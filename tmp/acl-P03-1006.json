{
  "info": {
    "authors": [
      "Cyril Allauzen",
      "Mehryar Mohri",
      "Brian Roark"
    ],
    "book": "Annual Meeting of the Association for Computational Linguistics",
    "id": "acl-P03-1006",
    "title": "Generalized Algorithms for Constructing Statistical Language Models",
    "url": "https://aclweb.org/anthology/P03-1006",
    "year": 2003
  },
  "references": [
    "acl-J92-4003",
    "acl-J94-3001",
    "acl-J97-2003",
    "acl-P96-1031"
  ],
  "sections": [
    {
      "heading": "Abstract",
      "text": [
        "Recent text and speech processing applications such as speech mining raise new and more general problems related to the construction of language models.",
        "We present and describe in detail several new and efficient algorithms to address these more general problems and report experimental results demonstrating their usefulness.",
        "We give an algorithm for computing efficiently the expected counts of any sequence in a word lattice output by a speech recognizer or any arbitrary weighted automaton; describe a new technique for creating exact representations of n-gram language models by weighted automata whose size is practical for offline use even for a vocabulary size of about 500,000 words and an n-gram order n = 6; and present a simple and more general technique for constructing class-based language models that allows each class to represent an arbitrary weighted automaton.",
        "An efficient implementation of our algorithms and techniques has been incorporated in a general software library for language modeling, the GRM Library, that includes many other text and grammar processing functionalities."
      ]
    },
    {
      "heading": "1 Motivation",
      "text": [
        "Statistical language models are crucial components of many modern natural language processing systems such as speech recognition, information extraction, machine translation, or document classification.",
        "In all cases, a language model is used in combination with other information sources to rank alternative hypotheses by assigning them some probabilities.",
        "There are classical techniques for constructing language models such as n-gram models with various smoothing techniques (see Chen and Goodman (1998) and the references therein for a survey and comparison of these techniques).",
        "In some recent text and speech processing applications, several new and more general problems arise that are related to the construction of language models.",
        "We present new and efficient algorithms to address these more general problems.",
        "Counting.",
        "Classical language models are constructed by deriving statistics from large input texts.",
        "In speech mining applications or for adaptation purposes, one often needs to construct a language model based on the output of a speech recognition system.",
        "But, the output of a recognition system is not just text.",
        "Indeed, the word error rate of conversational speech recognition systems is still too high in many tasks to rely only on the one-best output of the recognizer.",
        "Thus, the word lattice output by speech recognition systems is used instead because it contains the correct transcription in most cases.",
        "A word lattice is a weighted finite automaton (WFA) output by the recognizer for a particular utterance.",
        "It contains typically a very large set of alternative transcription sentences for that utterance with the corresponding weights or probabilities.",
        "A necessary step for constructing a language model based on a word lattice is to derive the statistics for any given sequence from the lattices or WFAs output by the recognizer.",
        "This cannot be done by simply enumerating each path of the lattice and counting the number of occurrences of the sequence considered in each path since the number of paths of even a small automaton may be more than four billion.",
        "We present a simple and efficient algorithm for computing the expected count of any given sequence in a WFA and report experimental results demonstrating its efficiency.",
        "Representation of language models by WFAs.",
        "Classical n-gram language models admit a natural representation by WFAs in which each state encodes a left context of width less than n. However, the size of that representation makes it impractical for offline optimizations such as those used in large-vocabulary speech recognition or general information extraction systems.",
        "Most offline representations of these models are based instead on an approximation to limit their size.",
        "We describe a new technique for creating an exact representation of n-gram language models by WFAs whose size is practical for offline use even in tasks with a vocabulary size of about 500,000"
      ]
    },
    {
      "heading": "words and for n = 6.",
      "text": [
        "Class-based models.",
        "In many applications, it is natural and convenient to construct class-based language models, that is models based on classes of words (Brown et al., 1992).",
        "Such models are also often more robust since they may include words that belong to a class but that were not found in the corpus.",
        "Classical class-based models are based on simple classes such as a list of words.",
        "But new clustering algorithms allow one to create more general and more complex classes that may be regular languages.",
        "Very large and complex classes can also be defined using regular expressions.",
        "We present a simple and more general approach to class-based language models based on general weighted context-dependent rules (Kaplan and Kay, 1994; Mohri and Sproat, 1996).",
        "Our approach allows us to deal efficiently with more complex classes such as weighted regular languages.",
        "We have fully implemented the algorithms just mentioned and incorporated them in a general software library for language modeling, the GRM Library, that includes many other text and grammar processing functionalities (Allauzen et al., 2003).",
        "In the following, we will present in detail these algorithms and briefly describe the corresponding GRM utilities."
      ]
    },
    {
      "heading": "2 Preliminaries",
      "text": []
    },
    {
      "heading": "Definition 1 A system (K, (D, ®, 0,1) is a semiring",
      "text": [
        "(Kuich and Salomaa, 1986) if: (K, (D, 0) is a commutative monoid with identity element 0; (Y\" ®, 1) is a monoid with identity element 1; ® distributes over ®; and 0 is an annihilatorfor ®: for all a E K, a ® 0 = 0 ® a = 0.",
        "Thus, a semiring is a ring that may lack negation.",
        "Two semirings often used in speech processing are: the log semiring L = (R U {oo}, (Dlog, +, oo, 0) (Mohri, 2002) which is isomorphic to the familiar real or probability semiring (R+, +, x, 0, 1) via a log morphism with, for all a, b E RU {oo}: a ®iog b = – log(exp( – a) + exp( – b)) and the convention that: exp( – oo) = 0 and – log(0) = oo, and the tropical semiring T = (R+ U {oo}, min, +, oo, 0) which can be derived from the log semiring using the Viterbi approximation.",
        "Definition 2 A weighted finite-state transducer T over a semiring K is an 8-tuple T = (E, A, Q, I, F, E, A, p) where: E is the finite input alphabet of the transducer; A is the finite output alphabet; Q is a finite set of states;",
        "set of transitions; A : I – � K the initial weight function; and p : F – � K the final weight function mapping F to .",
        "A Weighted automaton A = (E, Q, I, F, E, A, p) is defined in a similar way by simply omitting the output labels.",
        "We denote by L (A) C E * the set of strings accepted by an automaton A and similarly by L (X) the strings described by a regular expression X.",
        "Given a transition e E E, we denote by i [e] its input label, p[e] its origin or previous state and n[e] its destination state or next state, w[e] its weight, o[e] its output label (transducer case).",
        "Given a state q E Q, we denote by E[q] the set of transitions leaving q.",
        "A path 7r = e1 • • • ek is an element of E* with consecutive transitions: n[e2_1] = p[ei], i = 2, ... , k. We extend n and p to paths by setting: n[7r] = n[ek] and p[7r] = p[e1].",
        "A cycle 7r is a path whose origin and destination states coincide: n[7r] = p[7r].",
        "We denote by P(q, q') the set of paths from q to q' and by P(q, x, q') and P(q, x, y, q') the set of paths from q to q' with input label x E E* and output label y (transducer case).",
        "These definitions can be extended to subsets R, R' C_ Q, by: P(R, x, R') = UgGR, q'ERAP(q, x, q').",
        "The labeling functions i (and similarly o) and the weight function w can also be extended to paths by defining the label of a path as the concatenation of the labels of its constituent transitions, and the weight of a path as the 0-product of the weights of its constituent transitions:",
        "larly, the output weight associated by a transducer T to a pair of input-output string (x, y) is:",
        "path in a weighted automaton or transducer M is a path from an initial state to a final state.",
        "M is unambiguous if for any string x E E * there is at most one successful path labeled with x.",
        "Thus, an unambiguous transducer defines a function.",
        "For any transducer T, denote by 112 (T) the automaton obtained by projecting T on its output, that is by omitting its input labels.",
        "Note that the second operation of the tropical semiring and the log semiring as well as their identity elements are identical.",
        "Thus the weight of a path in an automaton A over the tropical semiring does not change if A is viewed as a weighted automaton over the log semiring or vice-versa."
      ]
    },
    {
      "heading": "3 Counting",
      "text": [
        "This section describes a counting algorithm based on general weighted automata algorithms.",
        "Let A = (Q, I, F, E, 6, Q, A, p) be an arbitrary weighted automaton over the probability semiring and let X be a regular expression defined over the alphabet E. We are interested in counting the occurrences of the sequences x E L (X) in A while taking into account the weight of the paths where they appear."
      ]
    },
    {
      "heading": "3.1 Definition",
      "text": [
        "When A is deterministic and pushed, or stochastic, it can be viewed as a probability distribution P over all strings",
        "E*.1 The weight QA� (x) associated by A to each string x is then P(x).",
        "Thus, we define the count of the sequence x in A, c(x), as:",
        "where I u I x denotes the number of occurrences of x in the string u, i.e., the expected number of occurrences of x given A.",
        "More generally, we will define the count of x as above regardless of whether A is stochastic or not.",
        "In most speech processing applications, A may be an acyclic automaton called a phone or a word lattice output by a speech recognition system.",
        "But our algorithm is general and does not assume A to be acyclic."
      ]
    },
    {
      "heading": "3.2 Algorithm",
      "text": [
        "We describe our algorithm for computing the expected counts of the sequences x E L (X) and give the proof of its correctness.",
        "Lemma 1 For all w E E*, (S, w) _ JwI x.",
        "Proof.",
        "By definition of the multiplication of power series in the probability semiring:",
        "This proves the lemma.",
        "S is a rational power series as a product and closure of the polynomial power series Q and x (Salomaa and Soit-tola, 1978; Berstel and Reutenauer, 1988).",
        "Similarly, since X is regular, the weighted transduction defined by",
        "theorem of Sch¨utzenberger (Sch¨utzenberger, 1961), there exists a weighted transducer T defined over the alphabet E and the probability semiring realizing that transduction.",
        "Figure 1 shows the transducer T in the particular case of E _ {a, b}.",
        "1 There exist a general weighted determinization and weight pushing algorithms that can be used to create a deterministic and pushed automaton equivalent to an input word or phone lattice (Mohri, 1997).",
        "The proposition gives a simple algorithm for computing the expected counts of X in a weighted automaton A based on two general algorithms: composition (Mohri et al., 1996) and projection of weighted transducers.",
        "It is also based on the transducer T which is easy to construct.",
        "The size of T is in O (1 E I + J AX ), where AX is a finite automaton accepting X.",
        "With a lazy implementation of T, only one transition can be used instead of I E 1, thereby reducing the size of the representation of T to O (1 A x ).",
        "The weighted automaton B = 112 (A o T) contains e-transitions.",
        "A general e-removal algorithm can be used to compute an equivalent weighted automaton with no E-transition.",
        "The computation of QB� (x) for a given x is done by composing B with an automaton representing x and by using a simple shortest-distance algorithm (Mohri, 2002) to compute the sum of the weights of all the paths of the result.",
        "For numerical stability, implementations often replace probabilities with – log probabilities.",
        "The algorithm just described applies in a similar way by taking – log of the weights of T (thus all the weights of T will be zero in that case) and by using the log semiring version of composition and e-removal."
      ]
    },
    {
      "heading": "3.3 GRM Utility and Experimental Results",
      "text": [
        "An efficient implementation of the counting algorithm was incorporated in the GRM library (Allauzen et al., 2003).",
        "The GRM utility grmcount can be used in particular to generate a compact representation of the expected counts of the n-gram sequences appearing in a word lattice (of which a string encoded as an automaton is a special case), whose order is less or equal to a given integer.",
        "As an example, the following command line: grmcount -n3 foo.fsm > count.fsm creates an encoded representation count.",
        "f sm of the n-gram sequences, n < 3, which can be used to construct a trigram model.",
        "The encoded representation itself is also given as an automaton that we do not describe here.",
        "The counting utility of the GRM library is used in a variety of language modeling and training adaptation tasks.",
        "= IwIX Our experiments show that grmcount is quite efficient.",
        "We tested this utility with 41,000 weighted automata outputs of our speech recognition system for the same number of speech utterances.",
        "The total number of transitions of these automata was 18.8M.",
        "It took about 1h52m, including I/O, to compute the accumulated expected counts of all n-gram, n < 3, appearing in all these automata on a single processor of a 1GHz Intel Pentium processor Linux cluster with 2GB of memory and 256 KB cache.",
        "The time to compute these counts represents just 50 th of the total duration of the 41,000 speech utterances used in our experiment."
      ]
    },
    {
      "heading": "4 Representation of n-gram Language Models with WFAs",
      "text": [
        "Standard smoothed n-gram models, including backoff (Katz, 1987) and interpolated (Jelinek and Mercer, 1980) models, admit a natural representation by WFAs in which each state encodes a conditioning history of length less than n. The size of that representation is often prohibitive.",
        "Indeed, the corresponding automaton may have E n-1 states and 1EIn transitions.",
        "Thus, even if the vocabulary size is just 1,000, the representation of a classical trigram model may require in the worst case up to one billion transitions.",
        "Clearly, this representation is even less adequate for realistic natural language processing applications where the vocabulary size is in the order of several hundred thousand words.",
        "In the past, two methods have been used to deal with this problem.",
        "One consists of expanding that WFA on-demand.",
        "Thus, in some speech recognition systems, the states and transitions of the language model automaton are constructed as needed based on the particular input speech utterances.",
        "The disadvantage of that method is that it cannot benefit from offline optimization techniques that can substantially improve the efficiency of a recognizer (Mohri et al., 1998).",
        "A similar drawback affects other systems where several information sources are combined such as a complex information extraction system.",
        "An alternative method commonly used in many applications consists of constructing instead an approximation of that weighted automaton whose size is practical for offline optimizations.",
        "This method is used in many large-vocabulary speech recognition systems.",
        "In this section, we present a new method for creating an exact representation of n-gram language models with WFAs whose size is practical even for very large-vocabulary tasks and for relatively high n-gram orders.",
        "Thus, our representation does not suffer from the disadvantages just pointed out for the two classical methods.",
        "We first briefly present the classical definitions of n-gram language models and several smoothing techniques commonly used.",
        "We then describe a natural representation of n-gram language models usingfailure transitions.",
        "This is equivalent to the on-demand construction referred to above but it helps us introduce both the approximate solution commonly used and our solution for an exact offline representation."
      ]
    },
    {
      "heading": "4.1 Classical Definitions",
      "text": [
        "In an n-gram model, the joint probability of a string wo ... wk is given as the product of conditional probabilities:",
        "where the conditioning history hi consists of zero or more words immediately preceding w2 and is dictated by the order of the n-gram model.",
        "Let c(hw) denote the count of n-gram hw and let Pr(wlh) be the maximum likelihood probability of w given h, estimated from counts.",
        "Pr is often adjusted to reserve some probability mass for unseen n-gram sequences.",
        "Denote by Pr(wlh) the adjusted conditional probability.",
        "Katz or absolute discounting both lead to an adjusted probability Pr.",
        "For all n-grams h = wh' where h E Ek for some k > 1, we refer to h' as the backoff n-gram of h. Conditional probabilities in a backoff model are of the form:",
        "where ah is a factor that ensures a normalized model.",
        "Conditional probabilities in a deleted interpolation model are of the form:",
        "where ah is the mixing parameter between zero and one.",
        "In practice, as mentioned before, for numerical stability, – log probabilities are used.",
        "Furthermore, due the Viterbi approximation used in most speech processing applications, the weight associated to a string x by a weighted automaton representing the model is the minimum weight of a path labeled with x.",
        "Thus, an n-gram language model is represented by a WFA over the tropical semiring."
      ]
    },
    {
      "heading": "4.2 Representation with Failure Transitions",
      "text": [
        "Both backoff and interpolated models can be naturally represented using default or failure transitions.",
        "A failure transition is labeled with a distinct symbol 0.",
        "It is the default transition taken at state q when q does not admit an outgoing transition labeled with the word considered.",
        "Thus, failure transitions have the semantics of otherwise.",
        "The set of states of the WFA representing a backoff or interpolated model is defined by associating a state qh to each sequence of length less than n found in the corpus:",
        "Its transition set E is defined as the union of the following set of failure transitions: f(gwh', 0, - 109(a'h), qh') : qwh' E Q and the following set of regular transitions: {(qh, w, – log(Pr(w1h)), nh.)",
        ": qh E Q, c(hw) > 01 where nh,, is defined by:",
        "if jhwl = n where h = w'h' 4 Figure 2 illustrates this construction for a trigram model.",
        "Treating e-transitions as regular symbols, this is a deterministic automaton.",
        "Figure 3 shows a complete Katz backoffbigram model built from counts taken from the following toy corpus and using failure transitions:",
        "(s) b a a a a(/s) (s) b a a a a(/s) (s) a (/s)",
        "where (s) denotes the start symbol and (/s) the end symbol for each sentence.",
        "Note that the start symbol (s) does not label any transition, it encodes the history (s).",
        "All transitions labeled with the end symbol (/s) lead to the single final state of the automaton."
      ]
    },
    {
      "heading": "4.3 Approximate Offline Representation",
      "text": [
        "The common method used for an offline representation of an n-gram language model can be easily derived from the representation using failure transitions by simply replacing each 0-transition by an e-transition.",
        "Thus, a transition that could only be taken in the absence of any other alternative in the exact representation can now be taken regardless of whether there exists an alternative transition.",
        "Thus the approximate representation may contain paths whose weight does not correspond to the exact probability of the string labeling that path according to the model.",
        "Consider for example the start state in figure 3, labeled with (s).",
        "In a failure transition model, there exists only one path from the start state to the state labeled a, with a cost of 1.108, since the 0 transition cannot be traversed with an input of a.",
        "If the 0 transition is replaced by an e-transition, there is a second path to the state labeled a – taking the e-transition to the history-less state, then the a transition out of the history-less state.",
        "This path is not part of the probabilistic model – we shall refer to it as an invalid path.",
        "In this case, there is a problem, because the cost of the invalid path to the state – the sum of the two transition costs (0.672) – is lower than the cost of the true path.",
        "Hence the WFA with e-transitions gives a lower cost (higher probability) to all strings beginning with the symbol a.",
        "Note that the invalid path from the state labeled (s) to the state labeled b has a higher cost than the correct path, which is not a problem in the tropical semiring."
      ]
    },
    {
      "heading": "4.4 Exact Offline Representation",
      "text": [
        "This section presents a method for constructing an exact offline representation of an n-gram language model whose size remains practical for large-vocabulary tasks.",
        "The main idea behind our new construction is to modify the topology of the WFA to remove any path containing e-transitions whose cost is lower than the correct cost associated by the model to the string labeling that path.",
        "Since, as a result, the low cost path for each string will have the correct cost, this will guarantee the correctness of the representation in the tropical semiring.",
        "Our construction admits two parts: the detection of the invalid paths of the WFA, and the modification of the topology by splitting states to remove the invalid paths.",
        "To detect invalid paths, we determine first their initial none transitions.",
        "Let EE denote the set of e-transitions of the original automaton.",
        "Let Pq be the set of all paths",
        "Lemma 2 For an n gram language model, the number ofpaths in Pq is less than the n-gram order: I Pq I < n. Proof.",
        "For all 7ri E Pq, let 7ri = 7r�'ei.",
        "By definition, there is some e2 E EE such that n[e2] = p[ei] = qha.",
        "By definition of e-transitions in the model, I h i < n – 1 for all i.",
        "It follows from the definition of regular transitions that n[ei] = qha,, = q.",
        "Hence, hi = hj = h, i.e. ei ="
      ]
    },
    {
      "heading": "7r E PT, and either (i) r' = r and w[e7r] < w[7r'] or (ii)",
      "text": [
        "i[e'] = E and w[e7r] < w[7r'e'].",
        "ej = e, for all 7r2, 7rj E Pq.",
        "Then, Pq = {Ire : 7r E Pq, } U {e}.",
        "The history-less state has no incoming non-E paths, therefore, by recursion, jPqj= Pqh I + 1 = jhwl< n. ❑ We now define transition sets Dqq' (originally empty) following this procedure: for all states r E Q and all",
        "and i[7r'] = i[7r], and either (i) n[7r'] = n[7r] and w[e7r] < w[7r'] or (ii) there exists e' E EE such that p[e'] = n[7r'] and n[e'] = n[7r] and w[e7r] < w[7r'e'], then we add el to the set: DP[_]P[_,] +- DP[_]P[_,] U {ei}.",
        "See figure 4 for an illustration of this condition.",
        "Using this procedure, we can determine the set: E[q] = {e E E[q] : ]q', e E Dggl }.",
        "This set provides the first non-E transition of each invalid path.",
        "Thus, we can use these transitions to eliminate invalid paths.",
        "Proposition 2 The cost ofthe construction of E[q]for all q E Q is n2 I E I I Q 1, where n is the n-gram order.",
        "Proof.",
        "For each q E Q and each 7r E Pq, there are at most AEI possible states q' such that for some e E EE, p[e] = q' and n[e] = q.",
        "It is trivial to see from the proof of lemma 2 that the maximum length of 7r is n. Hence, the cost of finding all 7r' for a given 7r is n I E 1.",
        "Therefore, the total cost is n2 I E I I Q 1.",
        "For all non-empty E[q], we create a new state q and for all e E E[q] we set p[e] = q\".",
        "We create a transition (q, E, 0, q), and for all e E E – EE such that n[e] = q, we set n[e] = q\".",
        "For all e E EE such that n[e] = q and JDgP[e] I = 0, we set n[e] = q\".",
        "For all e E EE such that n[e] = q and lDgP[e] I > 0, we create a new intermediate backoff state q and set n[e] = q; then for all e' E E[q], if e' � Dgp[e], we add a transition e = (q, i[e'], w[e'], n[e']) to E. Proposition 3 The WFA over the tropical semiring mod-ifiedfollowing the procedurejust outlined is equivalent to the exact online representation with failure transitions.",
        "Proof.",
        "Assume that there exists a string s for which the WFA returns a weight iv(s) less than the correct weight w(s) that would have been assigned to s by the exact online representation with failure transitions.",
        "We will call an E-transition e2 within a path 7r = el ... ek invalid if the next non-E transition ej, j > i, has the label w, and there is a transition e with p[e] = p[ei] and",
        "i[e] = w. Let 7r be a path through the WFA such that i[7r] = s and w[7r] = iv(s), and 7r has the least number of invalid E-transitions of all paths labeled with s with weight w(s).",
        "Let e2 be the last invalid E-transition taken in path 7r.",
        "Let 7r' be the valid path leaving p[e j] such that",
        "there would be a path with fewer invalid E-transitions with weight w(s).",
        "Let r be the first state where paths 7r' and e2+1 ... ek intersect.",
        "Then r = n[ej] for some j > i.",
        "By definition, e2+1 ... ej E PT, since intersection will occur before any E-transitions are traversed in 7r.",
        "Then it must be the case that ei+i E Dn[ei]P[ei], requiring the path to be removed from the WFA.",
        "This is a contradiction."
      ]
    },
    {
      "heading": "4.5 GRM Utility and Experimental Results",
      "text": [
        "Note that some of the new intermediate backoff states (q) can be fully or partially merged, to reduce the space requirements of the model.",
        "Finding the optimal configuration of these states, however, is an NP-hard problem.",
        "For our experiments, we used a simple greedy approach to sharing structure, which helped reduce space dramatically.",
        "Figure 5 shows our example bigram model, after application of the algorithm.",
        "Notice that there are now two history-less states, which correspond to q and q\" in the algorithm (no q was required).",
        "The start state backs off to q, which does not include a transition to the state labeled a, thus eliminating the invalid path.",
        "Table 1 gives the sizes of three models in terms of transitions and states, for both the failure transition and E-transition encoding of the model.",
        "The DARPA North American Business News (NAB) corpus contains 250 million words, with a vocabulary of 463,331 words.",
        "The Switchboard training corpus has 3.1 million words, and a vocabulary of 45,643.",
        "The number of transitions needed for the exact offline representation in each case was between 2 and 3 times the number of transitions used in the representation with failure transitions, and the number of states was less than twice the original number of states.",
        "This shows that our technique is practical even for very large tasks.",
        "Efficient implementations of model building algorithms have been incorporated into the GRM library.",
        "The GRM utility grmmake produces basic backoff models, using Katz or Absolute discounting (Ney et al., 1994) methods, in the topology shown in fig",
        "ure 3, with e-transitions in the place of failure transitions.",
        "The utility grmshrink removes transitions from the model according to the shrinking methods of Seymore and Rosenfeld (1996) or Stolcke (1998).",
        "The utility grmconvert takes a backoff model produced by grmmake or grmshrink and converts it into an exact model using either failure transitions or the algorithm just described.",
        "It also converts the model to an interpolated model for use in the tropical semiring.",
        "As an example, the following command line: grmmake -n3 counts.fsm > model.fsm creates a basic Katz backoff trigram model from the counts produced by the command line example in the earlier section.",
        "The command:",
        "shrinks the trigram model using the weighted difference method (Seymore and Rosenfeld, 1996) with a threshold of 1.",
        "Finally, the command: grmconvert -tfail m.s1.fsm > f.s1.fsm outputs the model represented with failure transitions."
      ]
    },
    {
      "heading": "5 General class-based language modeling",
      "text": [
        "Standard class-based or phrase-based language models are based on simple classes often reduced to a short list of words or expressions.",
        "New spoken-dialog applications require the use of more sophisticated classes either derived from a series of regular expressions or using general clustering algorithms.",
        "Regular expressions can be used to define classes with an infinite number of elements.",
        "Such classes can naturally arise, e.g., dates form an infinite set since the year field is unbounded, but they can be easily represented or approximated by a regular expression.",
        "Also, representing a class by an automaton can be much more compact than specifying them as a list, especially when dealing with classes representing phone numbers or a list of names or addresses.",
        "This section describes a simple and efficient method for constructing class-based language models where each class may represent an arbitrary (weighted) regular language.",
        "Let c1, c2 �... �cn be a set of n classes and assume that each class c2 corresponds to a stochastic weighted automaton AZ defined over the log semiring.",
        "Thus, the weight [Ail (w) associated by AZ to a string w can be interpreted as – log of the conditional probability P(wI ci).",
        "Each class c2 defines a weighted transduction: AZ --+ c2 This can be viewed as a specific obligatory weighted context-dependent rewrite rule where the left and right contexts are not restricted (Kaplan and Kay, 1994; Mohri and Sproat, 1996).",
        "Thus, the transduction corresponding to the class c2 can be viewed as the application of the following obligatory weighted rewrite rule:",
        "X can be made stochastic using a pushing algorithm (Mohri, 1997).",
        "In general, the transducer T may not be unambiguous.",
        "Thus, the result of the application of the class rules to the corpus may not be a single text but an automaton representing a set of alternative sequences.",
        "However, this is not an issue since we can use the general counting algorithm previously described to construct a language model based on a weighted automaton.",
        "When",
        "a code, the transducer T is unambiguous.",
        "Denote now by G the language model constructed from the new corpus X.",
        "To construct our final class-based language model G, we simply have to compose G with T-1 and project the result on the output side: G=r12(GoT-1) A more general approach would be to have two transducers T1 and T2, the first one to be applied to the corpus and the second one to the language model.",
        "In a probabilistic interpretation, T1 should represent the probability distribution P(ci l w) and T2 the probability distribution P(wlc2).",
        "By using T1 = T and T2 = T-1, we are in fact making the assumptions that the classes are equally probable and thus that P(cilw) = P(wIc2)/E 1P(wlcj).",
        "More generally, the weights of T1 and T2 could be the results of an iterative learning process.",
        "Note however that",
        "Let T be the weighted transducer obtained by compiling the rules corresponding to the classes.",
        "The corpus can be represented as a finite automaton X.",
        "To apply the rules defining the classes to the input corpus, we just need to compose the automaton X with T and project the result on the output:",
        "we are not limited to this probabilistic interpretation and that our approach can still be used if Tl and T2 do not represent probability distributions, since we can always push X and normalize G. Example.",
        "We illustrate this construction in the simple case of the following class containing movie titles: ✪movie✰= f (batman, 0.6), (batman returns, 0.❛) } The compilation of the rewrite rule defined by this class and applied left to right leads to the weighted transducer T given by figure 6.",
        "Our corpus simply consists of the sentence “batman returns” and is represented by the automaton X given by figure 7.",
        "The corpus X obtained by composing X with T is given by figure 7."
      ]
    },
    {
      "heading": "6 Conclusion",
      "text": [
        "We presented several new and efficient algorithms to deal with more general problems related to the construction of language models found in new language processing applications and reported experimental results showing their practicality for constructing very large models.",
        "These algorithms and many others related to the construction of weighted grammars have been fully implemented and incorporated in a general grammar software library, the GRM Library (Allauzen et al., 2003)."
      ]
    },
    {
      "heading": "Acknowledgments",
      "text": [
        "We thank Michael Riley for discussions and for having implemented an earlier version of the counting utility."
      ]
    }
  ]
}
