{
  "info": {
    "authors": [
      "Hirosi Tuda",
      "Koiti Hasida",
      "Hidetosi Sirai"
    ],
    "book": "Conference of the European Association for Computational Linguistics",
    "id": "acl-E89-1013",
    "title": "JPSG Parser on Constraint Logic Programming",
    "url": "https://aclweb.org/anthology/E89-1013",
    "year": 1989
  },
  "references": [
    "acl-C86-1018"
  ],
  "sections": [
    {
      "heading": "Abstract",
      "text": [
        "This paper presents a constraint logic programming language cu-Prolog and introduces a simple Japanese parser based on Japanese Phrase Structure Grammar (JPSG) as a suitable application of cu-Prolog.",
        "cu-Prolog adopts constraint unification instead of the normal Prolog unification.",
        "In cu-Prolog, constraints in terms of user defined predicates can be directly added to the program clauses.",
        "Such a clause is called Constraint Added Horn Clause (CAHC).",
        "Unlike conventional CLP systems, cu-Prolog deals with constraints about symbolic or combinatorial objects.",
        "For natural language processing, such constraints are more important than those on numerical or boolean objects.",
        "In comparison with normal Prolog, cu-Prolog has more descriptive power, and is more declarative.",
        "It enables a natural implementation of JPSG and other unification based grammar formalisms."
      ]
    },
    {
      "heading": "1 Introduction",
      "text": [
        "Prolog is frequently used in implementing natural language parsers or generators based on unification based grammars.",
        "This is because Prolog is also based on unification, and therefore has a declarative feature.",
        "One important characteristic of unification based grammar is also a declarative grammar formalization [11].",
        "However, Prolog does not have sufficient power of expressing constraints because it executes every parts of its programs as procedures and because every variable of Prolog can be instantiated with any objects.",
        "Hence, the constraints in unification based grammar are forced to be implemented not declaratively but procedurally.",
        "We developed a new constraint logic programming language cu-Prolog which is free from this defect of traditional Prolog [13].",
        "In cu-Prolog, user defined constraints can be directly added to a program clause (constraint added Horn clause), and the constraint unification [12, 8] 1 is adopted instead of the nor-lln these earlier papers, \"constraint unification\" was called \"conditioned unification.\" - 95 - mal unification.",
        "This paper discusses the outline of the cu-Prolog system, and presents a Japanese parser based on JPSG (Japanese Phrase Structure Grammar) [7] as a suitable application of cu-Prolog."
      ]
    },
    {
      "heading": "2 Constraint Added Horn Clause (CAHC)",
      "text": [
        "Most of the constraint logic programming language systems (CAL [2], PrologIll [5], etc.)",
        "deal with constraints about algebraic equations, i.e., constraints about numerical domains, such as that of real numbers etc.",
        "However, in the problems arising in Artificial Intelligence, constraints on symbolic or combinatorial objects are far more important than those on numerical objects.",
        "cu-Prolog handles constraints described in terms of sequence of atomic formulas of Prolog.",
        "The program clauses of cu-Prolog are following type, which we call Constraint Added Horn Clauses (CAHCs):",
        "(H is called the head, B1, B2, .. Bn is the body, C2, , Cm is the constraint.",
        "The body and the constraint can be empty.)",
        "C1, C2,..., Cm comprise a set of constraints on the variables occurring in the rest of the clause.",
        "C1, C2, ..., Cm must be, in the current implementation, modular in the sense that it has the following canonical form.",
        "[Def.]",
        "1 (modular) A sequence of atomic formulas CI, C2, , Cm is modular when",
        "1. every arguments of Ci is variable, and 2. no variable occurs in two distinct places, and 3. the predicate of C1 is modularly defined (1 < i < m).",
        "1. every argument of D is variable, 2. no variable occurs in two distinct space, and 3. every predicate occurring in D is p or modularl?",
        "defined.",
        "Seen from the declarative semantics, the progran clause of cu-Prolog is equivalent to the following pro gram clause of Prolog:"
      ]
    },
    {
      "heading": "3 cu-Prolog",
      "text": []
    },
    {
      "heading": "3.1 Constraint Unification",
      "text": [
        "cu-Prolog employs Constraint Unification [12, E which is the usual Prolog unification plus constrain transformation (normalization).",
        "Using constraint unification, the inference rule c cu-Prolog is as follows: Q,R;C. , Q' : – S;D., = mgu(Q ,Q1), B = m f (C8, DO) SO, RO; B (Q is an atomic formula.",
        "R, C, S, D, and B are sequences of atomic formulas.",
        "mgu(Q,Q') is a most general unifier between Q and Q'.)",
        "mf(C/,..., Cm) is a modular constraint which equivalent to C1, , Cm.",
        "If C1, , Cm is inconsil tent, mf(Ci, , Cm) is not defined.",
        "In this case, a above inference rule is inapplicable.",
        "For example, mf (member(X, [a, b, member(X , [6, c, d])) returns a new constraint cO(X), where the definition of c0 is c0(b).",
        "c0(c).",
        "and mf (member(X ,[a, c]), member(X , [k, 1, m])) is not undefined.",
        "This transformation is done by repeating unfold/fold transformations as described later."
      ]
    },
    {
      "heading": "3.2 Comparison with conventional approaches",
      "text": [
        "In normal Prolog, constraints are inserted in a goal and processed as procedures.",
        "It is not desirable for a declarative programming language, and the execution can be ineffective when constraints are inserted in a insufficient place.",
        "As constraints are rewritten at every unification, cu-Prolog has more powerful descriptive ability than the bind-hook technique.",
        "For example, freeze in Prolog II[4] can impose constraints on one variable, so that when the variable is instantiated, the constraints are executed as a procedure.",
        "Freeze has, however, two disadvantages.",
        "First, freeze cannot impose a constraint on plural variables at one time.",
        "For example, it cannot express the following CAHC.",
        "f (X), g(Y, Z); append(X, Y, Z).",
        "Second, since the contradiction between constraints is not detected until the variable is instantiated, there is a possibility of executing useless computation in constraints deadlocking.",
        "For example, X and Y are unifiable even after executing free ze(X , member(X , [a, b])) and",
        "and f (Y);member(Y, [u, v]).",
        "are not unifiable."
      ]
    },
    {
      "heading": "3.3 Constraint Transformation",
      "text": [
        "This subsection explains the mechanism of constraint transformation in cu-Prolog.",
        "Let T be definition clauses of modularly defined constraints, E be a set of constraints {C1, , that contains variables xl, ... , xn„ and p be a new m-ary predicate.",
        "Let V be definition clauses of new predicates, and",
        "and other new predicates are included through the constraint normalization.",
        "Then, mf(E) returns p(xi, , zrn), if there exists a sequence of program clauses",
        "and Pn is modularly defined, where Pi.f./ is derived from Pi (0 < i < n) by one of the following three types of transformations.",
        "1. unfold transformation",
        "Select one clause C from Pi and one atomic formula A from the body of C. Let C1, .",
        ".",
        ".",
        ", Cn be all the clauses whose heads unify with A, and C.`i be the result of applying Ci to A of C (j = 1, , n).",
        "Pi+i is obtained by replacing C in Pi with C[, , C'",
        "Let C (H : -B&R.) be a clause in Pi, where B is not modular and contains variables x1, , x„, and there are no common variables between B and R. Let p be a new m-ary predicate and the following clause E:",
        "and adding E. E is also added to V. The third transformation can be seen as a special case of fold transformation.",
        "Hence, these three transformations preserve the semantics of programs because unfold/fold transformation has been proved as valid [6].",
        "The following example shows a transformation of",
        "and E is {member(A, Z), append(X, Y, Z)}.",
        "The new predicate pl is defined as Di: pi(A,X,Y,Z):-member(A,Z),append(X,Y,Z).",
        "and",
        "These clauses comprise the modular definition of p2 Thus",
        "has been transformed to pl(A, X, Y, Z) preserving equivalence, and the following new clauses have been defined.",
        "{T4, TV, TV, T7, T8, T9, T1011."
      ]
    },
    {
      "heading": "3.4 Implementation",
      "text": [
        "The source code of cu-Prolog is, at present (Ver 2.0), composed of 4,500 lines of language C on UNIX system.",
        "Its precise computation speed is under evaluation, but is sufficient for practical use.",
        "Implementation of the effective constraint transformation shown in above subsection requires some heuristics in the application of three transformation.",
        "Especially, in unfold transformation, one atomic formula A is selected in the following heuristic rules",
        "1.",
        "The atomic formula of the finite predicate.",
        "2.",
        "The atomic formula that has constants or [ ] in its arguments.",
        "3.",
        "The atomic formula that has lists in its argument.",
        "4.",
        "The atomic formula that has plural dependencies.",
        "Here, [Def.]",
        "3 (finite predicate) A predicate p is finite, when the body of every definition clause of p is",
        "1. nil, or 2. expressed by finite predicates"
      ]
    },
    {
      "heading": "4 A JPSG parser",
      "text": [
        "As an application of cu-Prolog, a natural language parser based on unification based grammar has been considered first of all.",
        "Since constraints can be added directly to the program clause representing a lexical entry or a phrase structure rule, the grammar is implemented more naturally and declaratively than with ordinary Prolog.",
        "Here we describe a simple Japanese parser of JPSG in cu-Prolog.",
        "CAHC plays an important role in two respects.",
        "First, CAHC is used in the lexicon of homonyms or polysemic words.",
        "For example, a Japanese noun \"hasi\" is 3-way ambiguous, it means a bridge, chopsticks, or an edge.",
        "This polysemic word can be subsumed in the following single lexical entry.",
        "where hasi_sem is defined as follows.",
        "hasi_sem(bridge).",
        "hasi_sem(chopsticks).",
        "hasi_sem(edge).",
        "The value of the semantic feature is a variable (SEM), and the constraint on SEM is hasi_sem(SEM).",
        "Note that predicate hasi_sem is modularly defined.",
        "According to CAHC, such ambiguity may be considered at one time, instead of being divided in separate lexical entries.",
        "Japanese has such an ambiguity is also shown in conjugation, post positions, etc.",
        "They can be treated in this manner.",
        "Second, a phrase structure rule is written naturally in a CAHC.",
        "In JPSG [7], FFP(FOOT Feature Principle) is: The value of a FOOT feature of the mother unifies with the union of those of her daughters.",
        "This principle is embedded in a phrase structure rule as follows: psraslashMS],[slashLDS],[slashRDS]); union(LDS, RD S, MS).",
        "However, this cannot be described in this manner in traditional Prolog.",
        "Figure 2 shows a simple demonstration of our JPSG parser, and Figure 3 shows an example of treating ambiguity as constraint.",
        "The current parser treats a few feature and has little lexicon.",
        "However, the expansion is easy.",
        "It parses about ten to twenty words sentences within a second on VAX8600.",
        "Since JPSG is a declarative grammar formalism and cu-Prolog describes JPSG also declaratively, the parser needs parsing algorithms independently.",
        "In the current implementation, we adopt the left corner parsing algorithm [1].",
        "Furthermore, we would even be able to abandon parsing algorithm altogether [10]."
      ]
    },
    {
      "heading": "5 Final Remarks",
      "text": [
        "The further study of cu-Prolog has many prospects.",
        "For example, to expand descriptive ability of constraints, the negative operator or the universal quantifier can be added.",
        "The constraint-based, alias partial, aspects of Situation Semantics[3] are naturally implemented in terms of an extended version of cu-Prolog [9].",
        "For practical applications in Artificial Intelligence in general and natural language processing in particular, one needs a mechanism for carrying out computation partially, instead of totally as described above, where constraint transformation halts only when the constraint in question is entirely modular.",
        "So the most difficult problem one must tackle concerns itself with heuristics about how to control computation."
      ]
    },
    {
      "heading": "Acknowledgments",
      "text": [
        "This study owes much to our colleagues in the JPSG Working group at ICOT.",
        "The implementation of cu-Prolog is supported by ICOT and the Ministry of International Trade and Industry in Japan."
      ]
    }
  ]
}
