{
  "info": {
    "authors": [
      "John Dowding",
      "Beth Ann Hockey",
      "Jean Mark Gawron",
      "Christopher Culy"
    ],
    "book": "Annual Meeting of the Association for Computational Linguistics",
    "id": "acl-P01-1022",
    "title": "Practical Issues in Compiling Typed Unification Grammars for Speech Recognition",
    "url": "https://aclweb.org/anthology/P01-1022",
    "year": 2001
  },
  "references": [
    "acl-A00-1016",
    "acl-A00-2033",
    "acl-A97-1001",
    "acl-H94-1010",
    "acl-P85-1018",
    "acl-P91-1032",
    "acl-P93-1008",
    "acl-P96-1030",
    "acl-P98-1101"
  ],
  "sections": [
    {
      "heading": "Abstract",
      "text": [
        "Current alternatives for language modeling are statistical techniques based on large amounts of training data, and hand-crafted context-free or finite-state grammars that are difficult to build and maintain.",
        "One way to address the problems of the grammar-based approach is to compile recognition grammars from grammars written in a more expressive formalism.",
        "While theoretically straight-forward, the compilation process can exceed memory and time bounds, and might not always result in accurate and efficient speech recognition.",
        "We will describe and evaluate two approaches to this compilation problem.",
        "We will also describe and evaluate additional techniques to reduce the structural ambiguity of the language model."
      ]
    },
    {
      "heading": "1 Introduction",
      "text": [
        "Language models to constrain speech recognition are a crucial component of interactive spoken language systems.",
        "The more varied the language that must be recognized, the more critical good language modeling becomes.",
        "Research in language modeling has heavily favored statistical approaches (Cohen 1995, Ward 1995, Hu et al.",
        "1996, Iyer and Ostendorf 1997, Bellegarda 1999, Stolcke and Shriberg 1996) while hand-coded finite-state or context-free language models dominate the commercial sector (Nuance 2001, SpeechWorks 2001, TellMe 2001, BeVocal2001, HeyAnita 2001, W3C 2001).",
        "The difference revolves around the availability of data.",
        "Research systems can achieve impressive performance using statistical language models trained on large amounts of domain-targeted data, but for many domains sufficient data is not available.",
        "Data may be unavailable because the domain has not been explored before, the relevant data may be confidential, or the system may be designed to do new functions for which there is no human-human analog interaction.",
        "The statistical approach is unworkable in such cases for both the commercial developers and for some research systems (Moore et al.",
        "1997, Rayner et al.",
        "2000, Lemon et al.",
        "2001, Gauthron and Colineau 1999).",
        "Even in cases for which there is no impediment to collecting data, the expense and time required to collect a corpus can be prohibitive.",
        "The existence of the ATIS database (Dahl et al.",
        "1994) is no doubt a factor in the popularity of the travel domain among the research community for exactly this reason.",
        "A major problem with grammar-based finite-state or context-free language models is that they can be tedious to build and difficult to maintain, as they can become quite large very quickly as the scope of the grammar increases.",
        "One way to address this problem is to write the grammar in a more expressive formalism and generate an approximation of this grammar in the format needed by the recognizer.",
        "This approach has been used in several systems, CommandTalk (Moore et al.",
        "1997), RIALIST PSA simulator (Rayner et al.",
        "2000), WITAS (Lemon et al.",
        "2001), and SETHIVoice (Gauthron and Colineau 1999).",
        "While theoretically straight-forward, this approach is more demanding in practice, as each of the compilation stages contains the potential for a combinatorial explosion that will exceed memory and time bounds.",
        "There is also no guarantee that the resulting language model will lead to accurate and efficient speech recognition.",
        "We will be interested in this paper in sound approximations (Pereira and Wright 1991) in which the language accepted by the approximation is a superset of language accepted by the original grammar.",
        "While we conceed that alternative techniques that are not sound (Black 1989, (Johnson 1998, Rayner and Carter 1996) may still be useful for many purposes, we prefer sound approximations because there is no chance that the correct hypothesis will be eliminated.",
        "Thus, further processing techniques (for instance, N-best search) will still have an opportunity to find the optimal solution.",
        "We will describe and evaluate two compilation approaches to approximating a typed unification grammar with a context-free grammar.",
        "We will also describe and evaluate additional techniques to reduce the size and structural ambiguity of the language model."
      ]
    },
    {
      "heading": "2 Typed Unification Grammars",
      "text": [
        "Typed Unification Grammars (TUG), like HPSG (Pollard and Sag 1994) and Gemini (Dowding et al.",
        "1993) are a more expressive formalism in which to write formal grammars1.",
        "As opposed to atomic nonterminal symbols in a CFG, each nonterminal in a TUG is a complex feature structure (Shieber 1986) where features with values can be attached.",
        "For example, the rule: s[] --� np: [num=N] vp: [num=N] can be considered a shorthand for 2 context free rules (assuming just two values for number):",
        "This expressiveness allows us to write grammars with a small number of rules (from dozens to a few hundred) that correspond to grammars with large numbers of CF rules.",
        "Note that the approximation need not incorporate all of the features from the original grammar in order to provide a sound approximation.",
        "In particular, in order to derive a finite CF grammar, we will need to consider only those features that have a finite number of possible values, or at least consider only finitely many of the possible values for infinitely valued features.",
        "We can use the technique of restriction (Shieber 1985) to remove these features from our feature structures.",
        "Removing these features may give us a more permissive language model, but it will still be a sound approximation.",
        "The experimental results reported in this paper are based on a grammar under development at RIACS for a spoken dialogue interface to a semi-autonomous robot, the Personal Satellite Assistant (PSA).",
        "We consider this grammar to be medium-sized, with 61 grammar rules and 424 lexical entries.",
        "While this may sound small, if the grammar were expanded by instantiating variables in all legal permutations, it would contain over 6.825 context-free rules."
      ]
    },
    {
      "heading": "3 The Compilation Process",
      "text": [
        "We will be studying the compilation process to convert typed unification grammars expressed in Gemini notation into language models for use with the Nuance speech recognizer (Nuance, 2001).",
        "We are using Nuance in part because it supports context-free language models, which is not yet industry standard.2 Figure 1 illustrates the stages of processing: a typed unification grammar is first compiled to a context-free grammar.",
        "This is in turn converted into a grammar in Nuance’s Grammar Specification Language (GSL), which is a form of context-free grammar in a BNF-like notation, with one rule defining each nonterminal, and allowing alternation and Kleene closure on the right-hand-side.",
        "Critically, the GSL must not contain any left-recursion, which must be eliminated before the GSL representation is produced.",
        "The GSL representation is then compiled into a Nuance package with the nuance compiler.",
        "This package is the input to the speech recognizer.",
        "In our experience, each of the compilation stages, as well as speech recognition itself, has the potential to lead to a combinatorial explosion that exceeds practical memory or time bounds.",
        "We will now describe implementations of the first stage, generating a context-free grammar from a typed unification grammar, by two different algorithms, one defined by Kiefer and Krieger (2000) and one by Moore and Gawron, described in Moore (1998) The critical difficulty for both of these approaches is how to select the set of derived nonterminals that will appear in the final CFG."
      ]
    },
    {
      "heading": "3.1 Kiefer&Krieger’s Algorithm",
      "text": [
        "The algorithm of Kiefer&Krieger (K&K) divides this compilation step into two phases: first, the set of context-free nonterminals is determined by iterating a bottom-up search until a least fixed-point is reached; second, this least fixed-point is used to instantiate the set of context-free productions.",
        "The computation of the fixed-point T, described in Table 1, proceeds as follows.",
        "First, To is constructed by finding the most-general set of feature structures that occur in the lexicon L (lines 1-4).",
        "Each feature structure has the lexical restric-tor L applied to it before being added to To (line 3) with the U E: operator.",
        "This operator maintains the set To of most-general feature structures.",
        "A new feature structure is added to the set only when it is not subsumed by any current members of the set, and any current members that are subsumed by the new member are removed as the new element is added.",
        "The computation of T proceeds with the call to Iterate (line 6), which adds new feature structures that can be derived bottom-up.",
        "Each call to Iterate generates a new set Ti+1, including Ti as its base (line 8).",
        "It then adds new feature structures to Ti+1 by instantiating every grammar rule r in R, the set of grammar rules.",
        "The first step in the instantiation is to unify every combination of daughters with all possible feature structures from Ti (FillDaughters, line 10).",
        "The rule restrictor is applied to each resulting feature structure (line 11) before it is added to Ti+1 using the UE: operator (line 12), similar to the lexical case.",
        "If after checking all rule applications bottom up, no new feature structures have been added to Ti+1 (line 13), then the least fixed-point had been found, and the process terminates.",
        "Otherwise, Iterate is called recursively.",
        "See Kiefer and Krieger (2000) for proof that this terminates, and finds the appropriate fixed-point.",
        "Having computed the least fixed-point T, the next step is to compute the set of corresponding CF productions.",
        "For each r in R, of the form t --� tl ... t, instantiate the daughters tl ... to using all combinations of unifiable feature structures from T. Context-free productions t --� tl ... t,, will be added, where �t E T and t subsumes t.3"
      ]
    },
    {
      "heading": "3.2 Moore and Gawron’s Algorithm",
      "text": [
        "While K&K uses subsumption to generate the set of most-general nonterminals, the algorithm of Moore and Gawron (M&G), described in Moore (1998) attempts to propagate features values both bottom-up and top-down through the grammar to generate a set of nonterminals that contains no variables.",
        "Also unlike K&K, the production of the CF rules and associated nonterminals is interleaved.",
        "The process consists of a preprocessing stage to eliminate singleton variables, a bottom-up propagation stage, and a top-down propagation stage.",
        "The preprocessing stage rewrites the grammar to eliminate singleton variables.",
        "This step effective replaces singleton variables with a new unique atomic symbol ’ANY’.",
        "The feature structure for each lexical item and grammar rule is rewritten such that singleton variables are unified with a special value ’ANY’, and every non-singleton variable expression is embedded in a val() term.",
        "After this transformation, singleton variables will not unify with non-singleton variable expressions, only with other singletons.",
        "Additional rules are then introduced to deal with the singleton variable cases.",
        "For each daughter in a grammar rule in which a singleton variable appears, new lexical items and grammar rules are introduced which unify with that daughter in the original grammar.",
        "As an example, consider the",
        "production in the approximation, but this may not be true if t was removed from T by UE:.",
        "Instead, the subsuming nonterminal i should be the new mother.",
        "grammar fragment: vp: [num=N] v: [num=N] np:[] np: [num=N] det: [num=N] n: [num=N] np: [num=pl] n: [num=pl] Here, the np object of vp is underspecified for num (as English does not generally require number agreement between the verb and its object), so it will be a singleton variable.",
        "So, the following rules will be generated: vp: [num=val(N)] --� v: [num=val(N)] np: [num=’ANY’] np: [num=val(N)] --� det: [num=val(N)] n: [num=val(N)] np: [num=val(pl)] n: [num=val(pl)] np:[num=’ANY’] det: [num=val(N)] n: [num=val(N)] np:[num=’ANY’] --� n:[num=val(pl)] After preprocessing, any variables remaining in the bodies of grammar rules will be shared variables.",
        "Singleton variable elimination by itself is very effective at shrinking the size of the CF grammar space, reducing the size of the rule space for the PSA grammar from 6.8x1025 rules to 4.2x1016 rules.",
        "The bottom-up stage starts from this grammar, and derives a new grammar by propagating feature values up from the lexicon.",
        "The process acts like a chart parser, except that indicies are not kept.",
        "When a rule transitions from an active edge to an inactive edge, a new rule with those feature instantiations is recorded.",
        "As a side-effect of this compilation, E-productions are eliminated.",
        "Top-down processing fires last, and performs a recursive-descent walk of the grammar starting atthe start symbol E, generating a new grammar that propagates features downward through the grammar.",
        "A side-effect of this computation is that useless-productions (rules not reachable from E) are removed.",
        "It might still be possible that after top-down propagation there would still be variables present in the grammar.",
        "For example, if the grammar allows sentences like “the deer walked”, which are ambiguous for number, then there will be a rule in the grammar that contains a shared variable for the number feature.",
        "To address this, as top-down propagation is progressing, all remaining variables are identified and unified with a special value ’ALL’.",
        "Since each nonterminal is now ground, it is trivial to assign each nonterminal a unique atomic symbol, and rewrite the grammar as a CFG."
      ]
    },
    {
      "heading": "3.3 Comparison",
      "text": [
        "Table 2 contains a summary of some key statistics generated using both techniques.",
        "The recognition results were obtained on a test set of 250 utterances.",
        "Recognition accuracy is measured in word error rate, and recognition speed is measured in multiples of real time (RT), the length of the utterance compared with the length of the CPU time required for the recognition result4.",
        "The size of the resulting language model is measured in terms of the number of nonterminals in the grammar, and the size of the Nuance node array, a binary representation of the recursive transition network it uses to search the grammar.",
        "Ambiguity counts the average number of parses per sentence that were allowed by the CF grammar.",
        "As can be readily seen, the compilation time for the K&K algorithm is dramatically lower than the M&G algorithm, while producing a similarly lower recognition performance, measured in both word error rate and recognition speed.",
        "Given that the two techniques generate grammars of roughly similar sizes, the difference in performance is striking.",
        "We believe that the use of the U E: in K&K is partially responsible.",
        "Consider a grammar that contains a lexical item like “deer” that is underspecified for number, and will contain a singleton variable.",
        "This will lead to a nonterminal feature structure for noun phrase that is also underspecified for number, which will be more general than any noun phrase feature structures that are marked for number.",
        "The U F operator will remove those noun phrases as being less general, effectively removing the number agreement constraint between subject and verb from the context-free approximation.",
        "The use of U E: allows a single grammar rule or lexical item to have non-local effects on the approximation.",
        "As seen in Table 2, the grammar derived from the K&K algorithm is much more ambiguous than the grammar derived the M&G algorithm, and, as is further elaborated",
        "in Section 4, we believe that the amount of ambiguity can be a significant factor in recognition performance.",
        "On the other hand, attention must be paid to the amount of time and memory required by the Moore algorithm.",
        "On a medium-sized grammar, this compilation step took over 3 hours, and was close to exceeding the memory capacity of our computer, with a process size of over 1GB.",
        "The approximation is only valuable if we can succeed in computing it.",
        "Finally, it should also be noted that M&G’s algorithm removes E-productions and useless-productions, while we had to add a separate postprocessing stage to K&K’s algorithm to get comparable results.",
        "For future work we plan to explore possible integrations of these two algorithms.",
        "One possibility is to include the singleton-elimination process as an early stage in the K&K algorithm.",
        "This is a relatively fast step, but may lead to a significant increase in the size of the grammar.",
        "Another possibility is to embed a variant of the K&K algorithm, and its clean separation of generating nonterminals from generating CF productions, in place of the bottom-up processing stage in M&G’s algorithm."
      ]
    },
    {
      "heading": "4 Reducing Structural Ambiguity",
      "text": [
        "It has been observed (Bratt and Stolcke 1999) that a potential difficulty with using linguistically-motivated grammars as language models is that ambiguity in the grammar will lead to multiple paths in the language model for the same recognition hypothesis.",
        "In a standard beam-search architecture, depending on the level of ambiguity, this may tend to fill the beam with multiple hypotheses for the same word sequence, and force other good hypotheses out of the beam, potentially increasing word error rate.",
        "This observation appears to be supported in practice.",
        "The original form of the PSA grammar allows an average of 1.4 parses per sentence, and while both the K&K and M&G algorigthm increase the level of ambiguity, the K&K algorithm increases much more dramatically.",
        "We are investigating techniques to transform a CFG into one weakly equivalent but with less ambiguity.",
        "While it is not possible in general to remove all ambiguity (Hopcroft and Ullman 1979) we hope that reducing the amount of ambiguity in the resulting grammar will result in improved recognition performance."
      ]
    },
    {
      "heading": "4.1 Grammar Compactor",
      "text": [
        "The first technique is actually a combination of three related transformations:",
        "• Duplicate Nonterminal Elimination – If two nonterminals A and B have exactly the same set of productions",
        "then remove the productions for B, and rewrite B as A everywhere it occurs in the grammar.",
        "• Unit Rule Elimination – If there is only one production for a nonterminal A, and it has a single daughter on its right-hand side",
        "A--�13,1131=1 then remove the production for A, and rewrite A as 13 everywhere it occurs in the grammar.",
        "• Duplicate Production Elimination –If a nonterminal A has two productions that are identical",
        "A--�1311 ... 113 ,13i=13j,i:/j then remove the production for 13Z.",
        "These transformations are applied repeatedly until they can no longer be applied.",
        "Each of these transformations may introduce opportunities for the others to apply, so the process needs to be order insensitive.",
        "This technique can be applied after the traditional reduction techniques of E-elimination, cycle-elimination, and left-recursion elimination, since they don’t introduce any new E-productions or any new left-recursion.",
        "Although these transformations seem rather specialized, they were surprisingly effective at reducing the size of the grammar.",
        "For the K&K algorithm, the number of grammar rules was reduced from 3,246 to 2,893, a reduction of 9.2%, and for the M&G algorithm, the number of rules was reduced from 4,758 to 1,837, a reduction of 61%.",
        "While these transforms do reduce the size of the grammar, and modestly reduce the level of ambiguity from 1.96 to 1.92, they did not initially appear to improve recognition performance.",
        "However, that was with the nuance parameter -nodearrayoptimizationlevel set to the default value FULL.",
        "When set to the value MIN, the compacted grammar was approximately 60% faster, and about 9% reduction in the word error rate, suggesting that the nuance compiler is performing a similar form of compaction during node array optimization."
      ]
    },
    {
      "heading": "4.2 Immediate Recursion Detection",
      "text": [
        "Another technique to reduce ambiguity was motivated by a desire to reduce the amount of prepositional phrase attachment ambiguity in our grammar.",
        "This technique detects when a Kleene closure will be introduced into the final form of the grammar, and takes advantage of this to remove ambiguity.",
        "Consider this grammar fragment:"
      ]
    },
    {
      "heading": "NP NP PP VP VNPPP",
      "text": [
        "The first rule tells us that an NP can be followed by an arbitrary number of PPs, and that the PP following the NP in the second rule will be ambiguous.",
        "In addition, any nonterminal that has an NP as its rightmost daughter can also be followed by an arbitrary number of PPs, so we can detect ambiguity following those nonterminals as well.",
        "We define a predicate follows as: A follows B iff B BAor B 13 C and A follows C Now, the follows relation can be used to reduce ambiguity by modifying other productions where a B is followed by an A:",
        "where 13,+ follows 13, and 13, z/ X can be rewritten as A --� 131 ... AA+2 ... 13 There is an exactly analogous transformation involving immediate right-recursion and a similar predicate preceeds.",
        "These transformation produce almost the same language, but can modify it by possibly allowing constructions that were not allowed in the original grammar.",
        "In our case, the initial grammar fragment above would require that at least one PP be generated within the scope of the VP, but after the transformation that is no longer required.",
        "So, while these transformations are not exact, they are still sound aproximations, as the resulting language is a superset of the original language.",
        "Unfortunately, we have had mixed results with applying these transformations.",
        "In earlier versions of our implementation, applying these transformations succeeded in improving the recognition speed up to 20%, while having some modest improvements in word error rate.",
        "But, as we improved other aspects of the compilation process, notably the grammar compaction techniques and the left-recursion elimination technique, those improvements disappeared, and the transformations actually made things worse.",
        "The problem appears to be that both transformations can introduce cycles, and the right-recursive case can introduce left-recursion even in cases where cycles are not introduced.",
        "When the introduced cycles and left-recursions are later removed, the size of the grammar is increased, which can lead to poorer recognition performance.",
        "In the earlier implementations, cycles were fortuitously avoided, probably due to the fact that there were more unique nonterminals overall.",
        "We expect that these transformations may be effective for some grammars, but not others.",
        "We plan to continue to explore refinements to these techiques to prevent them from applying in cases where cycles or left-recursion may be introduced."
      ]
    },
    {
      "heading": "5 Left Recursion Elimination",
      "text": [
        "We have used two left-recursion elimination techniques, the traditional one based on Paull’s algorithm, as reported by Hopcroft and Ullman (1979), and one described by Moore (2000)5, based on a technique described by Johnson (1998).",
        "Our experience concurs with Moore that the left-corner transform he describes produces a more compact left-recursion free grammar than that of Paull’s algorithm.",
        "For the K&K approximation, we were unable to get any grammar to compile through to a working language model using Paull’s algorithm (the models built with Paull’s algorithm caused the recognizer to exceed memory bounds), and only succeeded with Moore’s left-recursion elimination technique."
      ]
    },
    {
      "heading": "6 Conclusions",
      "text": [
        "We have presented descriptions of two algorithms for approximating typed unification grammars with context-free grammars, and evaluated their performance during speech recognition.",
        "Initial results show that high levels of ambiguity coorelate with poor recognition performance, and that size of the resuling language model does not appear to directly coorelate with recognition performance.",
        "We have developed new techniques for further reducing the size and amount of ambiguity in these context-free grammars, but have so far met with mixed results."
      ]
    }
  ]
}
