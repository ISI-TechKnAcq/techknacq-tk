{
  "info": {
    "authors": [
      "Andreas Eisele",
      "Jochen Dorre"
    ],
    "book": "Annual Meeting of the Association for Computational Linguistics",
    "id": "acl-P88-1035",
    "title": "Unification of Disjunctive Feature Descriptions",
    "url": "https://aclweb.org/anthology/P88-1035",
    "year": 1988
  },
  "references": [
    "acl-C86-1045",
    "acl-C86-1129",
    "acl-P84-1008",
    "acl-P86-1038",
    "acl-P87-1033"
  ],
  "sections": [
    {
      "heading": "Abstract",
      "text": [
        "The paper describes a new implementation of feature structures containing disjunctive values, which can be characterized by the following main points: Local representation of embedded disjunctions, avoidance of expansion to disjunctive normal form and of repeated test-unifications for checking consistence.",
        "The method is based on a modification of Kasper and Rounds' calculus of feature descriptions and its correctness therefore is easy to see.",
        "It can handle cyclic structures and has been incorporated successfully into an environment for grammar development."
      ]
    },
    {
      "heading": "1 Motivation",
      "text": [
        "In current research in computational linguistics but also in extralinguistic fields unification has turned out to be a central operation in the modelling of data types or knowledge in general.",
        "Among linguistic formalisms and theories which are based on the unification paradigm are such different theories as FUG [Kay 79,Kay 85], LFG [Kaplan/Bresnan 82], GSPG [Gazdar et al.",
        "85], CUG [Uszkoreit 86].",
        "However, research in unification is also relevant for fields like logic programming, theorem proving, knowledge representation (see [Smolka/Ait-Kaci 87] for multiple inheritance hierarchies using unification), programming language design [Alt-Kaci/Nasr 86] and others.",
        "The version of unification our work is based on is graph unification, which is an extension of term unification.",
        "In graph unification the number of arguments is free and arguments are selected by attribute labels rather than by position.",
        "The algorithm described here may easily be modified to apply to term unification.",
        "The structures we are dealing with are rooted directed graphs where arcs starting in one node must carry distinct labels.",
        "Terminal nodes may also be labelled.",
        "These structures are referred to by various names in the literature: feature structures, functional structures, functional descriptions, types, categories.",
        "We will call them feature structures1 throughout this paper.",
        "In applications, other than toy applications, the efficient processing of indefinite information which is represented by disjunctive specifications becomes a relevant factor.",
        "A strategy of multiplying-out disjunction by exploiting (nearly) any combination of disjuncts through backtracking, as it is done, e.g., in the case of a simple DCG parser, quickly runs into efficiency problems.",
        "On the other hand the descriptional power of disjunction often helps to state highly ambiguous linguistic knowledge clearly and concisely (see Fig. 1 for a disjunctive description of morphological features for the six readings of the german noun `Koffer').",
        "Koffer: r num: sg 1 L.pers: 3 j masc {nom dat acc"
      ]
    },
    {
      "heading": "morph:",
      "text": []
    },
    {
      "heading": "pers:",
      "text": []
    },
    {
      "heading": "MaSC",
      "text": [
        "{nom gen acc r rel: Koffer' 1 I arg: [ ]",
        "Kasper and Rounds [86] motivated the distinction between feature structures and formulae of a logical calculus that are used to describe feature structures.",
        "Disjunction can be used within such a formula to describe sets of feature structures.",
        "With this separation the underlying mathematical framework which is used to define the semantics of the descriptions can be kept simple."
      ]
    },
    {
      "heading": "2 Disjunctive Feature Descriptions",
      "text": [
        "We use a slightly modified version of the formula language FML of Kasper and Rounds [86] to describe our feature structures.",
        "Fig.",
        "2 gives the syntax of FM!, where A is the set of atoms and L the set of labels.",
        "In contrast to Kasper and Rounds [86] we do not use the syntactic construct of path equivalence classes.",
        "Instead, path equivalences are expressed using non-local path expressions (called pointers in the sequel).",
        "This choice is motivated by the fact that we use these pointers for an efficient representation below, and we want to keep FM: as simple as possible.",
        "The intuitive semantics of FML' is as follows (see [Kasper/Rounds 86] for formal definitions):",
        "1.",
        "NIL is satisfied by any feature structure.",
        "2.",
        "TOP is never satisfied.",
        "3. a is satisfied by the feature structure consisting only of a single node labelled a.",
        "4.",
        "1 : (I) requires a (sub-)structure under arc 1 to satisfy 4).",
        "5.",
        "4' A 4f is satisfied by a feature structure that satisfies 4) and satisfies AP.",
        "6.",
        "4' V 4/ is satisfied by a feature structure that satisfies 4) or satisfies 41.",
        "7.",
        "(p) requires a path equivalence (two paths lead",
        "ing to the same node) between the path (p) and the actual path relative to the top-level structure.",
        "The denotation of a formula 4) is usually defined as the set of minimal elements of SAT(4) with respect to subsumption3, where SAT(4)) is the set 2 This construct is context-sensitive in the sense that the denotation of (p) may only be computed with respect to the whole structure that the formula describes.",
        "3 The subsumption relation C is a partial ordering on feature structures inducing a semi-lattice.",
        "It may be defined as: FS1 C FS2 if the set of formulae satisfied by FS2 includes the set of formulae satisfied by FS1.",
        "of feature structures which satisfy 4).",
        "Example: The formula",
        "denotes the two graphs The unification problem for disjunctive feature descriptions can be stated as follows: Given two formulae that describe feature structures, find the set of feature structures that satisfy both formulae, if it is nonempty, else announce 'fail'.",
        "The simplest way to deal with disjunction is to rewrite any description into disjunctive normal form (DNF).",
        "This transformation requires time and space exponential with the number of disjuncts in the initial formula in the worst case.",
        "Although the problem of unifying disjunctive descriptions is known to be NP-complete (see [Kasper 87a]), methods which avoid this transformation may perform well in most practical cases.",
        "The key idea is to keep disjunction local and consider combinations of disjuncts only when they refer to the very same substructure.",
        "This strategy, however, is complicated by the fact that feature structures may be graphs with path equivalences and not only trees.",
        "Fig.",
        "3 shows an example where unifying a disjunction with a structure containing reentrancy causes parts of the disjunction to be linked to other parts of the structure.",
        "The disjunction is exported via this reentrancy.",
        "Hence, the value of attribute d cannot be represented uniquely.",
        "It may be + or -, depending on which disjunct in attribute a is chosen.",
        "To represent this information without extra formal devices we have to lift the disjunction one level up.4"
      ]
    },
    {
      "heading": "4 From Description to Efficient Representation",
      "text": [
        "It is interesting to investigate whether FE: is suitable as an encoding of feature structures, i.e. if it can be used for computational purposes.",
        "However, this is clearly not the case for the unrestricted set of formulae of FNI!, since a given feature structure can be represented by infinitely many different formulae of arbitrary complexity and – even worse – because it is also not possible to ascertain whether a given formula represents any feature structure at all without extensive computation.",
        "On the other hand, the formulae of FICL' have some properties that are quite attractive for representing feature structures, such as embedded and general disjunction and the possibility to make use of the law of distributivity for disjunctions.",
        "Therefore we have developed an efficiency-oriented normal form ENF, which is suitable as an efficient representation for sets of feature structures.",
        "The formulae are built according to a restricted syntax (Fig.",
        "4, Part A) and have to satisfy condition GEN, (Part B).",
        "The syntax restricts the use of conjunction and TOP in order to disallow contradictory information in a formula other than TOP.",
        "However, even in a formula of the syntax of Part A inconsistence can be introduced by a pointer to a location that is `blocked' by an atomic value on a higher level.",
        "For example in the formula a: (b c) A b:d the path (b c) is blocked since it would require the value of attribute b to be complex in conflict to the atomic value d, thus rendering the formula non-satisfiable.",
        "With the additional condition GEN, such inconsistencies are excluded.",
        "Its explanation in the next section is somewhat technical and is not prerequisite for the overall understanding of our method."
      ]
    },
    {
      "heading": "Condition C„,",
      "text": [
        "First we have to introduce some terminology.",
        "Instance: When every disjunction in a formula is replaced by one of its disjuncts, the result is called an instance of that formula.",
        "Realized: A recursive definition of what we call a realized path in an instance d, is given in Fig. 5.",
        "The intuitive idea behind this notion is to restrict"
      ]
    },
    {
      "heading": "realized in",
      "text": [
        "is realized in (p'), if p'p is realized in the top-level formula",
        "pointers in such a way that the path to their destination may not be blocked by the introduction of an atomic value on a prefix of this path.",
        "Note that by virtue of the second line of the definition, the last label of the path does not have to actually occur in the formula, if there are other labels.",
        "Example: In a: (b c) only the path e and each path of length 1 is realized.",
        "Any longer path may be blocked by the introduction of an atomic value at level 1.",
        "Thus, the formula violates GEN,.",
        "a:(b d) A b:(c) A c: (d:x V b:y), on the other hand, is a well-formed VW formula, since it contains only pointers with realized destinations in every disjunct.",
        "The easiest way to satisfy the condition is to introduce for each pointer the value NIL at its destination when building up a formula.",
        "With this strategy we actually never have to check this condition, since it is maintained by the unification algorithm described below."
      ]
    },
    {
      "heading": "Properties of ENF",
      "text": [
        "The most important properties of formulae in ENF are:",
        "• For each formula of FIII; an equivalent formula in ENF can be found.",
        "• Each instance of a formula in ENF (besides TOP) denotes exactly one feature structure.",
        "• This feature structure can be computed in linear time.",
        "The first property can be established by virtue of the unification algorithm given in the next section, which can be used to construct an equivalent ENF-formula for an arbitrary formula in FKL'.",
        "The next point says: It doesn't matter which disjunct in one disjunction you choose – you cannot get a contradiction.",
        "Disjunctions in ENF are mutually independent.",
        "This also implies that TOP is the only formula in ENF that is not satisfiable.",
        "To see why this property holds, first consider formulae without pointers.",
        "Contradictory information (besides TOP) can only be stated using conjunction.",
        "But since we only allow conjunctions of different attributes, inconsistent information cannot be stated in formulae without pointers.",
        "Pointers could introduce two sorts of inconsistencies: Since a pointer links two paths, one might assume that inconsistent information could be specified for them.",
        "But since conjunction with a pointer is not allowed, only the destination path can carry additional information, thus excluding this kind of inconsistency.",
        "On the other hand, pointers imply the existence of the paths they refer to.",
        "The condition C„, ensures that no informstion in the formula contradicts the introduction of these implied paths.",
        "We can conclude that even formulae containing pointers are consistent.",
        "The condition C„„ additionally requires that no extension of a formula, gained by unification with another formula, may contain such contradicting information.",
        "A unification algorithm thus can introduce an atomic value into a formula without having to check if it would block the destination path of some pointer."
      ]
    },
    {
      "heading": "5 The Unification Procedure",
      "text": [
        "Figure 6 shows an algorithm that takes as input two terms representing formulae in ENF and computes an ENF-representation of their unification.",
        "The representation of the formulae is given by a 1-to-l-mapping between formulae and data-structures, so that we can abstract from the data-structures and write formulae instead.",
        "In this sense, the logical connectives A, V,: are used as term-constructors that build more complex data-structures from simpler ones.",
        "In addition, we use the operator • to express concatenation of labels or label sequences and write (p) to express the pointer to the location specified by the label sequence p. p : 0 is an abbreviation for a formula where the subformula 0 is embedded on path p. The auxiliary function unity_aux performs the essential work of the unification.",
        "It traverses both formulae in parallel and builds all encountered subformulae into the output formula.",
        "The following cases have to be considered:",
        "• If one of the input formulae specifies a subformula at a location where the other input provides no information or if both inputs contain the same subformuls.",
        "at a certain location, this subformula is built into the output without modification.",
        "• The next statement handles the case where one",
        "input contains a pointer whereas the other contains a different subformula.",
        "Since we regard the destination of the pointer as the representative of the equivalence class of paths, the subformula has to be moved to that place.",
        "This case requires additional discussion, so we have moved it to the procedure move_tormula.",
        "• In case of two conjunctions the formulae have to be traversed recursively and all resulting attribute - value pairs have to be built into the output structure.",
        "For clarity, this part of the algorithm has been moved to the procedure linify_complex.",
        "• The case where one of the input formulae is a disjunction is handled in the procedure unity_disj that is described in Section 5.2.",
        "• If none of the previous cases matches (e.g. if the inputs are different atoms or an atom and",
        "a complex formula), a failure of the unification has to be announced which is done in the last",
        "The most interesting case is the treatment of a pointer.",
        "The functional organization of the algorithm does not allow for side effects on remote parts of the top-level formula (nor would this be good programming style), so we had to find a different way to move a subformula to the destination of the pointer.",
        "For that reason, we have defined our procedures so that they return two results: a local result that has to be built into the output formula at the current location (i.e. the path both input formulae are embedded on) and a global result that is used to express 'side effects' of the unification.",
        "This global result represents a formula that has to be unified with the top-level result in order to find a formula covering all information contained in the input.",
        "This global result is normally set to NIL, but the procedure move_formula must of course produce something different.",
        "For the time being, we can assume the preliminary definition of move_formula in Figure 7, which will be modified in the next subsection.",
        "Here, the local result is the pointer (since we want to keep the information about the path equivalence), whereas the global result is a formula containing the subformula to be moved embedded at its new location.",
        "The function unify_complex unifies conjunctions of label-value-pairs by calling unify_aux recursively and placing the local results of these unifications at the appropriate locations.",
        "Labels that appear only in one argument are built into the output without modification.",
        "If any of the recursive unifications fail, a failure has to be announced.",
        "The global results from recursive unifications are collected by top-level unification'.",
        "The third argument of nnify_anx and unify_complex contains the sequence of labels to the actual location.",
        "It is not used in this version but is included in preparation of the more sophisticated treatment of pointers described below.",
        "To perform a top-level unification of two formulae, the call to unify_aux is repeated in order to unify the local and global results until either the unification fails or the global result is NIL.",
        "Before extending the algorithm to handle disjunction, we will first concentrate on the question how the termination of this repeat-loop can be guaranteed."
      ]
    },
    {
      "heading": "5.1 Avoiding Infinite Loops",
      "text": [
        "There are cases where the algorithm in Figure 6 will not terminate if the movement of subformulae is defined as in Figure 7.",
        "Consider the unification of a: (b) A b: (a) with Here, the formula (I) 51f we allow the global result to be a list of formulae, this recursion could be replaced by list-concatenation.",
        "However, this would imply modifications in the top-level loop and would slightly complicate the treatment of disjunction.",
        "will be moved along the pointers infinitely often and the repeat-loop in unity will never terminate.",
        "An algorithm that terminates for arbitrary input must include precautions to avoid the introduction of cyclic pointer chains or it has to recognize such cycles and handle them in a special way.",
        "When working with pointers, the standard technique to avoid cycles is to follow pointer chains to their end and to install a new pointer only to a location that does not yet contain an outgoing pointer.",
        "For different reasons, dereferencing is not the method of choice in the context of our treatment of disjunction (see [Eisele 87] for details).",
        "However, there are different ways to avoid cyclic movements.",
        "A total order `<p' on all possible locations (i.e. all paths) can be defined such that, if we allow movements only from greater to smaller locations, cycles can be avoided.",
        "A pointer from a greater to a smaller location in this order will be called a positive pointer, a pointer from a smaller to a greater location will be called negative.",
        "But we have to be careful about chosing the right order; not any order will prevent the algorithm from an infinite loop.",
        "For instance, it would not be adequate to move a formula along a pointer from a location p to its extension p q, since the pointer itself would block the way to its destination.",
        "(The equivalence class contains (p), (p q) , (p q .",
        ".",
        ".",
        "and it makes no sense to choose the last one as a representative).",
        "Since cyclic feature structures can be introduced inadvertently and should not lead to an infinite loop in the unification, the first condition the order `<p ' has to fulfill is: p <p pq if q e The order must be defined in a way that positive pointers can not lead to even indirect cycles.",
        "This is guaranteed if the condition p <p q rps <p rqs"
      ]
    },
    {
      "heading": "holds for arbitrary paths p, q, r and s.",
      "text": [
        "We get an order with the required properties if we compare, in the first place, the length of the paths and use a lexicographic order <, for paths of the same length.",
        "A formal statement of this definition is given in Figure 8.",
        "Note that positive pointers can turn into negative ones when the structure containing them is moved, as the following example shows:",
        "However, we can be pragmatic about this point; the purpose of ordering is the avoidance of cyclic movements.",
        "Towards this end, we only have to avoid using negative pointers, not writing them down.",
        "To avoid movement along a negative pointer, we now make use of the actual location that is provided by the third argument of unify_aux and unity_complex and as the second argument of move_formula.",
        "• If the pointer is positive we proceed as usual.",
        "• If it points to the actual location, it can be ignored (i.e. treated as NIL).",
        "This case occurs, when the same path equivalence is stated more than once in the input.",
        "• If the pointer is negative, it is inverted by installing at its destination a pointer to the actual position."
      ]
    },
    {
      "heading": "5.2 Incorporating Disjunction",
      "text": [
        "The procedure unity_disj in Figure 10 has four arguments: the formula to unify with the disjunction (which also can be a disjunction), both disjuncts, and the actual location.",
        "In the first two statements, the unifications of the formula A with the disjuncts B and C are performed independently.",
        "We can distinguish three main cases:",
        "• If one of the unifications fails, the result of the other is returned without modification.",
        "• If both unifications have no global effect or if the global effects happen to result in the same",
        "formula, a disjunction is returned as local result and the common global result of both disjuncts is taken as the global result for the disjunction.",
        "• If both unifications have different global results, we can not return a disjunction as local result, since remote parts of the resulting formula depend on the choice of the disjunct at the actual location.",
        "This case arrives if one or both disjuncts have outgoing pointers and if one of these pointers has been actually used to move a subformula to its destination.",
        "The last point describes exactly the case where the scope of a disjunction has to be extended to a higher level due to the interaction between disjunction and path equivalence, as was shown in Figure 3.",
        "A simple treatment of such effects would be to return a disjunction as global result where the disjuncts are the global results unified with the corresponding local result embedded at the actual position.",
        "However, it is not always necessary to return a top-level disjunction in such a situation.",
        "If the global effect of a disjunction concerns only locations 'close' to the location of the disjunction, we get two global results that differ only in an embedded substructure.",
        "To minimize the 'lifting' of the disjunction, we can assume a procedure pack that takes two formulae X and Y and returns a formula equivalent to X V Y where the disjunction is embedded at the lowest possible level.",
        "Although the procedure pack can be defined in a straightforward manner, we refrain from a formal specification, since the discussion in the next section will show how the same effect can be achieved in a different way."
      ]
    },
    {
      "heading": "6 Implementation",
      "text": [
        "We now have given a complete specification of a unification algorithm for formulae in ENF.",
        "However, there are a couple of modifications that can be applied to it in order to improve its efficiency.",
        "The improvements described in this section are all part of our actual implementation.",
        "Unification of Two Pointers If both arguments are pointers, the algorithm in Figure 6 treats one of them in the same way as an arbitrary formula and tries to move it to the destination of the other pointer.",
        "Although this treatment is correct, some of the necessary computations can be avoided if this case is treated in a special way.",
        "Both pointer destinations and the actual location should be compared and pointers to the smallest of these three paths should be installed at the other locations.",
        "Special Treatment of Atomic Formulae In most applications, we do not care about the equivalence of two paths if they lead to the same atom.",
        "Under this assumption, when moving an atomic formula along a pointer, the pointer itself can be replaced by the atom without loss of information.",
        "This helps to reduce the amount of global information that has to be handled.",
        "Ordering Labels The unification of conjunctions that contain many labels can be accelerated by keeping the labels sorted according to some order (e.g. </).",
        "This avoids searching one formula for each label that occurs in the other.",
        "Organisation of the Global Results on a Stack In the algorithm described so far, the global result of a unification is collected, but is - apart from disjunction - not used before the traversal of the input formulae is finished.",
        "When formulae containing many pointers are unified, the repeated traversal of the top-level formula slows down the unification, and may lead to the construction of many intermediate results that are discarded later (after having been copied partially).",
        "To improve this aspect of the algorithm, we have chosen a better representation of the global result.",
        "Instead of one formula, we represent it as a stack of",
        "formulae where the first element holds information for the actual location and the last element holds information for the top-level formula.",
        "Each time a formula has to be moved along a pointer, its destination is compared with the actual location and the common prefix of the paths is discarded.",
        "From the remaining part of the actual location we can determine the first element on the stack where this information can be stored.",
        "The rest of the destination path indicates how the information has to be represented at that location.",
        "When returning from the recursion, the first element on the stack can be popped and the information in it can be used immediately.",
        "This does not only improve efficiency, but has also an effect on the treatment of disjunction.",
        "Instead of trying to push down a top-level disjunction to the lowest possible level, we climb up the stacks returned by the recursive unifications and collect the subformulae until the rests of the stacks are identical.",
        "In this way, 'lifting' disjunctions can be limited to the necessary amount without using a function like pack."
      ]
    },
    {
      "heading": "Practical Experiences",
      "text": [
        "In order to be compatible with existing software, the algorithm has been implemented in PROLOG.",
        "It has been extended to the treatment of unification in an LFG framework where indirectly specified labels (e.g in the equation (1 (1pcase)) = 1 ), set values and various sorte of constraints have to be considered.",
        "This version has been incorporated into an existing grammar development facility for LFGs [Eisele/DOrre 86,Eisele/Schimpf 87] and has not only improved efficiency compared to the former treatment of disjunction by backtracking, but also helps to survey a large number of similar results when the grammar being developed contains (too) much disjunction.",
        "One version of this system runs on PCs with reasonable performance."
      ]
    },
    {
      "heading": "7 Comparison with Other Approaches",
      "text": []
    },
    {
      "heading": "7.1 Asymptotical Complexity",
      "text": [
        "Candidates for a comparison with our algorithm are the naive multiplying-out to DNF, Kasper's representation of general disjunction [Kasper 87b], and Karttunen's treatment of value disjunction [Karttunen 84], also the improved version in [Bear 87].",
        "Since satisfiability of formulae in FML is known to be an NP-complete problem, we cannot expect better than exponential time complexity in the worst case.",
        "Nevertheless it might be interesting to find cases where the asymptotic behaviour of the algorithms differ.",
        "The following statements – although somewhat vague – may give an impression of strong and weak points of the different methods.",
        "For each given statement we have specific examples, but their presentation or proofs would be beyond the scope of this paper."
      ]
    },
    {
      "heading": "7.1.1 Space Complexity (Compactness of the Representation)",
      "text": [
        "• When many disjunctions concern different substructures and do not depend on each other, our representation uses exponentially less space than expansion to DNF.",
        "• There are cases where Kasper's representation uses exponentially less space than our representation.",
        "This happens when disjunctions interact strongly, but an exponential amount of consistent combinations remain.",
        "• Since Karttunen's method enumerates all consistent combinations when several disjunctions concern the same substructure, but allows for local representation in all other cases, his method seems to have a similar space complexity than ours.",
        "• There are cases where Kasper's method uses exponentially more time than ours.",
        "This happens when disjunctions interact so strongly, that only few consistent combinations remain, but none of the disjunctions can be resolved.",
        "• When disjunctions interact strongly, but an exponential amount of consistent combinations remains, our method needs exponential time.",
        "An algorithm using Kasper's representation could do better in some of these cases, since it could find out in polynomial time that each of the disjuncts is used in a consistent combination.",
        "However, the actual organisation of Kasper's full consistency check introduces exponential time complexity for different reasons."
      ]
    },
    {
      "heading": "7.2 Average Complexity and Con",
      "text": []
    },
    {
      "heading": "clusion",
      "text": [
        "It is difficult to find clear results when comparing the average complexity of the different methods,",
        "since anything depends on the choice of the examples.",
        "However, we can make the following general observation: Al!",
        "methods have to multiply out disjunctions that are not mutually independent in order to find inconsistencies.",
        "Kasper's and Karttunen's methods discard the results of such computations, whereas our algorithm keeps anything that is computed until a contradiction appears.",
        "Thus, our method tends to use more space than the others.",
        "On the other hand, since Kasper's and Karttunen's methods 'forget' intermediate results, they are sometimes forced to perform identical computations repeatedly.",
        "As conclusion we can say that our algorithm sacrifies space in order to save time."
      ]
    },
    {
      "heading": "8 Further Work",
      "text": [
        "The algorithm or the underlying representation can still be improved or extended in various respects:"
      ]
    },
    {
      "heading": "General Disjunction",
      "text": [
        "For the time being, when a formula is unified with a disjunction, the information contained in it has to be distributed over all disjuncts.",
        "This may involve some unnecessary copying of label-value-pairs in cases where the disjunction does not interact with the information in the formula.",
        "(Note, however, that in such cases only the first level of the formula has to be copied.)",
        "It seems worthwhile to define a relaxed ENF, where a formula (AVB)AC is allowed under certain circumstances (e.g. when (A V B) and C do not contain common labels) and to investigate whether a unification algorithm based on this relaxed normal form can help to save unnecessary computations."
      ]
    },
    {
      "heading": "Functional Uncertainty",
      "text": [
        "The algorithm for unifying formulae with regular path expressions given by Johnson [Johnson 86] gives as a result of a unification a finite disjunction of cases.",
        "The algorithm presented here seems to be a good base for an efficient implementation of Johnson's method.",
        "The details still have to be worked out."
      ]
    },
    {
      "heading": "Acknowledgments",
      "text": [
        "The research reported in this paper was supported by the EUROTRA-D accompanying project (BMFT grant No.",
        "101 3207 0), the ESPRIT project ACORD (P393) and the project LILOG (supported by IBM Deutschland).",
        "Much of the inspiration for this work originated from a course about extensions to unification (induding the work of Kasper and Rounds) which Hans Uszkoreit held at the University of Stuttgart in spring 1987.",
        "We had fruitful discussions with Lauri Karttunen about an early version of this algorithm.",
        "Thanks also go to Jfirgen Wedekind, Hank Zeevat, Inge Bethke, and Roland Seiffert for helpful discussions and important counterexamples, and to Fiona McKinnon, Stefan Momma, Gert Smollca, and Carin Speeht for polishing up our argumentation."
      ]
    }
  ]
}
