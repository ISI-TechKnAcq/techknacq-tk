{
  "info": {
    "authors": [
      "Laura Kallmeyer",
      "Giorgio Satta"
    ],
    "book": "ACL-IJCNLP",
    "id": "acl-P09-1112",
    "title": "A Polynomial-Time Parsing Algorithm for TT-MCTAG",
    "url": "https://aclweb.org/anthology/P09-1112",
    "year": 2009
  },
  "references": [
    "acl-E91-1005",
    "acl-J05-2003",
    "acl-P85-1011",
    "acl-P87-1015"
  ],
  "sections": [
    {
      "text": [
        "Laura Kallmeyer Giorgio Satta",
        "Collaborative Research Center 441 Department of Information Engineering Universitat Tübingen University of Padua",
        "Tübingen, Germany Padova, Italy",
        "lk@sfs.uni-tuebingen.de satta@dei.unipd.it",
        "This paper investigates the class of Tree-Tuple MCTAG with Shared Nodes, TT-MCTAG for short, an extension of Tree Adjoining Grammars that has been proposed for natural language processing, in particular for dealing with discontinuities and word order variation in languages such as German.",
        "It has been shown that the universal recognition problem for this formalism is NP-hard, but so far it was not known whether the class of languages generated by TT-MCTAG is included in PTIME.",
        "We provide a positive answer to this question, using a new characterization of TT- MCTAG."
      ]
    },
    {
      "heading": "1. Introduction",
      "text": [
        "For a large range of linguistic phenomena, extensions of Tree Adjoining Grammars (Joshi et al., 1975), or TAG for short, have been proposed based on the idea of separating the contribution of a lexical item into several components.",
        "Instead of single trees, these grammars contain (multi-)sets of trees.",
        "Examples are tree-local and set-local multicomponent TAG (Joshi, 1985; Weir, 1988), MC-TAG for short, non-local MCTAG with dominance links (Becker et al., 1991), Vector-TAG with dominance links (Rambow, 1994) and, more recently, Tree-Tuple MCTAG with Shared Nodes (Lichte, 2007)), or TT-MCTAG for short.",
        "For some of the above formalisms the word recognition problem is NP-hard.",
        "This has been shown for non-local MCTAG (Rambow and Satta, 1992), even in the lexicalized case (Champollion, 2007).",
        "Some others generate only polynomial languages but their generative capacity is too limited to deal with all natural language phenomena.",
        "This has been argued for tree-local and even set-local MCTAG on the basis of scrambling data from languages such as German (Becker et al., 1992; Rambow, 1994).",
        "In this paper, we focus on TT-MCTAG (Lichte, 2007).",
        "So far, it has been shown that the universal recognition problem for TT-MCTAG is NP-hard (Sogaard et al., 2007).",
        "A restriction on TT-MCTAG has been proposed in (Kallmeyer and Parmentier, 2008): with such a restriction, the universal recognition problem is still NP-hard, but the class of generated languages is included in PTIME, i.e., all these languages can be recognized in deterministic polynomial time.",
        "In this paper, we address the question of whether for general TT-MCTAG, i.e., TT-MCTAG without the constraint from (Kallmeyer and Parmentier, 2008), the class of generated languages is included in PTIME.",
        "We provide a positive answer to this question.",
        "The TT-MCTAG definition from (Lichte, 2007; Kallmeyer and Parmentier, 2008) imposes a condition on the way different tree components from a tree tuple in the grammar combine with each other.",
        "This condition is formulated in terms of mapping between argument and head trees, i.e., in order to test such a condition one has to guess some grouping of the tree components used in a derivation into instances of tree tuples from the grammar.",
        "This results in a combinatorial explosion of parsing analyses.",
        "In order to obtain a polynomial parsing algorithm, we need to avoid this effect.",
        "On this line, we propose an alternative characterization of TT-MCTAG that only requires (i) a counting of tree components and (ii) the check of some local conditions on these counts.",
        "This allows for parsing in polynomial deterministic time.",
        "TT-MCTAG uses so-called 'parallel unordered' rewriting.",
        "The first polynomial time parsing results on this class were presented in (Ram-bow and Satta, 1994; Satta, 1995) for some string-based systems, exploiting counting techniques closely related to those we use in this paper.",
        "In contrast to string-based rewriting, the tree rewriting formalisms we consider here are structurally more complex and require specializations of the above techniques.",
        "Polynomial parsing results for tree rewriting systems based on parallel unordered rewriting have also been reported in (Rambow, 1994; Rambow et al., 1995).",
        "However, in the approach proposed by these authors, tree-based grammars are first translated into equivalent string-based systems, and the result is again provided on the string domain."
      ]
    },
    {
      "heading": "2. Tree Adjoining Grammars",
      "text": [
        "Tree Adjoining Grammars (Joshi et al., 1975) are a formalism based on tree rewriting.",
        "We briefly summarize here the relevant definitions and refer the reader to (Joshi and Schabes, 1997) for a more complete introduction.",
        "Definition 1 A Tree Adjoining Grammar (TAG) is a tuple G = (VN ,Vt,S,I,A) where VN and VT are disjoint alphabets of non-terminal and terminal symbols, respectively, S £ VN is the start symbol, and I and A are finite sets of initial and auxiliary trees, respectively.",
        "□",
        "Trees in IU A are called elementary trees.",
        "The internal nodes in the elementary trees are labeled with non-terminal symbols, the leaves with nonterminal or terminal symbols.",
        "As a special property, each auxiliary tree P has exactly one of its leaf nodes marked as the foot node, having the same label as the root.",
        "Such a node is denoted by Ft (pi).",
        "Leaves with non-terminal labels that are not foot nodes are called substitution nodes.",
        "In a TAG, larger trees can be derived from the elementary trees by subsequent applications of the operations substitution and adjunction.",
        "The substitution operation replaces a substitution node rj with an initial tree having root node with the same label as r .",
        "The adjunction operation replaces an internal node rj in a previously derived tree 7 with an auxiliary tree P having root node with the same label as r .",
        "The subtree of 7 rooted at r is then placed below the foot node of p. Only internal nodes can allow for adjunction, adjunction at leaves is not possible.",
        "See figure 1 for an example of a tree derivation.",
        "Usually, a TAG comes with restrictions on the two operations, specified at each node rj by sets Sbst(n) and Adj (rj) listing all elementary trees that can be substituted or adjoined, respectively.",
        "Furthermore, adjunction at rj might be obligatory.",
        "John derived tree: S",
        "ADV VP* always",
        "John VP always V laughs",
        "derivation tree: laugh john always",
        "TAG derivations are represented by derivation trees that record the history of how the elementary trees are put together.",
        "A derivation tree is an unordered tree whose nodes are labeled with elements in I U A and whose edges are labeled with Gorn addresses of elementary trees.",
        "Each edge in a derivation tree stands for an adjunction or a substitution.",
        "E.g., the derivation tree in figure 1 indicates that the elementary tree for John is substituted for the node at address 1 and always is adjoined at node address 2.",
        "In the following, we write a derivation tree D as a directed graph (V, E, r) where V is the set of nodes, E c V x V is the set of arcs and r £ V is the root.",
        "For every v £ V, Lab (v) gives the node label and for every (v1;v2) £ E, Lab((v1;v2)) gives the edge label.",
        "A derived tree is the result of carrying out the substitutions and the adjunctions in a derivation tree, i.e., the derivation tree describes uniquely the derived tree; see again figure 1."
      ]
    },
    {
      "heading": "3. TT-MCTAG",
      "text": [
        "For a range oflinguistic phenomena, multicomponent TAG (Weir, 1988) have been proposed, also called MCTAG for short.",
        "The underlying motivation is the desire to split the contribution ofa single lexical item (e.g., a verb and its arguments) into several elementary trees.",
        "An MCTAG consists of (multi-)sets of elementary trees, called tree sets.",
        "If an elementary tree from some set is used in a derivation, then all of the remaining trees in the set must be used as well.",
        "Several variants of MC-TAGs can be found the literature, differing on the specific definition of the derivation process.",
        "The particular MCTAG variant we are concerned with is Tree-Tuple MCTAG with Shared were introduced to deal with free word order phenomena in languages such as German.",
        "An example is (1) where the argument es of reparieren precedes the argument der Mann of versucht and is not adjacent to the predicate it depends on.",
        "(1) ... dass es der Mann zu reparieren versucht ...that it the man to repair tries",
        "that the man tries to repair it'",
        "A TT-MCTAG is slightly different from standard MCTAGs since each elementary tree set contains one specially marked lexicalized tree called the head, and all of the remaining trees in the set function as arguments ofthe head.",
        "Furthermore, in a TT-MCTAG derivation the argument trees must either adjoin directly to their head tree, or they must be linked in the derivation tree to an elementary tree that attaches to the head tree, by means of a chain of adjunctions at root nodes.",
        "In other words, in the corresponding TAG derivation tree, the head tree must dominate the argument trees in such a way that all positions on the path between them, except the first one, must be labeled by e. This captures the notion of adjunction under node sharing from (Kallmeyer, 2005).",
        "Definition 2 A TT-MCTAG is a tuple G = (Vn ,",
        "For each r = (7, {p1,..., pr}) £ T, we call 7 the head tree and the 's the argument trees.",
        "We informally say that 7 and the 's belong to r, and write |r| = r + 1.",
        "As a remark, an elementary tree 7 from the underlying TAG GT can be found in different tree tuples in G, or there could even be multiple instances of such a tree within the same tree tuple r. In these cases, we just treat these tree instances as distinct trees that are isomorphic and have identical labels.",
        "For a given argument tree p in r, h(p) denotes the head of p in r. For a given 7 £ IU A, 0(7) denotes the set of argument trees of 7, if there are any, or the empty set otherwise.",
        "Furthermore, for a given TT-MCTAG G, H (G) is the set of head trees and A(G) is the set of argument trees.",
        "Finally, a node v in a derivation tree for G with Lab (v) = 7 is called a 7-node.",
        "Definition 3 Let G = (Vn , Vt,S,I,A, T) be some TT-MCTAG.",
        "A derivation tree D = (V, E, r) in the underlying TAG GT is licensed in G ifand only ifthe following conditions (MC) and (SN-TTL) are both satisfied.",
        "• (MC): For all r from G and for all 71,72in r, we have |{v | v £ V, Lab (v) = 71}| = |{v | v £ V, Lab(v) = 72}|.",
        "The separation between (MC) and (SN-TTL) in definition 3 is motivated by the desire to separate the multicomponent property that TT-MCTAG shares with a range ofrelated formalisms (e.g., tree-local and set-local MCTAG, Vector-TAG, etc.)",
        "from the notion of tree-locality with shared nodes that is peculiar to TT-MCTAG.",
        "Figure 2 shows a TT-MCTAG derivation for (1).",
        "Here, the NPnom auxiliary tree adjoins directly to versucht (its head) while the NPacc tree adjoins to the root of a tree that adjoins to the root of a tree that adjoins to reparieren.",
        "TT-MCTAG can generate languages that, in a strong sense, cannot be generated by Linear Context-Free Rewriting Systems (Vijay-Shanker et al., 1987; Weir, 1988), or LCFRS for short.",
        "An example is the language of all strings n(n[1l ... ntm])v[l ... v[m] with m > 1, n a permutation, and n[j] = n is a nominal argument of v[j] = v for 1 < i < m, i.e., these occurrences come from the same tree set in the grammar.",
        "Such a language has been proposed as an abstract description of the scrambling phenomenon as found in German and other free word order languages, and cannot be generated by a LCFRS (Becker et al., 1992; Rambow, 1994).",
        "Figure 3 reports a TT-MCTAG for this language.",
        "Concerning the other direction, at the time of writing it is not known whether there are languages generated by LCFRS but not by TT-",
        "MCTAG.",
        "It is well known that LCFRS is closed under the finite-copy operator.",
        "This means that, for any fixed k > 1, if L is generated by a LCFRS then the language {w | w = uk, u G L} can also be generated by a LCFRS.",
        "We conjecture that TT-MCTAG does not have such a closure property.",
        "However, from a first inspection of the MC-TAG analyses proposed for natural languages (see Chen-Main and Joshi (2007) for an overview), it seems that there are no important natural language phenomena that can be described by LCFRS and not by TT-MCTAG.",
        "Any construction involving some kind of component stacking along the VP projection such as subject-auxiliary inversion can be modelled with TT-MCTAG.",
        "Unbounded extraposition phenomena cannot be described with TT-MCTAG but they constitute a problem for any local formalism and so far the nature of these phenomena is not sufficiently well-understood.",
        "Note that, in contrast to non-local MCTAG, in TT-MCTAG the trees coming from the same instance of a tuple in the grammar are not required to be added at the same time.",
        "TT-MCTAGs share this property of 'non-simultaneity' with other vector grammars such as Unordered Vector Grammars (Cremers and Mayer, 1973) and Vectoris crucial for the polynomial parsing algorithm.",
        "The non-simultaneity seems to be an advantage when using synchronous grammars to model the syntax-semantics interface (Nesson and Shieber, 2008).",
        "The closest formalism to TT-MCTAG is",
        "V-TAG.",
        "However, there are fundamental differences between the two.",
        "Firstly, they make a different use of dominance links: In V-TAG dominance links relate different nodes in the trees of a tree set from the grammar.",
        "They present dominance requirements that constrain the derived tree.",
        "In TT-MCTAG, there are no dominance links between nodes in elementary trees.",
        "Instead, the node of a head tree in the derivation tree must dominate all its arguments.",
        "Furthermore, even though TT-MCTAG arguments can adjoin with a delay to their head, their possible adjunction site is restricted with respect to their head.",
        "As a result, one obtains a slight degree of locality that can be exploited for natural language phenomena that are unbounded only in a limited domain.",
        "This is proposed in (Lichte and Kallmeyer, 2008) where the fact that substitution nodes block argument adjunction to higher heads is used to model the limited domain of scrambling in German.",
        "V-TAG does not have any such notion of locality.",
        "Instead, it uses explicit constraints, so-called integrity constraints, to establish islands.",
        "TT-MCTAG",
        "The definition of TT-MCTAG in subsection 3.1 is taken from (Lichte, 2007; Kallmeyer and Parmenderivation tree is formulated in terms of heads and arguments belonging together, i.e., coming from the same tuple instance.",
        "For our parsing algorithm, we want to avoid grouping the instances of elementary trees in a derivation tree into tuple instances.",
        "In other words, we want to check whether a TAG derivation tree is a valid TT-",
        "MCTAG derivation tree without deciding, for every occurrence of some argument p, which of the h(p)-nodes represents its head.",
        "Therefore we propose to reformulate (SN-TTL).",
        "For a node v in a derivation tree D, we write Dv to represent the subtree of D rooted at v. For 7 £ (I U A), we define Dom(v, 7) as the set of nodes of Dv that are labeled by 7.",
        "Furthermore, for an argument tree p £ A(G), we let n(v, p) = |Dom(v,p)| – |Dom(v,h(p))|.",
        "Lemma 1 Let G be a TT-MCTAG with underlying TAG Gt, and let D = (V, E, r) be a derivation tree in Gt that satisfies (MC).",
        "D satisfies (SN-TTL) if and only if, for every v £ V and every p £ A(G), the following conditions both hold.",
        "(i) n(v,p) > 0.",
        "(ii) If n(v, p) > 0, then one of the following conditions must be satisfied:",
        "(d) Lab(v) = h(p) and there is some (v, v ) E with Lab((v, v )) = e and n(v,p) < vr(v£,p) < n(v,p) + 1.",
        "Intuitively, condition (i) in lemma 1 captures the fact that heads always dominate their arguments in the derivation tree.",
        "Condition (ii)b states that, if v is a p-node and if v is not the only 'pending' p-node in Dv, then all pending p-nodes in Dv, except v itself, must be below the root adjoining node.",
        "Here pending means that the node is not matched to a head-node within Dv.",
        "Condition (ii)c treats the case in which there are pending p-nodes in Dv for some node v whose label is neither p nor h(p).",
        "Then the pending nodes must all be below the root adjoining node.",
        "Finally, condition (ii)d deals with the case of a h(p)-node v where, besides the p-node that serves as an argument of v, there are other pending p-nodes in Dv.",
        "These other pending p-nodes must all be in DV£, where v is the (unique) root adjoining node, if it exists.",
        "The argument of v might as well be below ve, and then the number of pending p-nodes in DV£ is the number of pending nodes in Dv, incremented by 1, since the argument of v is not pending in Dv but it is pending in DV£.",
        "Otherwise, the argument of v is a pending p-node below some other daughter of v. Then the number of pending p-nodes in DV£ is the same as in Dv.",
        "Proof We first show that (SN-TTL) implies both (i) and (ii).",
        "Condition (i): Assume that there is a v V and a p £ a(g) with n(v, p) < 0.",
        "Then for some n and for pairwise different v1,..., vn with (v,vj) £ E*, Lab (vj) = h(p) (1 < i < n), we cannot find pairwise different u1,..., un with (vj,uj) £ E*, Lab= p. This is in contradiction with (SN-TTL).",
        "Consequently, condition (i) must be satisfied.",
        "Condition (ii): Assume p and v as in the statement of the lemma, with n(v,p) > 0.",
        "Let v1,...,vn be all the h(p)-nodes in D. There is a bijection /j from these nodes to n pairwise distinct p-nodes in D, such that every pair vj, ///(vj) = uj satisfies the conditions in (SN-TTL).",
        "Because of (MC), the nodes u1,..., un must be all the p-nodes in D. There must be at least one vj (1 < i < n) with (vj, v) £ E+, (v, //,(vj)) £ E*.",
        "Then we have one of the following cases.",
        "(a) uj = v and vj is the only h(p)-node dominating v with a corresponding p-node dominated by v. In this case (ii)a holds.",
        "(b) Lab(v) = p, i.e., (/-1(v), v) £ E+ and there are other nodes u £ Dom(v,p), u = v with (/-1(u),v) £ E+.",
        "Then, with (SN-TTL), there must be a v with (v, v ) E, Lab((v, v )) = e and for all such nodes u, ( v , u) E* .",
        "Consequently, (ii)b holds.",
        "(c) Lab(v) £ {p,h(p)}.",
        "Then, as in (b), there must be a v with (v, v ) E, Lab((v, v )) = e and for all u £ Dom(v,p) with (/ – 1(u),v) £ E+, (ve, u) £ E*.",
        "Consequently, (ii)c holds.",
        "(d) Lab(v) = h(p).",
        "If /j(v) is dominated by a vethat is a daughter of v with Lab((v, ve)) = e, then for all u £ Dom(v,p) with (/-1(u),v) £ E+ we have (ve, u) £ E*.",
        "Consequently, n(ve,p) = n(v,p) + 1.",
        "Alternatively, (v) is dominated by some other daughter v' of v with Lab((v,v;)) = e. In this case ve must still exist and, for all u £ Dom(v,p) with u = //j(v) and with (/-1(u),v) £ E+, we have (ve,u) £ E*.",
        "Consequently, 7r(v£, p) = n(v, p).",
        "Now we show that (i) and (ii) imply (SN-TTL).",
        "With (MC), the number of p-nodes and h(p)-nodes in V are the same, for every p A(G).",
        "For every p £ A(G), we construct a bijection /j of the same type as in the first part of the proof, and show that (SN-TTL) is satisfied.",
        "To construct /j, for every v £ V we define sets VJ;V C Dom(v, p) of p-nodes v/ that have a matching head // (v/ ) dominating v. The definition satisfies |VJ,v | = n(v,p).",
        "For every v with v1 , .",
        ".",
        ".",
        ", vn being all its daughters:",
        "a) If Lab(v) = p, then (by (ii)) for every 1 < j < n with Lab ((v, vj)) = e, VJ)Vj = 0.",
        "If there is a vj with Lab((v, vj)) = e, then = Vj,^ U {v}, else VJ;V = {v}.",
        "b) If Lab(v) £ {p, h(p)}, then (by (ii)) = 0 for every 1 < j < n with Lab((v,v?))",
        "= e. If there is a vj with Lab((v,vj)) = e, then VJ;V = Vj)vi, else V/j;v = 0.",
        "c) If Lab(v) = h(p), then there must be some i, 1 < i < n, such that Vj,vi = 0.",
        "We need to distinguish two cases.",
        "In the first case we have Lab((v,vj)) = e, |V/3;vi | = 1 and, for every 1 < j < n with j = i, either VJ)Vj = 0 or Lab((v, vj)) = e. In this case we define /j(v) = v' for {v'} = Vj vi.",
        "In the second case we have Lab((v, vj)) = e and, for every 1 < j < n with j = i, Vj vj = 0.",
        "In this case we pick an arbitrary v' £ v. and let /j (v) = v'.",
        "In both cases we let",
        "V/j,v = (Un=1 ) (v)}.",
        "With this mapping, (SN-TTL) is satisfied when choosing for each h(p)-node vj the p-node uj = /j(vj) as its corresponding node.",
        "■"
      ]
    },
    {
      "heading": "4. Parsing algorithm",
      "text": [
        "In this section we present a recognition algorithm for TT-MCTAG working in polynomial time in the size of the input string.",
        "The algorithm can be easily converted into a parsing algorithm.",
        "The basic idea is to use a parsing algorithm for TAG, and impose on-the-fly additional restrictions on the underlying derivation trees that are being constructed, in order to fulfill the definition of valid TT-MCTAG derivation.",
        "To simplify the presentation, we assume without loss of generality that all elementary trees in our grammars are binary trees.",
        "The input string has the form w = a1 • • • an with each aj £ VT and n > 0 (n = 0 means w = e).",
        "We start with the discussion of a baseline recognition algorithm for TAG, along the lines of (Vijay-Shanker and Joshi, 1985).",
        "The algorithm is specified by means of deduction rules, following (Shieber et al., 1995), and can be implemented using standard tabular techniques.",
        "Items have the form [7, pt, i, /1, /2, j] where 7 £ I U A, p is the address of a node in 7, subscript t £ {T, _L} specifies whether substitution or adjunction has already taken place (T) or not (_L) at p, and 0 < i < /1 < /2 < j < n are indices with i, j indicating the left and right edges of the span recognized by p and /1 , /2 indicating the span of a gap in case a foot node is dominated by p. We write /1 = /2 = – if no gap is involved.",
        "For combining indices, we use the operator /' © /= / where / = /' if /= – , / = /if /' = – , and / is undefined otherwise.",
        "The deduction rules are shown in figure 4.",
        "The algorithm walks bottom-up on the derivation tree.",
        "Rules (1) and (2) process leaf nodes in elementary trees and require precondition Lab(7,p) = wj+1 and Lab(7,p) = e, respectively.",
        "Rule (3) processes the foot node of auxiliary tree p A by guessing the portion of w spanned by the gap.",
        "Note that we use py in the consequent item in order to block adjunction at foot nodes, as usually required in TAG.",
        "We move up along nodes in an elementary tree by means of rules (4) and (5), depending on whether the current node has no sibling or has a single sibling, respectively.",
        "Rule (6) substitutes initial tree a at p in 7, under the precondition a £ Sbst(7,p).",
        "Similarly, rule (7) adjoins auxiliary tree p at p in 7, under the precondition p Adj(7, p).",
        "Both these rules use py in the consequent item in order to block multiple adjunction or substitution at p, as usually required in TAG.",
        "Rule (8) processes nodes at which adjunction is not obligatory.",
        "The algorithm recognizes w if and only if some item [a, ey, 0, – , – , n] can be inferred with a £ I and Lab(a, e) = S.",
        "We now extend the recognition algorithm of figure 4 to TT-MCTAG.",
        "Let G be an input TT-",
        "MCTAG.",
        "We assume that the tuples in T are numbered from 1 to |T| , and that the elementary trees in each rj are also numbered from 1 to | rj| , with the first element being the head.",
        "We then write 7q>rfor the r-th elementary tree in the q-th tuple in T.",
        "A t-counter is a ragged array T of integers with primary index q ranging over {1,..., |T|} and with secondary index r ranging over {1,..., |rj|}.",
        "We write T(q'r) to denote the t-counter with T[ q, r] = 1 and zero everywhere else.",
        "We also use the sum and the difference oft-counters, which are",
        "Figure 4: A baseline recognition algorithm for TAG.",
        "Rule preconditions and goal item are described in the text.",
        "Figure 5: A recognition algorithm for TT-MCTAG.",
        "Rule preconditions are the same as for figure 4, filtering conditions on rules are described in the text.",
        "defined elementwise in the obvious way.",
        "Let D be a derivation tree generated by the TAG underlying G. We associate D with the t-counter T such that T[q, r] equals the count of all occurrences of elementary tree 7q>r appearing in D. Intuitively, we use t-counters to represent information about TAG derivation trees that are relevant to the licensing of such trees by the input TT-",
        "MCTAGG.",
        "We are now ready to present a recognizer based on TT-MCTAG.",
        "To simplify the presentation, we first discuss how to extend the algorithm of fig. 4 in order to compute t-counters, and will later specify how to apply TT-MCTAG filtering conditions through such counters.",
        "The reader should however keep in mind that the two processes are strictly interleaved, with filtering conditions being tested right after the construction of each new t-counter.",
        "We use items of the form [7^,pt,i,/1, /2, j, T], where the first six components are defined as in the case of TAG items, and the last component is a t-counter associated with the constructed derivations.",
        "Our algorithm is specified in figure 5.",
        "The simplest case is that of rules (12) and (16).",
        "These rules do not alter the underlying derivation tree, and thus the t-counter is simply copied from the antecedent item to the consequent item.",
        "first elementary tree in the analysis (7q>r £ A in case of rule (11)).",
        "Therefore we set the associated t-counter to T(q>r).",
        "In rule (14) we substitute initial tree 7q' y at node p in 7q r. In terms of derivation structures, we extend a derivation tree D' rooted at node v'with Lab (v') = 7q' r' to a new derivation tree D with root node v, Lab(v) = 7q>r. Node v has a single child represented by the root of D'.",
        "Thus the t-counter associated with D should be T' + T('r).",
        "A slightly different operation needs to be performed when applying rule (15).",
        "Here we have a derivation tree D with root node v, Lab(v) = 7q>r and a derivation tree D' with root node v', Lab(v') = 7q'y.",
        "When adjoining 7q'y into 7q>r, we need to add to the root of D a new child node, represented by the root of D'.",
        "This means that the t-counter associated with the consequent item should be the sum ofthe t-counters associated with",
        "D and D'.",
        "Finally, rule (13) involves derivation trees D1 and D2, rooted at nodes v1 and v2, respectively.",
        "Nodes v1 and v2 have the same label 7q>r. The application of the rule corresponds to the 'merging' of v1 and v2 into a new node v with label 7q>r as well, Node v inherits all of the children of v1 and v2.",
        "In this case the t-counter associated with the consequent item is T1 + T2 – T(q>r).",
        "Here T(q>r) needs to be subtracted because the contribution of tree 7q>r is accounted for in both v1 and v2.",
        "We can now discuss the filtering conditions that need to be applied when using the above deduction rules.",
        "We start by observing that the algorithm in figure 5 might not even stop if there is an infinite set of derivation trees for the input string w = a1 • • • an in the underlying TAG GT.",
        "This is because each derivation can have a distinct tcounter.",
        "However, the definition of TT-MCTAG imposes that the head tree of each tuple contains at least one lexical element.",
        "Together with condition (MC), this implies that no more than n tuple instances can occur in a derivation tree for w according to G. To test for such a condition, we introduce a norm for t-counters",
        "||T||m = £ maxj.='1 T[q,r] .",
        "We then impose ||T ||m < n for each t-counter constructed by our deduction rule, and block the corresponding derivation if this is not satisfied.",
        "We also need to test conditions (i) and (ii) from lemma 1.",
        "Since these conditions apply to nodes of the derivation tree, this testing is done at each deduction rule in which a consequent item may be constructed for a node ey, that is, rules (14), (15) and (16).",
        "We introduce two specialized predicates",
        "F< (T) = V(q,r) : T[q, 1] < T[q,r]; F= (T) ee V(q,r) : T[q, 1] = T[q,r] .",
        "We then test F< (T), which amounts to testing condition (i) for each argument tree in A(G).",
        "Furthermore, if at some rule we have F< (T) A -F=(T), then we need to test for condition (ii).",
        "To do this, we consider each argument tree 7^, r = 1, and compare the elementary tree 7q>r in the consequent item of the current rule with 7^ and h(jq,r) = lq,i, to select the appropriate subcondition of (ii).",
        "As an example, assume that we are applying rule (15) as in figure 5, with p = e. Let Tc = T + T' be the t-counter associated with the consequent item.",
        "When we come to process some argument tree 7^ such that Tc[q,f] – Tc[q, 1] > 0 and 7g;r ^ {\"fq,r, 7g,i}, we need to test (ii)c. This is done by requiring T'[q,r]-T'[q, 1] = Tc[q, r] - Tc[q, 1].",
        "there is no adjunction at the root node, by requiring 7g>r = jg}¥ and T[q, f] - T[q, 1] = 1.",
        "We block the current derivation whenever the conditions in lemma 1 are not satisfied.",
        "The algorithm recognizes w if and only if some item [7q>1,et, 0, – , – ,n,T] can be inferred satisfying 7q>1 £ I, Lab (7q>1,e) = S and F=(T).",
        "The correctness immediately follows from the correctness of the underlying TAG parser and from lemma 1.",
        "Finally, we turn to the computational analysis of the algorithm.",
        "We assume a tabular implementation of the process of item inference using our deduction rules.",
        "Our algorithm clearly stops after some finite amount of time, because of the filtering condition ||T||m < n. We then need to derive an upper bound on the number of applications of deduction rules.",
        "To do this, we use an argument that is rather standard in the tabular parsing literature.",
        "The number of t-counters satisfying ||T ||m < n is O(nCG), with cG = £j=1 |rj|.",
        "Since all of the other components in an item are bounded by O(n), there are polynomially (in n) many items that can be constructed for an input w. It is not difficult to see that each individual item can be constructed by a number of rule applications bounded by a polynomial as well.",
        "Therefore, the total number of applications of our deduction rules is also bounded by some polynomial in n. We thus conclude that the languages generated by the class TT-",
        "MCTAG are all included in PTIME."
      ]
    },
    {
      "heading": "5. Conclusion and open problems",
      "text": [
        "We have shown in this paper that the class of languages generated by TT-MCTAG is included in PTIME, by characterizing the definition of TT-MCTAG through some conditions that can be tested locally.",
        "PTIME is one of the required properties in the definition of the class of Mildly Context-Sensitive (MCS) formalisms (Joshi et al., 1991).",
        "In order to settle membership in MCS for TT-MCTAG, what is still missing is the constant-growth property or, more generally, the semilin-earity property."
      ]
    },
    {
      "heading": "Acknowledgments",
      "text": [
        "The work of the first author has been supported by the DFG within the Emmy-Noether Program.",
        "The second author has been partially supported by MIUR under project PRIN No.",
        "2007TJNZRE_002."
      ]
    }
  ]
}
