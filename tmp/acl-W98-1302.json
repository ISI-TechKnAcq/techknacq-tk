{
  "info": {
    "authors": [
      "Mark-Jan Nederhof"
    ],
    "book": "Workshop on Finite State Methods in Natural Language Processing",
    "id": "acl-W98-1302",
    "title": "Context-Free Parsing Through Regular Approximation",
    "url": "https://aclweb.org/anthology/W98-1302",
    "year": 1998
  },
  "references": [
    "acl-J97-2003",
    "acl-P89-1018",
    "acl-P97-1058"
  ],
  "sections": [
    {
      "heading": "Mark-Jan Nederhof DFKI",
      "text": [
        "Stuhlsatzenhausweg 3, D-66123 Saarbriicken, GERMANY Abstract.",
        "We show that context-free parsing can be realised by a 2-phase process, relying on an approximated context-free grammar.",
        "In the firtt phase a finite transducer performs parsing according to the approximation.",
        "In the second phase, the approximated parses are refined according to the original grammar"
      ]
    },
    {
      "heading": "1 Introduction",
      "text": [
        "A recent publication [15] presented a novel way of transforming a context-free grammar into a new grammar that generates a regular language.",
        "This new language is a superset of the original language.",
        "It was argued that this approach has advantages over other methods of regular approximation [16, 7].",
        "Our method of approximation is the following.",
        "We define a condition on context-free grammars that is a sufficient condition for a grammar to generate a regular language.",
        "We then give a transformation that turns an arbitrary grammar into another grammar that satisfies this condition.",
        "This transformation is obviously not language-preserving; it adds strings to the language generated by the original grammar, in such a way that the language becomes regular.",
        "In the present communication we show how thiii procedure needs to be extended so that context-free parsing can be realised by a 2-phase process.",
        "For the first phase, the approximated grammar is turned into a finite transducer.",
        "This transducer processes the input in linear time and produces a table.",
        "In the second phase, this table is processed to obtain the set of all parses according to the original grammar.",
        "The order of the time complexity of the second phase is cubic, which corresponds to the time complexity of most context-free parsing algorithms that are used in practice.",
        "However, the first phase filters out many parses that are inconsistent with respect to the regular approximation.",
        "This may reduce the effort needed by the second phase.",
        "It is interesting to note that the work presented here is conceptually related to use of regular lookahead in context-free parsing [5].",
        "The structure of this paper is as follows.",
        "In Section 2 we recall some standard definitions from language theory.",
        "Section 3 investigates a sufficient condition for a context-free grammar to generate a regular language.",
        "We also present the construction of a finite transducer from such a grammar.",
        "How this transducer reads input and how the output of the transducer can be turned into a representation of all parse trees is discussed in Sections 4 and 5, respectively.",
        "An algorithm to transform a grammar if the sufficient condition mentioned above is not satisfied is given in Section 6.",
        "Section 7 explains how this transformation can be incorporated into the construction of the transducer and how the output of such a transducer is then to be interpreted in order to obtain parse trees according to the original grammar.",
        "Some preliminary conclusions drawn from empirical results are given in Section 8."
      ]
    },
    {
      "heading": "2 Preliminaries",
      "text": [
        "A context-free grammar G is a 4-tuple (L', N, P, S), where E and N are two finite disjoint sets of terminals and nonterminals, respectively, S E N is the start symbol, and P is a finite set of rules.",
        "Each rule has the form A 4 a with A E N and a E V*, where V denotes N 1.1 The relation on N x V* is extended to a relation on V* x V* as usual.",
        "The transitive and reflexive closure of 4 is denoted by -4*.",
        "The language generated by a context-free grammar is given by the set (w E E* I S -4* w).",
        "By definition, such a set is a context-free language.",
        "By reduction of a grammar we mean the elimination from P of all rules A 4 7 such that S -4* aAi5 aryl) -4* w does not hold for any ao3 E V* and w E E*.",
        "We generally use symbols A, B, C, .",
        ".",
        ".",
        "to range over N, symbols a, b, c, .",
        ".",
        ".",
        "to range over E, symbols X,Y,Z to range over V, symbols a, (3,7, ... to range over V*, and symbols v, w, x,... to range over E*.",
        "We write E to denote the empty string.",
        "A rule of the form A 4 B is called a unit rule.",
        "A (nondeterministic) finite automaton .7\" is a 5-tuple (K, 27, IA, s, F), where K is a finite set of states, of which s is the initial state and those in F C K are the final states, E is the input alphabet, and the transition relation Z1 is a finite subset of K x E* x K. We define a configuration to be an element of K x E. We define the binary relation I-between configurations as: (q, vw) (q', w) if and only if (q, v, ) E A.",
        "The transitive and reflexive closure of I is denoted by F. Some input v is recognized if (a, v) 1-* (q, e), for some q E F. The language accepted by Y defined to be the set of all strings v that are recognized.",
        "By definition, a language accepted by a finite automaton is called a regular language.",
        "A finite transducer T is a 6-tuple (K, 27i, Ea, A, s , F).",
        "Next to the input alphabet Ei we now have an output alphabet E2.",
        "Transitions are of the form (q, vita , qs) where v E Ej.\" and w E For finite transducers, a configuration is an element of K x x 27.",
        "We define the binary relation I between configurations as: (q, wa) (e 11)02) if and only if (q, v1Iv2 , E Some input WI is associated with output to2 if (s, e) 1-* (q,e,w2), for some q E F. The set of all such pairs (w1, w2) is the (regular) transduction represented by the transducer."
      ]
    },
    {
      "heading": "3 The Structure of Parse Trees",
      "text": [
        "We define a spine in a parse tree to be a path that runs from the root down to some leaf.",
        "Our main interest in spines lies in the sequences of grammar symbols at nodes bordering on spines.",
        "A simple example is the set of parse trees such as the one in Figure 1 (a), for a 3-line grammar of palindromes.",
        "It is intuitively clear that the language is not regular: the grammar symbols to the left of the spine from the root to E \"communicate\" with those to the right of the spine.",
        "More precisely, the prefix of the input up to the point where it meets the final node E of the spine determines the suffix after that point, in a way that an unbounded quantity of symbols from the prefix need to be taken into account.",
        "A formal explanation for why the grammar may not generate a regular language relies on the following definition [4]:",
        "In order to avoid the somewhat unfortunate term nonself-embedding (or noncenter-embedding [11]) we define a strongly regular grammar to be a grammar that is not self-embedding.",
        "Strong regularity informally means that when a section of a spine in a parse tree repeats itself, then either no grammar symbols occur to the left of that section of the spine, or no grammar symbols occur to the right.",
        "This prevents the \"unbounded communication\" between the two sides of the spine exemplified by the palindrome grammar.",
        "We now prove that strongly regular grammars generate regular languages.",
        "For an arbitrary grammar, we define the set of recursive nonterminals as: = {A E N I 3a, /3[A aAM} We determine the partition Ar of N consisting of subsets NI, N2, .. , Nk, for some k > 0, of mutually recursive nonterminals:",
        "We now define the function recursive from A( to the set {left, right, self, cyclic}:",
        "where",
        "When recursive(N1) = left, Ni consists of only left-recursive nonterminals, which does not mean it cannot also contain right-recursive nonterminals, but in that case right recursion amounts to application of unit rules.",
        "When recursive(N1) = cyclic, it is only such unit rules that take part in the recursion.",
        "That recursive(N1) = self, for some i, is a sufficient and • necessary condition for the grammar to be self-embedding.",
        "Therefore, we have to prove that if recursive(N1) E {left, right, cyclic}, for all i, then the grammar generates a regular language.",
        "Our proof differs from an existing proof [3] in that it is fully constructive: Figure 2 presents an algorithm for creating a finite transducer that recognizes as input all strings from the language generated by the grammar, and produces output strings of a form to be discussed shortly.",
        "The process is initiated at the start symbol, and from there the process descends the grammar in all ways until terminals are encountered.",
        "Descending the grammar is straightforward in the case of rules of which the left-hand side is not a recursive nonterminal: the subautomata found recursively for members in the right-hand side will be connected.",
        "In the case of recursive nonterminals, the process depends on whether the nonterminals in the corresponding set from H are mutually left-recursive or right-recursive; if they are both, which means they are cyclic, then either subprocess can be applied; in the code in Figure 2 cyclic and left-recursive subsets Ni are treated uniformly.",
        "We discuss the case that the nonterminals are left-recursive or cyclic.",
        "One new state is created for each nontenninal in the set.",
        "The transitions that are created for terminals and nonterminals not in Ni are connected in a way that is reminiscent of the construction of left-corner parsers [17].",
        "The output of the transducer consists of a list of filter items interspersed with input symbols.",
        "A filter item is a rule with a distinguished position in the right-hand side, indicated by a diamond.",
        "The part to the left of the diamond generates a part of the input just to the left of the current input position.",
        "The part to the right of the diamond potentially generates a subsequent part of the input.",
        "A string consisting of filter items and input symbols can be seen as a representation of a parse, different from some existing representations [11, 9, 12].",
        "At this point we use only initial filter items, from the set:",
        "This definition implies that for every rule there is exactly one initial filter item.",
        "The diamond holds the rightmost position, unless we are dealing with a right-recursive rule.",
        "An example is given in Figure 3.",
        "Four states have been labelled according to the names they are given in procedure make_fst.",
        "There are two states that are labelled qB.",
        "This can be explained by the fact that nonterminal B can be reached by descending the grammar from S in two essentially distinct ways.",
        "then for each (B 4 ... E P such that B E A Xi, , X,,, N,",
        "else for each (A /3) E P (* A is not recursive *) do let q = fresh-state; make_fst(q0, q); let A = A U {(q, el(A 4 p , qi)}"
      ]
    },
    {
      "heading": "4 Tabular Simulation of Finite Transducers",
      "text": [
        "After a finite transducer has been obtained, it may sometimes be turned into a deterministic transducer [13].",
        "However, this is not always possible since not all regular transductions can be",
        "described by means of deterministic finite transducers.",
        "In this case, input can be processed by simulating a nondeterministic transducer in a tabular way.",
        "Assume we have a finite transducer T = (K, , E2, A, 8,F) and an input string al • an• We create two tables.",
        "The first table K' contains entries of the form (i, qi), where 0 < < n and E K. Such an entry indicates that the transducer may be in state qi after reading input from position 0 up to i.",
        "The second table 4' contains entries of the form ((i, q1), v, (j, q)), where V E L. Such an entry indicates that furthermore the transducer may go from state qi to q2 in a single step, by reading the input from position i to position j while producing v as output.",
        "The preferred way of looking at these two tables is as a set of states and a set of transitions of a finite automaton F = (K', Z2, A', (0, s), F'), where F' is a subset of {n} x F. Initially K' = {(0, a)) and 4' = 0.",
        "Then the following is repeated until no more new elements can be added to K' or A':",
        "1.",
        "We choose a state (i, qi) E K' and a transition (qi, • • ailv, q2) E 4.",
        "2.",
        "We add a state (j,q2) to K' and a transition ((i, (j,g2)) to A' if not already present.",
        "We then define F' = K' n ({n} x F).",
        "The input al • • • an is recognized by T when F' is nonempty.",
        "The language accepted by F is the set of output strings that al • • an is associated with by T [1].",
        "Before continuing with the next phases of processing, as presented in the following sections, we may first reduce the automaton, i.e. we may remove the transitions that do not contribute to any paths from (0,․) to a state in F'.",
        "For simplifying the discussion in the next section, we further assume that F is transformed such that all transitions (g,v,g') E 41 satisfy ivj = 1.",
        "For the running example of Figure 3 we may then obtain the finite automaton indicated by the thick lines in Figure 4.",
        "(Two e-transitions were implicitly eliminated and the automaton has been reduced.)",
        "The time demand of the construction of F from T and al • • • an is linear measured both in n and in the size of T. Note that in general the language accepted by .7. may be infinite in case the grammar is cyclic."
      ]
    },
    {
      "heading": "5 Retrieving a Parse Forest",
      "text": [
        "Using the compact representation of all possible output strings discussed above, we can obtain the structure of the input according to the context-free grammar; by \"structure\" of the input we mean the collection of all parse trees.",
        "Again, we use a tabular representation, called a parse forest [6, 10, 2].",
        "Our particular kind of parse forest is a table U consisting of dotted items of the form [q, A 4 a where q and q' are states from K' and A a# is a rule.",
        "The dot indicates to how far recognition of the right-hand side has progressed.",
        "To be more precise, the meaning of the above dotted item is that the input symbols on a path from q to q' can be derived from P. Note that recognition of right-hand sides is done from right to left, i.e. in reversed order with respect to Earley's algorithm [6].",
        "For a certain instance of a rule, the initial position of the dot is given by the position of the diamond in the corresponding filter item.",
        "There are several ways to construct U.",
        "For presentational reasons our algorithm will be relatively simple, in the style of the CYK algorithm [81:",
        "1.",
        "Initially U is empty.",
        "2.",
        "We perform one of the following until no more new elements can be added to U: (a) We choose a transition (q, A 4 a o , q') E 11' and add an item [q, A 4 a • , qi] to U.",
        "(b) We choose a transition (q, A 4 a o B , q') E A' and an item [q' , B 4 • y ,q\"] E U and add an item [q, A -+ a • B ,q's] to U.",
        "(c) We choose a transition (q, a, q') E A' and an item [q', A aa • )9, qui E U and add an item [q, A -+ a • ,q\") to U.",
        "(d) We choose a pair of items [q, B 4 • 7, qq,[ql , A 4 aB • 13, E U and add an item",
        "Assume the grammar is G = (E, N, P, S).",
        "The following is to be performed for each set Ni E H such that recursive(N2) = self.",
        "1.",
        "Add the following nonterminals to N: 4, 4, it and 443 for all A, B E Ni.",
        "2.",
        "Add the following rules to P, for all A, B, C, D, E E Ni: – A 4 4; – 4 itc Y,„Ct, for all (C Y„,) P, with , Ni; – A4 el4A Y„,43, for all (D 4 aCK .Y„,EP) E P , with Y1, , Ni; - 44.4.B LIA; • – Al 4 Y1 Y„, 87B, for a,ll (A ..YmC fl) E P, with , Ym Ni; – B e; – A-+ > C B _-713 Y„„ for all (A- aCY1 .Y,n) E P , with , Ym Ni; - BB 4 E. 3.",
        "Remove from P the old rules of the form A – > a, where A E Ni.",
        "4.",
        "Reduce the grammar.",
        "The items produced for the running example are represented as the thin lines in Figure 4."
      ]
    },
    {
      "heading": "6 Approximating a Context-Free Language",
      "text": [
        "Section 3 presented a sufficient condition for the generated language to be regular, and explained when this condition is violated.",
        "This suggests how to change an arbitrary grammar so that it will come to satisfy the condition.",
        "The intuition is that the \"unbounded communication\" between the left and right sides of spines is broken.",
        "This is done by a transformation that operates separately on each set Ni such that recursive(N1) = self, as indicated in Figure 5.",
        "After this, the grammar will be strongly regular.",
        "Consider the grammar of palindromes in the left half of Figure 1.",
        "The approximation algorithm leads to the grammar in the right half.",
        "Figure 1 (b) shows the effect on the structure of parse trees.",
        "Note that the left sides of former spines are treated by the new nonterminal .457s and the right sides by the new nonterminal This example deals with the special case that each nonterminal can lead to at most one recursive call of itself.",
        "The general case is more complicated and is treated elsewhere [15]."
      ]
    },
    {
      "heading": "7 Obtaining Correct Parse Trees",
      "text": [
        "In Section 5 we discussed how the table resulting from simulating the transducer should be interpreted in order to obtain a parse forest.",
        "However, we assumed then that the transducer had been constructed from a grammar that was strongly regular.",
        "In case the original grammar is not strongly regular we have to approach this task in a different way.",
        "One possibility is to first apply the grammar transformation from the previous section and subsequently perform the 2-phase process as before.",
        "However, this approach results in a parse forest that reflects the structure of the transformed grammar rather than that of the original grammar.",
        "The second and preferred approach is to incorporate the grammar transformation into the construction of the transducer.",
        "The accepted language is then the same as in the case of the first approach, but the symbols that occur in the output carry information about the rules from the original grammar.",
        "How the construction of the finite transducer from Figure 2 needs to be changed is indicated in Figure 6.",
        "We only show the part of the code which deals with the case that a consists of a single nonterminal.",
        "For nonterminals which are not in a set Ni such that recursive(N1) = self, the same treatment as before is applied.",
        "Upon encountering a nonterminal B E N1 such that recursive(N1) = self, we consider the structure of the grammar if it is transformed according to Figure 5.",
        "This transformation creates new sets of recursive nonterminals, which have to be treated according to Figure 2 depending on whether they may be left-recursive or right-recursive.",
        "For example, given a fixed nonterminal B E N1, for some i such that recursive(N8) = self, the set of nonterminals 4413 and 4, for any A E Ni, together form a set M in the transformed grammar for which recursive(M) = right.",
        "We may therefore construct the transducer as dictated by",
        "Note that a nonterminal of the form Ic does not belong to M but to another set, say MI, which in the transformed grammar satisfies recursive(Mi) = right (or recursive(M1) = cyclic).",
        "Similarly, a nonterminal of the form CA belongs to a set, say M2, which satisfies recursive(M2) = left (or recursive(M2) = cyclic).",
        "Treatment of these nonterminals occurs in a deeper level of recursion of make_fst, and appears as separate cases in Figure 6.",
        "It is important to remember that the sets Ni in Figure 6 always refer to the nature of recursion in the original grammar; the transformed grammar is merely implicit in the given construction of the transducer, and helps us to understand the construction in terms of Figure 2.",
        "In addition to unit, filter items from the following set are used: /mid = {B a oCP I (B 4 aC 13) E P A ai[recursive(Ni) = self A B,C E Nill The meaning of the diamond is largely unchanged with regard to Section 3.",
        "For example, for the rule D 4 aCK Y„,E 13, which corresponds to the rule 4 4 CA .",
        "YmEtir of the transformed grammar, the filter item D -+ aCK .Y„, o E# is output, which indicates that an instance of Y1 ... Y„,, (or an approximation thereof) has just been read, which is potentially preceded by an instance of aC and followed by an instance of EP.",
        "On the other hand, upon encountering a rule such as 4 4 BA, which is an artifact of the grammar transformation, no output symbol is generated.",
        "For retrieving the forest from .7' we need to take into account the additional form of filter item.",
        "Now the following steps are required:",
        "(a) We choose (q, A 4 a *,q') E 4' and add [q, A -> a • , ql to U.",
        "(b) We choose (q, A -> a o B, q') E 4', such that (A 4 a o B) E /init, and [q', B -+ • 7, q\"] E U and add [q, A -> a • B, q\"] to U.",
        "else (* a must consist of a single nonterminal *) if a is of form A E Ni, some i, and recursive(N1) E {right, left, cyclic} then ...treatment as in Figure 2... elseif a is of form B E Ni, some i, and recursive(N1) = self then (* we implicitly replace B by /31;3 according to B BtB *)",
        " – otherwise, add [q, A – > a • BP, qll] to U."
      ]
    },
    {
      "heading": "8 Empirical Results",
      "text": [
        "The implementation was completed recently.",
        "Initial experiments allow some tentative conclusions, reported here.",
        "We have compared the 2-phase algorithm to a traditional tabular context-free parsing algorithm.",
        "In order to allow a fair comparison, we have taken a mixed parsing strategy that applies a set of dotted items comparable to that of Section 7.",
        "Assuming the input is given by al • • • an as before, the steps are given by:",
        "For the experiments we have taken a grammar for German, generated automatically through EBL, of which a considerable part contains self-embedding.",
        "The transducer was determinized and minimized as if it were a finite automaton, i.e. in a transition (q, vlw, , q') the pair 1.1111) is treated as one symbol, and the pair ele is treated as the empty string.",
        "The test sentences were obtained using a random generator [14].",
        "For a given input sentence, we define T1 and T2 to be the number of steps that are performed for the respective phases of the 2-phase algorithm: first, the creation of _I from the input • • an, and second, the creation of U from F. We define Tcf to be the number of steps that are performed for the direct construction of table U from al • • • an by the above tabular algorithm.",
        "Concerning the two processes with context-free power, viz. Tc1 and 1'2, we have observed that in the majority of cases there is a reduction in the number of steps from TO to T2.",
        "This can be a reduction from several hundreds of steps to less than 10.",
        "In individual cases however, especially for long sentences, T2 can be larger than T1.",
        "This can be explained by the fact that 7 may have many more states than that the input sentence has positions, which leads to less sharing of computation.",
        "Adding T1 and T2 in many cases leads to higher numbers of steps than T1.",
        "At this stage we cannot say whether this implies that the 2-phase idea is not useful.",
        "Many refinements, especially concerning the reduction of the number of states of 7 in order to enhance sharing of computation, have as yet not been explored.",
        "In this context, we observe that the size of the repertoire of filter items has conflicting consequences for the overall complexity.",
        "If T outputs no filter items, then it reduces to a recognizer, which can be deterrninized.",
        "Consequently, T1 will be equal to the sentence length, but T2 will be no less than (and in fact identical to) Tcf .",
        "If on the other hand T outputs many types of filter item, then determinization and minimization is more difficult and consequently 7' may be large and both Ti and T2 may be high."
      ]
    },
    {
      "heading": "Acknowledgements",
      "text": [
        "Parts of this research were carried out within the framework of the Priority Programme Language and Speech Technology (TST), while the author was employed at the University of Groningen.",
        "The TST-Programme is sponsored by NWO (Dutch Organization for Scientific Research).",
        "This work was further funded by the German Federal Ministry of Education, Science, Research and Technology (BMBF) in the framework of the VERDMOBIL Project under Grant 01 IV 701 V0.",
        "The responsibility for the contents lies with the author."
      ]
    }
  ]
}
