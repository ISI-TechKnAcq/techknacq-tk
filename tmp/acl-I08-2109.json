{
  "info": {
    "authors": [
      "Wanxiang Che",
      "Min Zhang",
      "Aiti Aw",
      "Chew Lim Tan",
      "Ting Liu",
      "Sheng Li"
    ],
    "book": "Proceedings of the Third International Joint Conference on Natural Language Processing",
    "id": "acl-I08-2109",
    "title": "Fast Computing Grammar-driven Convolution Tree Kernel for Semantic Role Labeling",
    "url": "https://aclweb.org/anthology/I08-2109",
    "year": 2008
  },
  "references": [
    "acl-N06-2025",
    "acl-P02-1031",
    "acl-P04-1043",
    "acl-P06-2010",
    "acl-W05-0620"
  ],
  "sections": [
    {
      "text": [
        "Fast Computing Grammar-driven Convolution Tree Kernel for",
        "Semantic Role Labeling",
        "Wanxiang Che* Min Zhang, Ai Ti Aw, Chew Lim Tan, Ting Liu, Sheng Li",
        "Grammar-driven convolution tree kernel (GTK) has shown promising results for semantic role labeling (SRL).",
        "However, the time complexity of computing the GTK is exponential in theory.",
        "In order to speed up the computing process, we design two fast grammar-driven convolution tree kernel (FGTK) algorithms, which can compute the GTK in polynomial time.",
        "Experimental results on the CoNLL-2005 SRL data show that our two FGTK algorithms are much faster than the GTK."
      ]
    },
    {
      "heading": "1. Introduction",
      "text": [
        "Given a sentence, the task of semantic role labeling (SRL) is to analyze the propositions expressed by some target verbs or nouns and some constituents of the sentence.",
        "In previous work, data-driven techniques, including feature-based and kernel-based learning methods, have been extensively studied for SRL (Carreras and Marquez, 2005).",
        "Although feature-based methods are regarded as the state-of-the-art methods and achieve much success in SRL, kernel-based methods are more effective in capturing structured features than feature-based methods.",
        "In the meanwhile, the syntactic structure features hidden in a parse tree have been suggested as an important feature for SRL and need to be further explored in SRL (Gildea and Palmer, 2002; Punyakanok et al., 2005).",
        "Moschitti (2004)",
        "The work was mainly done when the author was a visiting student at I R",
        "and Che et al.",
        "(2006) are two reported work to use convolution tree kernel (TK) methods (Collins and Duffy, 2001) for SRL and has shown promising results.",
        "However, as a general learning algorithm, the TK only carries out hard matching between two subtrees without considering any linguistic knowledge in kernel design.",
        "To solve the above issue, Zhang et al.",
        "(2007) proposed a grammar-driven convolution tree kernel (GTK) for SRL.",
        "The GTK can utilize more grammatical structure features via two grammar-driven approximate matching mechanisms over substructures and nodes.",
        "Experimental results show that the GTK significantly outperforms the method is applicable to any problem that uses syntax structure features and can be solved by the TK methods, such as parsing, relation extraction, and so on.",
        "In this paper, we use SRL as an application to test our proposed algorithms.",
        "Although the GTK shows promising results for SRL, one big issue for the kernel is that it needs exponential time to compute the kernel function since it need to explicitly list all the possible variations of two sub-trees in kernel calculation (Zhang et al., 2007).",
        "Therefore, this method only works efficiently on such kinds of datasets where there are not too many optional nodes in production rule set.",
        "In order to solve this computation issue, we propose two fast algorithms to compute the GTK in polynomial time.",
        "The remainder of the paper is organized as follows: Section 2 introduces the GTK.",
        "In Section 3, we present our two fast algorithms for computing the GTK.",
        "The experimental results are shown in Section 4.",
        "Finally, we conclude our work in Section 5."
      ]
    },
    {
      "heading": "2. Grammar-driven Convolution Tree Kernel",
      "text": [
        "The GTK features with two grammar-driven approximate matching mechanisms over substructures and nodes.",
        "Grammar-driven Approximate Substructure Matching: the TK requires exact matching between two phrase structures.",
        "For example, the two phrase structures \"NP^DT JJ NN\" (NP^a red car) and \"NP^DT NN\" (NP^a car) are not identical, thus they contribute nothing to the conventional kernel although they share core syntactic structure property and therefore should play the same semantic role given a predicate.",
        "Zhang et al.",
        "(2007) introduces the concept of optional node to capture this phenomenon.",
        "For example, in the production rule \"NP^DT [JJ] NP\", where [JJ] denotes an optional node.",
        "Based on the concept of optional node, the grammar-driven approximate substructure matching mechanism is formulated as follows:",
        "approximate node matching can be formulated as:",
        "where r1 is a production rule, representing a two-layer sub-tree, and likewise for r2.",
        "is the ith variation of the sub-tree r1 by removing one ore more optional nodes, and likewise for Tj2.",
        "IT(•, •) is a binary function that is 1 iff the two sub-trees are identical and zero otherwise.",
        "X1 (0 < X1 < 1) is a small penalty to penalize optional nodes.",
        "ai and bj stand for the numbers of occurrence of removed optional nodes in subtrees T£1 and Tj2, respectively.",
        "M(r1,r2) returns the similarity (i.e., the kernel value) between the two sub-trees r1 and r2 by summing up the similarities between all possible variations of the sub-trees.",
        "Grammar-driven Approximate Node Matching: the TK needs an exact matching between two nodes.",
        "But, some similar POSs may represent similar roles, such as NN (dog) and NNS (dogs).",
        "Zhang et al.",
        "(2007) define some equivalent nodes that can match each other with a small penalty \\2 (0 < \\2 < 1).",
        "This case is called node feature mutation.",
        "The where f1 is a node feature, f1 is the ith mutation of f1 and ai is 0 iff f1 and f1 are identical and 1 otherwise, and likewise for f2 and bj.",
        "If (•, •) is a function that is 1 iff the two features are identical and zero otherwise.",
        "Eq.",
        "(2) sums over all combinations of feature mutations as the node feature similarity.",
        "Given these two approximate matching mechanisms, the GTK is defined by beginning with the feature vector representation of a parse tree T as:",
        "where #subtreei(T) is the occurrence number of the ith sub-tree type (subtree,) in T. Now the GTK is defined as follows:",
        "where N1 and N2 are the sets of nodes in trees T1and T2, respectively.",
        "I'subtree.",
        "(n) is a function that is Xf • \\2 iff there is a subtreei rooted at node n and zero otherwise, where a and b are the numbers of removed optional nodes and mutated node features, respectively.",
        "A'(n1,n2) is the number of the common subtrees rooted at n1 and n2, i.e.,",
        "A'(n1,n2) can be further computed by the following recursive rules:",
        "R-A: if n1 and n2 are pre-terminals, then:",
        "where f\\ and f2 are features of nodes n\\ and n2 which can be computed in linear time O(n), where n is the number of feature mutations.",
        "R-B: else if both n\\ and n2 are the same nonterminals, then generate all variations of sub-trees of depth one rooted at n\\ and n2 (denoted by Tni and Tn2 respectively) by removing different optional nodes, then:",
        "where , Tj2, IT(•, •), ai and bj have been explained in Eq.",
        "(1).",
        "nc(n1 ,i) returns the number of children of n1 in its ith subtree variation T i1 .",
        "ch(n1 ,i,k) is the kth child of node n1 in its ith variation subtree Tn 1, and likewise for ch(n2,j,k).",
        "X (0 < X < 1) is the decay factor.",
        "R-C: else A'(m,n2) = 0"
      ]
    },
    {
      "heading": "3. Fast Computation of the GTK",
      "text": [
        "Clearly, directly computing Eq.",
        "(6) requires exponential time, since it needs to sum up all possible variations of the sub-trees with and without optional nodes.",
        "For example, supposing n1 = \"A->-a [b] c [d]\", n2 = \"A->-a b c\".",
        "To compute the Eq.",
        "(6), we have to list all possible variations of n1 and n2's subtrees, n1: \"A->-ab c d\", \"A->-ab c\", \"A->-ac d\", \"A->-a c\"; n2: \"A->-a b c\".",
        "Unfortunately, Zhang et al.",
        "(2007) did not give any theoretical solution for the issue of exponential computing time.",
        "In this paper, we propose two algorithms to calculate it in polynomial time.",
        "Firstly, we recast the issue of computing Eq.",
        "(6) as a problem of finding common sub-trees with and without optional nodes between two subtrees.",
        "Following this idea, we rewrite Eq.",
        "(6) as:",
        "where cn1 and cn2 are the child node sequences of n1 and n2, Ap evaluates the number of common sub-trees with exactly p children (at least including all non-optional nodes) rooted at n1 and n2, Ix = max{np(cni),np(cn2)} and np(^) is the number of non-optional nodes, lm = min{l(cni),l(cn2)}and l(^) returns the number of children.",
        "Now let's study how to calculate Ap(cni, cn2) using dynamic programming algorithms.",
        "Here, we present two dynamic programming algorithms to compute it in polynomial time.",
        "Kernel I (FGTK-I)",
        "Our FGTK-I algorithm is motivated by the string subsequence kernel (SSK) (Lodhi et al., 2002).",
        "Given two child node sequences sx = cni and t = cn2 (x is the last child), the SSK uses the following recursive formulas to evaluate the Ap:",
        "where A'p is an auxiliary function since it is only the interior gaps in the subsequences that are penalized; p, is a decay factor only used in the SSK for weighting each extra length unit.",
        "Lodhi et al.",
        "(2002) explained the correctness of the recursion defined above.",
        "Compared with the SSK kernel, the GTK has three different features:",
        "fl: In the GTK, only optional nodes can be skipped while the SSK kernel allows any node skipping;",
        "f2: The GTK penalizes skipped optional nodes only (including both interior and exterior skipped nodes) while the SSK kernel weights the length of subsequences (all interior skipped nodes are counted in, but exterior nodes are ignored);",
        "f3: The GTK needs to further calculate the number of common sub-trees rooted at each two matching node pair x and t[j].",
        "To reflect the three considerations, we modify the SSK kernel as follows to calculate the GTK:",
        "xopt(t[j + 1: \\t\\]) x A'(x,t[j])).",
        "where opt(w) is a binary function, which is 0 if non-optional nodes are found in the node sequence w and 1 otherwise (fl); X1 is the penalty to penalize skipped optional nodes and the power of X1 is the number of skipped optional nodes (f2); A'(x,t[j]) is defined in Eq.",
        "(7) f3).",
        "Now let us compare the FGTK-I and SSK kernel algorithms.",
        "Based on Eqs.",
        "(8), (9), (10) and (11), we introduce the opt(^) function and the penalty X1 into Eqs.",
        "(12), (13) and (14), respectively.",
        "opt(^) is to ensure that in the GTK only optional nodes are allowed to be skipped.",
        "And only those skipped optional nodes are penalized with X1.",
        "Please note that Eqs.",
        "(10) and (11) are merged into Eq.",
        "(14) because of the different meaning of p and X1.",
        "From Eq.",
        "(8), we can see that the current path in the recursive call will stop and its value becomes zero once non-optional node is skipped (when opt(w) = 0).",
        "Let us use a sample of n1 = \"A->-a [b] c [d]\", n2 = \"A->-a b c\" to exemplify how the FGTK-I algorithm works.",
        "In Eq.",
        "(14)'s vocabulary, we have s = \"a [b] c\", t = \"a b c\", x = \"[d]\", opt(x) = opt([d]) = 1, p = 3.",
        "Then according to Eq (14), Ap(cni ,cn2) can be calculated recursively as Eq.",
        "(15) (Please refer to the next page).",
        "(Lodhi et al., 2002).",
        "This means that the worst case complexity of the FGTK-I is O(pp\\N1\\ • \\N2\\), where p is the maximum branching factor of the two trees.",
        "Kernel II (FGTK-II)",
        "Our FGTK-II algorithm is motivated by the partial trees (PTs) kernel (Moschitti, 2006).",
        "The PT kernel algorithm uses the following recursive formulas to evaluate Ap(cni,(n2):",
        "where cni [1 : i] and cn2 [1 : j] are the child subsequences of cni and cn2 from 1 to i and from 1 to j, respectively.",
        "Given two child node sequences s1 a = cni [1 : i] and s2b = cn2[1 : j] (a and b are the last children), the PT kernel computes A'p(•, •) as follows:",
        "where A'(a, b) is defined in Eq.",
        "(7) and Dp is recursively defined as follows:",
        "where p used in Eqs.",
        "(17) and (18) is a factor to penalize the length of the child sequences.",
        "Compared with the PT kernel, the GTK has two different features which are the same as fl and f2 when defining the FGTK-I.",
        "To reflect the two considerations, based on the PT kernel algorithm, we define another fast algorithm of computing the GTK as follows:",
        "for all k, l",
        "where opt(w) and X1 are the same as them in the",
        "FGTK-I.",
        "Now let us compare the FGTK-II and the PT algorithms.",
        "Based on Eqs.",
        "(16), (18) and (19), we introduce the opt(^) function and the penalty X1 into Eqs.",
        "(20), (22) and (23), respectively.",
        "This is to ensure that in the GTK only optional nodes are allowed to be skipped and only those skipped optional nodes are penalized.",
        "In addition, compared with Eq.",
        "(17), the penalty p is removed in Eq.",
        "(21) in view that our kernel only penalizes skipped nodes.",
        "Moreover, Eq.",
        "(24) is only for fast computing.",
        "Finally, the same as the FGTK-I, in the FGTK-II the current path in a recursive call will stop and its value becomes zero once non-optional node is skipped (when opt(w) = 0).",
        "Here, we still can use an example to derivate the process of the algorithm step by step as that for FGTK-I algorithm.",
        "Due to space limitation, here, we do not illustrate it in detail.",
        "By means of the above algorithms, we can compute the A'(n1,n2) in O(p\\cni\\ • \\cn2\\) (Moschitti,",
        "By means of the above algorithm, we can com2006).",
        "This means that the worst complexity of the FGTK-II is O{pp\\Ni\\ • \\N2\\).",
        "It is faster than the FGTK-I's O(pp\\Ni\\ • \\N2\\) in theory.",
        "Please note that the average p in natural language parse trees is very small and the overall complexity of the FGTKs can be further reduced by avoiding the computation of node pairs with different labels (Moschitti, 2006)."
      ]
    },
    {
      "heading": "4. Experiments",
      "text": [
        "Data: We use the CoNLL-2005 SRL shared task data (Carreras and Marquez, 2005) as our experimental corpus.",
        "Classifier: SVM (Vapnik, 1998) is selected as our classifier.",
        "In the FGTKs implementation, we modified the binary Tree Kernels in SVM-Light Tool (SVM-Light-TK) (Moschitti, 2006) to a grammar-driven one that encodes the GTK and the two fast dynamic algorithms inside the well-known SVM-Light tool (Joachims, 2002).",
        "The parameters are the same as Zhang et al.",
        "(2007).",
        "convolution tree kernel (the best-reported method for kernel-based SRL) as our baseline kernel.",
        "It is defined as Khybrid = 0KPath + (l - 0)Kcs (0 < 0 < l).",
        "Here, we use the GTK to compute the KPath and the KCs.",
        "In the training data (WSJ sections 02-21), we get 4,734 production rules which appear at least 5 times.",
        "Finally, we use 1,404 rules with optional nodes for the approximate structure matching.",
        "For the node approximate matching, we use the same equivalent node sets as Zhang et al.",
        "(2007).",
        "We use 30,000 instances (a subset of the entire training set) as our training set to compare the different kernel computing algorithms .",
        "All experiments are conducted on a PC with CPU 2.8GH and memory 1G.",
        "Fig.",
        "1 reports the experimental results, where training curves (time vs. # of instances) of five kernels are illustrated, namely the TK, the FGTK-I, the FGTK-II, the GTK and a polynomial kernel (only for reference).",
        "It clearly demonstrates that our FGTKs are faster than the GTK algorithm as expected.",
        "However, the improvement seems not so significant.",
        "This is not surprising as there are only 30.4% rules (1,404 out of 4,734) that have optional nodes and most of them have only one optional node.",
        "Therefore, in this case, it is not time consuming to list all the possible sub-tree variations and sum them up.",
        "Let us study this issue from computational complexity viewpoint.",
        "Suppose all rules have exactly one optional node.",
        "This means each rule can only generate two variations.",
        "Therefore computing Eq.",
        "(6) is only 4 times (2*2) slower than the GTK in this case.",
        "In other words, we can say that given the constraint that there is only one optional node in one rule, the time complexity of the GTK is also O( N1 • N2 ) , where N1 and N2 are the numbers of tree nodes, the same as the TK.",
        "Figure 1: Training time comparison among different kernels with rule set having less optional nodes.",
        "Moreover, Fig 1 shows that the FGTK-II is faster than the FGTK-I.",
        "This is reasonable since as discussed in Subsection 3.2, the FGTK-I's time complexity is O(pp\\Ni\\ -\\N2\\) while the FGTK-II's is O{pp\\N± \\-\\N2\\).",
        "Figure 2: Training time comparison among different kernels with rule set having more optional nodes.",
        "To further verify the efficiency of our proposed algorithm, we conduct another experiment.",
        "Here we use the same setting as that in Fig 1 except that we randomly add more optional nodes in more production rules.",
        "Table 1 reports the statistics on the two rule set.",
        "Similar to Fig 1, Fig 2 compares the training time of different algorithms.",
        "We can see that Fig 2 convincingly justify that our algorithms are much faster than the GTK when the experimental data has more optional nodes and rules."
      ]
    },
    {
      "heading": "5. Conclusion",
      "text": [
        "The GTK is a generalization of the TK, which can capture more linguistic grammar knowledge into the later and thereby achieve better performance.",
        "However, a biggest issue for the GTK is its computing speed, which needs exponential time in theory.",
        "Therefore, in this paper we design two fast grammar-driven convolution tree kennel (FGTK-I and II) algorithms which can compute the GTK in polynomial time.",
        "The experimental results show that the FGTKs are much faster than the GTK when data set has more optional nodes.",
        "We conclude that our fast algorithms enable the GTK kernel to easily scale to larger dataset.",
        "Besides the GTK, the idea of our fast algorithms can be easily used into other similar problems.",
        "To further our study, we will use the FGTK algorithms for other natural language processing problems, such as word sense disambiguation, syntactic parsing, and so on.",
        "# rules",
        "# rule",
        "with at",
        "# op-",
        "# average op-",
        "least",
        "optional",
        "tional",
        "tional nodes per",
        "nodes",
        "nodes",
        "rule",
        "Exp!",
        "4,734",
        "!,404",
        "2,242",
        "1.6",
        "Exp2",
        "4,734",
        "4,520",
        "!0,45!",
        "2.3"
      ]
    }
  ]
}
