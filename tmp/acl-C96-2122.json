{
  "info": {
    "authors": [
      "Vincenzo Lombardo",
      "Leonardo Lesmo"
    ],
    "book": "International Conference on Computational Linguistics",
    "id": "acl-C96-2122",
    "title": "An Earley-Type Recognizer for Dependency Grammar",
    "url": "https://aclweb.org/anthology/C96-2122",
    "year": 1996
  },
  "references": [
    "acl-J90-4003",
    "acl-J92-2001",
    "acl-P91-1014",
    "acl-P93-1017"
  ],
  "sections": [
    {
      "heading": "Abstract",
      "text": [
        "The paper is a first attempt to fill a gap in the dependency literature, by providing a mathematical result on the complexity of recognition with a dependency grammar.",
        "The paper describes an improved Earley-type recognizer with a complexity 0(IGI2n3).",
        "The improvement is due to a precompilation of the dependency rules into parse tables, that determine the conditions of applicability of two primary actions, predict and scan, used in recognition."
      ]
    },
    {
      "heading": "1 Introduction",
      "text": [
        "Dependency and constituency frameworks define different syntactic structures.",
        "Dependency grammars describe the structure of a sentence in terms of binary head-modifier (also called dependency) relations on the words of the sentence.",
        "A dependency relation is an asymmetric relation between a word called head (governor, parent), and a word called modifier (dependent, daughter).",
        "A word in the sentence can play the role of the head in several dependency relations, i.e. it can have several modifiers; but each word can play the role of the modifier exactly once.",
        "One special word does not play the role of the modifier in any relation, and it is named the root.",
        "The set of the dependency relations that can be defined on a sentence form a tree, called the dependency tree (fig.",
        "la).",
        "Although born in the same years, dependency syntax (Tesniere 1959) and constituency, or phrase structure, syntax (Chomsky 1956) (see fig.lb), have had different impacts.",
        "The mainstream of formalisms consists almost exclusively of constituency approaches, but some of the original insights of the dependency tradition have found a role in the constituency formalisms: in particular, the concept of head of a phrase and the use of grammatical relations.",
        "The identification of the head within a phrase has been a major point of all the recent frameworks in linguistics: the X-bar theory (Jackendoff 1977), defines phrases as projections of (pre)terminal symbols, i.e. word categories; in GPSG (Gazdar et al.",
        "1985) and HPSG (Pollard, Sag 1987), each phrase structure rule identifies a head and a related subcategorization within its right-hand side; in HG (Pollard 1984) the head is involved in the so-called head-wrapping operations, which allow the formalism to go beyond the context-free power (Joshi et al.",
        "1991).",
        "Grammatical relations are the primitive entities of relational grammar (Perlmutter 1983) (classified as a dependency-based theory in (Mel'cuk 1988)):",
        "tree (b) for the sentence \"The chef cooked a fish\".",
        "The leftward or rightward orientation of the arrows in the dependency tree represents the order constraints: the modifiers that precede the head stand on its left, the modifiers that follow the head stand on its right.",
        "subject, object, xcomplement, ... label the dependency relations when the head is a verb.",
        "Grammatical.",
        "relations gained much popularity within the unification formalisms in early 1980's. FUG (Kay 1979) and LFG (Kaplan, Bresnan 1982) exhibit mechanisms for producing a relational (or functional) structure of the sentence, based on the merging of feature representations.",
        "All the recent constituency formalisms acknowledge the importance of the lexicon, and reduce the amount of information brought by the phrasal categories.",
        "The \"lexicalization\" of context-free grammars (Schabes, Waters 1993) points out many similarities between the two paradigms (Rainbow, Joshi 1992).",
        "Dependency syntax is an extremely lexicalized framework, because the phrase structure component is totally absent.",
        "Like the other lexicalized frameworks, the dependency approach does not produce spurious grammars, and this facility is of a practical interest, especially in writing realistic grammars.",
        "For instance, there are no heavily ambiguous, infinitely ambiguous or cyclic dependency grammars (such as S SS; S 0 a; S e; see (Tomita 1985), pp.",
        "72-73).",
        "Dependency syntax is attractive because of the immediate mapping of dependency structures on the predicate-arguments structure (accessible by the semantic interpreter), and because of the treatment of free-word order constructs (Sgall et al., 1986) (Mel'cuk 1988) (Hudson 1990).",
        "A number of parsers have been developed for some dependency frameworks (Fraser 1989) (Covington 1990) (Kwon, Yoon 1991) (Sleator, Temperley 1993) (Hahn et al.",
        "1994) (Lai, Huang 1995): however, no result of algorithmic efficiency has been published as far as we know.",
        "The theoretical worst-case analysis of 0(n3) descends from the (weak) equivalence between projective dependency grammars (a restricted of dependency grammars) and context-free grammars (Gaifman 1965), and not from an actual parsing algorithm.",
        "This paper is a first attempt to fill a gap in the literature between the linguistic merits of the dependency approach (widely debated) and the mathematical properties of such formalisms (quite negleted).",
        "We describe an improved Earley-type recognizer for a projective dependency formalism.",
        "As a starting point we have adopted a restricted dependency formalism with context-free power, that, for the sake of clearness, is described in the notation introduced by Gaifman (1965).",
        "The dependency grammar is translated into a set of parse tables that determine the conditions of applicability of the primary parser operations.",
        "Then the recognition algorithm consults the parse tables to build the sets of items as in Earley's algorithm for context-free grammars."
      ]
    },
    {
      "heading": "2 A dependency formalism",
      "text": [
        "In this section we introduce a dependency formalism.",
        "We express the dependency relations in terms of rules that are very similar to their constituency counterpart, i.e. context-free grammars.",
        "The formalism has been adapted from (Gaifman 1965).",
        "Less constrained dependency formalisms exist in the literature (Mel'cuk 1988) (Fraser, Hudson 1992), but no mathematical studies on their expressive power exist.",
        "A dependency grammar is a quintuple <S, C, W, L, T>, where W is a finite set of symbols (vocabulary of words of a natural language), C is a set of syntactic categories (preterminals, in constituency terms), S is a non-empty set of root categories (C S), L is a set of category assignment rules of the form X: x, where XEC, xEW, and",
        "belong to C. (see fig. 2).",
        "The modifier symbols Yj can take the form Yj*: as usual, this means that an indefinite number of Yj's (zero or more) may appear in an application of the rule 1.",
        "In the sample grammar below, this extension allows for several prepositional modifiers under a single verbal or nominal head without introducing intermediate symbols; the predicate-arguments structure is immediately represented by a one-level (flat) dependency structure.",
        "Let x.a1a2...ap EW* be a sentence.",
        "A dependency tree of x is a tree such that:",
        "1) the nodes are the symbols a1EW (lsisp); 2) a node ak,j has left daughters ak, l, ak",
        "occurring in this order and right daughters ak,j+1, ak,q in this order if and only if there exist the rules Ak,l: ak,j, Aki: ak j, Akm: ak,q in L and the rule Ak,j(Ak,i Ak # Aki+i Ak,q) in T. We say that ak,j, aki_i, ak ,j+1, ak,q directly depend on ak,j, or equivalently that ak,j directly governs ak,i, ak j+i , akâ€¢ aki and ak,h (h = 1, ..., j-1, j+1, q) are said to be in a dependency relation, where ak,j is the head and ak is the modifier, if there exists a sequence of nodes ai, aj+ , aj_i, aj such that ak directly depends on ak_i for each k such that i+lsksj, then we say that aj depends on aj;",
        "3) it satisfies the condition of projectivity with respect to the order in x, that is, if aj depends directly on aj and ak intervenes between them (i<k<j or j<k<i), then either ak depends on ai or ak depends on aj (see fig. 3); 4) the root is a unique symbol as such that As: as E L and AsES.",
        "The condition of projectivity limits the expressive power of the formalism to be equivalent to the context-free power.",
        "Intuitively, this principle statesaj",
        "1 The use of the Kleene star is a notational change with respect to Gaifman: however, it is not uncommon to allow the symbols on the right hand side of a rule to be regular expressions in order to augment the perspicuity of the syntactic representation, but not the expressive power of the grammar (a similar extension appears in the context-free part of the LFG formalism (Kaplan, Bresnan 1982)).",
        "that a dependent is never separated from its governor by anything other than another dependent, together with its subtree, or by a dependent of its own.",
        "As an example, consider the grammar",
        "{I, saw, a, tall, old, man, in, the, park, with, telescope}, {N: I, V: saw, D: a, A: tall, A: old, N: man, P: in, D: the, N: park, P: with, N: telescope} Tl>, where 'T1 is the following set of dependency rules: I. V(N P*); 2.",
        "V(N N P*);",
        "3.",
        "N(A*f/P*); 4.",
        "N(DA* # P*); 5.",
        "P(# N); 6.",
        "A(#); 7.",
        "D(#).",
        "For instance, the two rules for the root category V(erh) specify that a verb (V) can dominate one or two nouns and some prepositions (*)."
      ]
    },
    {
      "heading": "3 Recognition with a dependency grammar",
      "text": [
        "The recognizer is an improved Earley-type algorithm, where the predictive component has been compiled in a set of parse tables.",
        "We use two primary actions: predict, that corresponds to the top-down guessing of a category, and scan, that corresponds to the scanning of the current input word, In the subsection 3.1 we describe the data structures and the algorithms for translating the dependency rules into the parse tables: the dependency rules for a category are first translated into a transition graph, and then the transition graph is mapped onto a parse table.",
        "In the subsection 3.2 we present the Earley-type recognizer, that equals the most efficient recognizers for context-free grammar."
      ]
    },
    {
      "heading": "3.1 Transition graphs and parse tables",
      "text": [
        "A transition graph is a pair (V, E), where V is a set of vertices called states, and E is a set of directed edges labelled with a syntactic category or the symbol ft.",
        "Given a grammar G=<S, C, W, L, T>, a state of the transition graph for a category Cat E C is a 'set of dotted strings of the form \".",
        "p\", where Cat(a13) E T and a, p E (C U OW; an edge is a triple <si, sj, Y>, where sj, si E V and YE CU {11}.",
        "A state that contains the dotted string \".\"",
        "is called final; a final state signals that the recognition of one or more dependency rules has been completed.",
        "The following algorithm constructs the transition graph for the category Cat:",
        "take a non-marked dotted string ds from set-of-strings; mark ds; if ds has the form \" .Y(1\" and Y is starred then set-of-strings := set-of-strings U {\" p\"} until all clotted strings in set-of-strings are marked star:= set-of-strings.",
        "The initial set of states consists of a single state so, that contains all the possible strings \".a\", such that Cat(a) is a dependency rule.",
        "Each string is prefixed with a dot.",
        "The marked states are the states that were expanded in a previous step.",
        "The expansion of a state s takes into account each symbol Y that inunediately follows a dot (Y E C U {#}).",
        "Y is a possible continuation to a new state s', that contains the dotted string \".p\", where \".Y1-1\" is a dotted string in s. s' is added to the set of states, and a new edge from s to s' labelled with Y is added to the set of edges.",
        "A dotted string of the form .Y.p is treated as a pair of dotted strings {.Y*13, .111, so to allow a number of iterations (one or more Y's follow) or no iteration (the first symbol in (i follows) in the next step.",
        "The function \"star\" takes into account these cases; the repeat loop accounts for the case when the first symbol of is starred too.",
        "The transition graphs obtained for the five categories of G1 are in fig. 4.",
        "Conventionally, we indicate the non-final states as h and the final states as $k, where h and k are integers.",
        "The total number of states of all the transition graphs for a grammar G is at most O(IGI), where IGI is the sum of the lengths of the dependency rules.",
        "The length of a dependency rule Cat(a) is the length of a.",
        "Starting from the transition graph for a category Cat, we can build the parse table for Cat, i.e. PTcatâ€¢ Irl'cat is an array h x k, where h is the number of states of the transition graph and k is the number of syntactic categories in C. Each row is identified by a pair <Cat, State>, where State is the label of a state of the corresponding transition graph; each column is associated with a syntactic category.",
        "In miler to improve the top-down algorithm we introduce the concept of \"first\" of a category.",
        "The first of the category Cat is the set of categories that appear as leftmost node of a subtree headed by Cat.",
        "The first of a category X is computed by a simple procedure that we omit here.",
        "The function parse_table computes the, parse tables of the various categories.",
        "E(t-graphcat) returns the set of the edges of the graph t-graphcat.",
        "The contents of the entries in the parse tables are sets (possibly empty) of predict and scan.",
        "The initialization step consists in setting all entries of the table to the empty set.",
        "The parse tables for the grammar G I are reported in fig. 5.",
        "The firsts are: first(V)=first(N)={N, A, D}; first(P)={P}; first(A)={A}; first(D)={D}.",
        "Note that an entry of a table can contain more than one action, although this does not happen for our simple grammar G 1.",
        "32 A dependency recognizer The dependency recognizer exhibits the same data structures of Earley's recognizer (Earley 1970), but improves the performance of that algorithm because of the precompilation of the predictive component into the parse tables.",
        "In order to recognize a sentence of n words, n+1 sets Si of items are built.",
        "An item is a quadruple <Category, State, Position, Depcat> where the first two elements (Category and State) correspond to a row of the parse table PTCategory, the third element (Position) gives the index i of the set Si where the recognition of a substructure began, and the fourth one (Depcat) is used to request the completion of a substructure headed by Depcat,",
        "before continuing in the recognition of the larger structure headed by Category (Depcat \"_\" means that the item is not waiting for any completion).",
        "The external loop of the algorithm cycles on the sets Si (0 s i s n); the inner loop cycles on the items of the set Si of the form <Cat, State, j, At each step of the inner loop, the action(s) given by the entry \"<Cat, State> x Inputcat\" in the parse table PTCat is(are) executed (where Inputcat is one of the categories of the current word).",
        "Like in Earley's parser there are three phases: completer, predictor and scanner.",
        "completer: When an item is in a final state (of the form $h), the algorithm looks for the items which represent the beginning of the input portion just analyzed: they are the four-element items contained in the set referred by j.",
        "These items are inserted into Si after having set to \"null\" the fourth element (_).",
        "predictor: \"<predict(Cat'), State>\" corresponds to a prediction of the category Cat' as a modifier of the category Cat and to the transition to State', in case a substructure headed by Cat' is actually found.",
        "This is modeled by introducing two new items in the set: a) <Cat', 0, i, _>, which represents the initial state of the transition graph of the category Cat' which will span a portion of the input starting at i.",
        "In Earley's terms, this item corresponds to all the dotted rules of the form Cat'(.",
        "a).",
        "b) <Cat, State', j, Cat'>, which represents the arc of the transition graph of the category Cat, entering the state State' and labelled Cat'.",
        "In Earley's terms, this item corresponds to a dotted rule of the form Cat(a .",
        "Cat' (3).",
        "The items including a non-null Depcat are just passive receptors waiting to be reactivated later when (and if) the recognition of the hypothesized substructure has successfully completed.",
        "scanner: \"<scan, State'>\" results in inserting a new item <Cat, State', i, _> into the set Si+i Let us trace the recognition of the sentence \"I saw a tall old man in the park with a telescope\".",
        "The first set So (fig.",
        "6) includes three items: the first one, <V, 0, 0, _>, is produced by the initialization; the next two, <V, 1, 0, N> and <N, 0, 0, _> are produced by the predictor (a N-headed subtree beginning in position 0 must be recognized and, in case such a recognition occurs, the governing V can pass to state 1).",
        "In Si the first item <N, $2, 0, _> is produced by the scanner: it is the result of advancing on the input string according to the item <N, 0, 0, _> in SO with an input noun \"1\" (the entry in the parse table PTN <N, 0> x N contains <scan,$2>).",
        "The next item, <V, 1, 0, _> is produced by applying the completer to the item in SO <V, 1, 0, N>, 52 contains the item <V, $2, 0, _>, obtained by the scanner, that advances on the verb \"saw\".",
        "The other four items are the result of a double application of the predictor, which, in a sense, builds a \"chain\" that consists of a noun governed by the root verb and of a determiner governed by that noun; this is the only way, according to the grammar, to accomodate an incoming determiner when a verb is under analysis.",
        "The subsequent steps can easily be traced by the reader.",
        "The input sentence is accepted because of the appearance in the last set of the item <V, $3, 0, _>, encoding that a structure headed by a verb (i.e. a root category), ending in a final state ($3), and covering all the words from the beginning of the sentence has been successfully recognized.",
        "The space complexity of the recognizer is O(IGI n2).",
        "Each item is a quadruple <Cat, State, Position, Depcat>: Depcat is a constant of the grammar; the pairs of Cat and State are bounded by O(IGI); So [I] <N, 0, 2 _> <N, 1, 2, _> <V, $3, 0, P> <N, 1, 7, _> <V, 0, 0, <N, 1, 2, 1J> <A, 0, 4, _> <N, $2, 2, P> S10 la] S12 _> <V, I , 0, N> <D, 0, 2, _> <N, I, 2, A> S9 [with] <P, I, 9, _> <N, $2, 10, _> <N, 0, 0, S7 'the] <N, $2, 7, _> <N, 0, 10, _> <P, $2, 9, _> _> S [tall] S5 [man] <P, 1, 6, _> <P, $2,6, _> <P, $2 , 9,N> <N, $2, 7 _> S 1 [saw] <1), $1, 2, _> <A, $1 , 4, _> <N, 0, 7, _> <N, $2, 2, _> <D, 0, 10, _> <N, $2, 2, _> <N, $2, 0, _> <N, 1,2, _> <N, 1, 2, _> <P, $2, 6, N> <V, $3, 0, _> <N, 1, 10, D> <V, $3, 0, _> <V, 1, 0, <A, 0, 3, _> <I), 0, 7 , _> <P, 0, 9, _> <P, $2, 6, _> _> <N, 1,2, A> S6 lin' <N, 1, 7, D> <N, $2, 7, P> S]] [telescope] S2 [a] 54 [old] <N, $2, 2, _> S8 [park] <N, $2, 2, P> <D, $1, 10, _> <V, $2, 0, _> <V, $3,2, _> <V, $3, 0, P> <N, 1, 10, _> <V, $3, 0, N> <A, $1, 3, _> <P, 0,6, _> <D, $1, 7, _>",
        "Position is bounded by 0(n).",
        "The number of such quadruples in a set of items is bounded by 0(1G1 n) and there are n sets of items.",
        "The time complexity of the recognizer is 0(1G12 n3).",
        "The phases scanner and predictor execute at most 0(1G1) actions per item; the items are at most 0(1G1 n2) and the cost of these two phases for the whole algorithm is 0(IG12n2).",
        "The phase completer executes at most one action per pair of items.",
        "The variables of such a pair of items are the two states (0(1G12)), the two sets that contain them (0(n2)), and the two positions (0(n2)).",
        "But the pairs considered are not all the possible pairs: one of the sets has the index which is the same of one of the positions, and the complexity of the completer is 0(1G12 n3).",
        "The phase completer prevails on the other two phases and the total complexity of the algorithm is 0(1G12 n3).",
        "Even if the 0-analysis is equivalent to Earley's, the phase of precompilation into the parse tables allows to save a lot of computation time needed by the predictor.",
        "All the possible predictions are precomputed in the transition to a new state.",
        "A similar device is presented in (Schabes 1990) for context-free grammars."
      ]
    },
    {
      "heading": "4 Conclusion",
      "text": [
        "The paper has described a recognition algorithm for dependency grammar.",
        "The dependency formalism is translated into parse tables, that determine the conditions of applicability of the parser actions.",
        "The recognizer is an improved Earley-type algorithm, whose performances are comparable to the best recognizers for the context-free grammars, the formalism which is equivalent to the dependency formalism described in this paper.",
        "The algorithm has been implemented in Common Lisp and runs under the Unix operating system.",
        "The next step in our research will be to relax the condition of projectivity in order to improve the expressive power and to deal with phenomena that go beyond the context-free power.",
        "These changes imply the restructuring of some parts of the recognizer, with a plausible increment of the complexity."
      ]
    }
  ]
}
