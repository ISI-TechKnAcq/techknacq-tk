{
  "info": {
    "authors": [
      "Shelly P. Harrison",
      "T. Mark Ellison"
    ],
    "book": "Computational Linguistics",
    "id": "acl-J92-4005",
    "title": "Restriction and Termination in Parsing With Feature-Theoretic Grammars",
    "url": "https://aclweb.org/anthology/J92-4005",
    "year": 1992
  },
  "references": [
    "acl-P85-1018"
  ],
  "sections": [
    {
      "text": [
        "Here, we describe one class of grammars for which restriction, as described by Shieber, induces non-termination.",
        "We do not suggest that the concept of restriction is fatally flawed, however.",
        "On the contrary, relatively minor modifications to the implementation of restriction can make it a more flexible tool for fine-tuning PATR grammars."
      ]
    },
    {
      "heading": "Background",
      "text": [
        "Shieber (1987) observes that the potentially infinite category domain of feature-theoretic grammar formalisms like PATR-II makes implementing efficient parsers for such formalisms difficult.",
        "He concludes that the two earliest approaches to the problem are at best ill-advised.",
        "Parsing with a context-free backbone effectively ignores information in fact available to guide the parse and violates the spirit of feature-theoretic grammar.",
        "Tailoring the parsing algorithm or the grammar itself to the exigencies of feature-theoretic formalisms puts the burden of coping with the problem in the wrong place, on the end user of a grammar development system.",
        "The most obvious alternative to parsing with a context-free backbone is using graph unification, rather than atomic symbol identity, to drive the parsing process.",
        "Shieber notes that not only is that approach costly (in using information that in fact can never affect the outcome of a parse) but, for some grammars, induces non-termination.",
        "The class of grammars Shieber describes might be termed top-down path building grammars, because they are grammars in which the length of a path through the graph increases as one descends the parse tree.",
        "The particular grammar Shieber uses is one that counts the number of terminal symbols in the string being parsed:",
        "In the course of a derivation, G1 builds a path (Tnf+) from the root of the graph Tn corresponding to each node Tn in the tree.",
        "The 'count' is reflected in the length of the path (Ttif +).",
        "As one descends the tree, the length of the path that is the value of the attribute f increases by 1 for each successive node Tn+i: Hence the term top-down path building, characterizing grammars like G1.",
        "Recall that, in a chart parsing regime, for each active edge Em of the form:",
        "the top-down rule adds an active edge En of the form: Y",
        "If, associated with Em, there is a graph Gm, and with Ri a graph G1, then associated with En will be a graph Gn = G, U Gm (Y), where Gm (Y) is the subgraph of Gm at Y.",
        "As Shieber points out, a parser employing this top-down rule will not terminate when interpreting grammar G1.",
        "On initialization (with Rule 'set end marker'), the parser generates an active edge seeking a constituent of category T. The top-down rule then uses that edge and the Rule 'recursive clause' to generate a new active edge seeking a constituent of category T. That active edge then generates a new (and, crucially, a distinct) active edge not subsumed by any existing edge, \"and so forth, ad infinitum.\" In other words, each top-down recursion anticipates a different terminal string that is one symbol longer than that predicted on the previous recursion; because the graphs associated with those anticipated strings are distinct, the normal chart parsing checks fail to prevent looping.",
        "Shieber's solution to the problem posed by grammar G1 is to introduce a notion he terms restriction.",
        "Under restriction, the graph associated with an edge generated by the top-down rule (applied to an active edge Em and a grammar rule Ri) is not a graph G = G, U Gm (X), where G, is the graph associated with R, and Gm (X) is that portion of the graph (associated with Em) corresponding to the left hand side of R1.",
        "Rather, G = G, U (Gm(X0), where Gni(X)!4)) is a graph G' resulting from filtering out of Gm all those paths not explicitly sanctioned by I.",
        "The filter l is termed a restrictor, and is represented as a set of paths P. The graph G' (= G!.1)) is derived from G by filtering out all those paths that are not members of P.1 Given a restrictor that passes through only the (cat) path, the termination problem for grammar G1 vanishes.",
        "Since the active edges generated by the top-down rule pass on only their category information, each time the rule 'recursive clause' is called recursively, the edge it generates is the same (underspecified) edge generated on the first call to that rule, and already on the chart.",
        "The following observations regarding the restrictors Shieber describes might be made at this point:",
        "1.",
        "The graph for the active edge generated by the top-down rule with a parser using restriction is no less specific (has no less information) than the graph stipulated by the rule used; i.e., it is information from the extant active edge that is suppressed.",
        "2.",
        "The restrictor provides a positive restriction, i.e., it stipulates which paths are included in the restricted graph, not which paths are suppressed."
      ]
    },
    {
      "heading": "A Problem: Bottom-up Path Building",
      "text": [
        "The following grammar might be considered almost the inverse of the grammar G1 described by Shieber (1987).",
        "It parses strings of length 1, and generates one node T in",
        "That definition might seem to suggest that paths that are instantiated (atom valued) are not filtered out by the restrictor.",
        "His examples demonstrate that that is not the correct interpretation of his definition.",
        "Rather, it would seem that atomic paths (i.e. 'leaves'), and not atomic-valued paths, fall through the filter.",
        "For this grammar, the length of the path (Tng+) in each subgraph Tn increases as one ascends the tree.",
        "Hence the term bottom-up path building is used to characterize grammars of this sort.",
        "Using the same restrictor (i.e. (cat)) employed for Gl, a parser interpreting G2 will not terminate on any grammatical input.",
        "As in Gl, only one active edge generated from the Rule 'recursive clause' is put on the chart:",
        "The rule 'base clause' of G2 generates the passive edge:",
        "and then applies to El and E3 to yield:",
        "and so forth, ad infinitum.",
        "Ultimately, the fundamental rule will generate a passive edge with a graph G such that G(g) {G, : T' (g) for the passive edge:",
        "where {G, : T'(g)} is the subgraph corresponding to the constituent T. At that point, the parser, in effect, will have parsed the input string.",
        "Nonetheless, it will continue to add new passive edges, each with a graph whose (g+) path is one arc longer than that of the passive edge from which it is generated.",
        "Bottom-up path building grammars are not without interesting linguistic applications.",
        "Consider, for example, the following PATR implementation of the append operation on lists employed in HPSG (Pollard and Sag 1987; Section 2.2): (G3)"
      ]
    },
    {
      "heading": "Rule 'collect lists'",
      "text": [
        "Top Left Right Append: (Append list1) = (Left list) (Append list2) = (Right list) (Top list) = (Append list).",
        "(Appendo list first) = (Appendo listl first) (Appendo list rest) = (Appendi list) (Appendo listl rest) = (Appendi listl) (Appendi list2) = (Appendo list2).",
        "Given the rules 'base case' and 'recursive clause,' one need only introduce a 'dummy' constituent Append (whose only function is to collect the list-valued attributes listl and list2 in a single list), and appropriate constraints on some list-valued attribute, in order to simulate the HPSG append in PAIR.",
        "Unfortunately, because these two rules are an instance of the bottom-up path building problem, no derivation employing these rules will terminate.2"
      ]
    },
    {
      "heading": "Solutions",
      "text": [
        "The source of the bottom-up path building problem is the active edge E1 above, whose (g+) path is of indeterminate length.",
        "Because the parser does not know how long that path should be, it keeps adding to it ad infinitum.",
        "Observe, however, that the parser had the required information (obtained from the (g) attribute of constituent A), but was induced by the restrictor to throw that information away.",
        "There are at least three solutions to the problem posed by bottom-up path building grammars under restriction:",
        "1.",
        "Impose a finite limit on the path (g+).",
        "2.",
        "Convert the grammar to top-down path building.",
        "3.",
        "Change the nature and implementation of restriction.",
        "We consider each of these proposals in turn in the following paragraphs.",
        "Solution 1 involves picking an arbitrary upper limit on the length of (g+), and adding a corresponding path to the restrictor.",
        "The parser would then terminate for any input whose (g+) path length is less than or equal to that of the stipulated path.",
        "For example, a parser interpreting G2 above would terminate with the restrictor {(cat)(g g g)}.",
        "But that is a \"Band-Aid\" solution at best.",
        "2 The append operation is necessary whenever a grammar demands that two list-valued attributes be combined; for example, when the SUBCAT of a constituent is defined as the union of the values of SUBCAT for its daughters, or when the list-valued SKELETON of a syllable is defined as the SKELETON of the onset followed by the SKELETON of the rhyme.",
        "One would, of course, prefer to have PATR extended to accommodate append, rather than have to simulate the append operation in pure PATR, but that is not the issue here.",
        "The point we are making is simply that one could simulate append in pure PATR, were it not for the restriction regime of the PATR standard defined in Shieber (1989).",
        "Solution 2 might involve a grammar like G4, a top-down path building grammar weakly equivalent to G2.",
        "G4 does not, however, have the termination problem of G2:",
        "Consider the case of two descendants, Left and Right, of a node Top, where the value of (Left list) is (a, b), the value of (Right list) is (c, d), and the value of (Top list) is append ((L list), (R list)).",
        "G3 assigns to that construction the parse tree:"
      ]
    },
    {
      "heading": "Left Right Append() Appendi Append2",
      "text": [
        "and the complex feature structure:",
        "As noted above, G3 provides a 'dummy' constituent Append that one might want ultimately to prune, since its only function is to assemble the appended list.",
        "By contrast, G5 assembles the appended list in successive Append nodes dominating the constituents Left and Right.",
        "One might want to argue that the latter solution is less felicitous than the former because the Append nodes dominate lexical material.",
        "In any event, as Shieber stresses, the grammar writer should not be constrained to choose between weakly equivalent grammars by the demands of the grammar development system.",
        "Let us now consider solution 3, modifying the nature and implementation of restriction.",
        "We choose to term the sort of restriction Shieber describes positive restriction.",
        "In positive restriction, the restrictor tells the parser how much of the information for which paths to retain (in the graph corresponding to the active edge used by the top-down rule).",
        "If a path is not explicitly mentioned in the restrictor, no information about that path is retained.",
        "An empty restrictor in effect tells the parser to throw away all the information in the restricted graph.",
        "(An anonymous reviewer for Computational Linguistics points out that grammars G2 and G3, in contrast to Shieber's Gl, are not offline parsable [in the sense of Bresnan and Kaplan 1982:263ff and Johnson 1988:95ff], and suggests that this failure of offline parsability is a necessary condition for membership in the class of grammars that are",
        "nonterminating under positive restriction.",
        "The constituent structures generated by a grammar are offline parsable iff: i. they contain no nonbranching dominance chains in which the same category [label] appears twice, and ii.",
        "all terminal nodes dominate lexical material G2 and G3 fail both these conditions, since neither the T node chain of G2 nor the Append node chain of G3 either branch or dominate lexical material.",
        "We make two observations in this regard.",
        "First, while it may indeed be the case that failure of offline parsability is a necessary condition for non-termination under positive restriction, it is certainly not a sufficient one, since G4 and G5 both fail condition i. above, and are thus not offline parsable, but do terminate under positive restriction.",
        "Second, though G2 through G5 fail the letter of an offline parsability constraint, they do not fail its spirit.",
        "Offline parsability has been proposed as a constraint on grammars guaranteeing the decidability of the recognition problem for feature-theoretic grammars of the sort considered here.",
        "For grammars that satisfy offline parsability, it will be the case that the number of nodes of any parse tree assigned to some string will be a computable function of the length of the string being parsed.",
        "This is not the case for G2 through G5.",
        "What is the case, however, is that the number of nodes in a parse tree generated by those grammars is a computable function of the graphs associated with the lexical material covered by the tree.",
        "This is because each of these grammars makes crucial reference either to a list-valued or path-valued attribute of lexical items, where the length of the list or path is finite and stipulated in the lexicon.",
        "The number of identical nodes in any nonbranching dominance chain generated by these grammars is a function of the length of a [bounded] list or path.)",
        "Positive restriction can be contrasted with what might be termed negative restriction.",
        "Under negative restriction, the restrictor tells the parser what information to throw away.",
        "For stipulated paths, the effects of positive and negative restriction are the same: a restrictor (ggg) tells the parser to (positively) retain all information up to and including an atomic value for the path (ggg), or to (negatively) throw away all information about any nonatomic extension of (ggg).",
        "The difference is in the interpretation of paths not explicitly mentioned; under positive restriction these are thrown away; under negative restriction they are retained.",
        "In formal terms, a restrictor, for Shieber, is a relation between paths and the single edges that are permitted to extend those paths: If 4) is a restrictor, p a path and 1 some edge label, then the restrictor permits the path pl iff 01.",
        "But Shieber does not use the full power of this formalism.",
        "He considers only what we term positive restrictors.",
        "Mathematically, if P is some finite set of paths, one can define a positive restrictor (1)11 to be the relation defined by: p�pliff3gEP, p < q where p < q means that p is a (perhaps improper) prefix to the path q.",
        "By contrast, the negative restriction regime proposed here allows paths not explicitly disallowed: 0)171 iff (3 r E P, r < p) 3 q E P, p q (1) In other words, whereas the positive restrictor admits those paths obeying the condition \"is a prefix of a member of the restrictor set,\" the negative restrictor only applies",
        " this condition to paths extending members of the restrictor set.",
        "Paths not extending members of the restrictor set are themselves not subject to restriction.",
        "It is an easy matter to show that any positive restrictor p can be defined in terms of a negative restrictor.",
        "If the null path is included in the restrictor set, then the antecedent of the implication in the definition of .13- (1 above) is always true (except if p = ( )), and the consequent 3q E P U {( )}, p < q is equivalent to 2q E P, p < q (except when",
        "is equivalent to NP 1.",
        "For other p, 043puf 011 = 043tl.",
        "So, 4)p-u{0} = 431t.",
        "Thus, an implementation using negative restriction can simulate any positive restrictor and, therefore, can necessarily solve all problems solvable by positive restriction, as well as those problems, described earlier, where positive restriction fails.",
        "Note that we have limited ourselves, as Shieber has, to finite restrictor sets.",
        "This limitation is not necessary.",
        "A more general proposal allows restrictor sets consisting of all paths expressable by some regular expression.",
        "Restrictors can then be implemented as finite state automata.",
        "An implementation of this sort would not impose a large computational burden and would allow much greater flexibility in the choice of restrictor relations.",
        "We have demonstrated that any restriction definable by a positive restrictor can also be defined by a negative restrictor.",
        "It follows that any parser requiring positive restriction to guarantee termination will also terminate for the same set of grammars using negative restriction.",
        "But we have also demonstrated that the reverse does not hold.",
        "Therefore, it would seem that negative restriction is superior to positive restriction in the implementation of parsers for feature-theoretic grammars."
      ]
    }
  ]
}
