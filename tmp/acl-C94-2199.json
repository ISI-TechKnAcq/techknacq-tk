{
  "info": {
    "authors": [
      "Marc Dymetman"
    ],
    "book": "International Conference on Computational Linguistics",
    "id": "acl-C94-2199",
    "title": "A Simple Transformation for Online-Parsable Grammars and Its Termination Properties",
    "url": "https://aclweb.org/anthology/C94-2199",
    "year": 1994
  },
  "references": [
    "acl-C90-3017",
    "acl-C92-1057",
    "acl-P83-1021",
    "acl-P89-1029"
  ],
  "sections": [
    {
      "heading": "Abstract",
      "text": [
        "We present, in easily reproducible terms, a simple transformation for offline-parsable grammars which results in a provably terminating parsing program directly top-down interpretable in Prolog.",
        "The transformation consists in two steps: (1) removal of empty-productions, followed by: (2) left-recursion elimination.",
        "It is related both to left-corner parsing (where the grammar is compiled, rather than interpreted through a parsing program, and with the advantage of guaranteed termination in the presence of empty productions) and to the Generalized Greibach Normal Form for DCGs (with the advantage of implementation simplicity)."
      ]
    },
    {
      "heading": "1 Motivation",
      "text": [
        "Definite clause grammars (DCGs) are one of the simplest and most widely used unification grammar formalisms.",
        "They represent a direct augmentation of context-free grammars through the use of (term) unification (a fact that tends to be masked by their usual presentation based on the programming language Pro-log).",
        "It is obviously important to ask wether certain usual methods and algorithms pertaining to CMGs can be adapted to DCGs, and this general question informs much of the work concerning DCGs, as well as more complex unification grammar formalisms (to cite only a few areas: Earley parsing, LR parsing, left-corner parsing, Greibach Normal :Form).",
        "One essential complication when trying to generalize CFG methods to the DCG domain lies in the fact that, whereas the parsing problem for CloGs is decidable, the corresponding problem for DCGs is in general undecidable.",
        "This can be shown easily as a consequence of the noteworthy fact that any definite clause program can be viewed as a definite clause grammar \"on the empty string\", that is, as a DCG where no terminals other than [ ] are allowed on the right-hand sides of rules.",
        "The Turing-completeness of definite clause programs therefore implies the undecidability of the parsing problem for this subclass of DCGs, and a fortiori for DCGs in general.]",
        "In order to guarantee good",
        "computational properties for DCGs, it is then necessary to impose certain restrictions on their form such as offline-parsability (OP), a nomenclature introduced by Pereira and Warren [11], who define an OP DCG as a grammar whose context-free skeleton CFG is not infinitely ambiguous, and show that 01' DCGs lead to a decidable parsing problem.2 Our aim in tins paper is to propose a simple transformation for arr arbitrary OP DCG putting it into a form which leads to the completeness of the direct top-down interpretation by the standard Prolog interpreter: parsing is guaranteed to enumerate all solutions to the parsing problem and terminate.",
        "The existence of such a transformation is known: in [1, 2], we have recently introduced a \"Generalized Greibach Normal Form\" (GGNF) for DCGs, which leads to termination of top-down interpretation in the OP case.",
        "However, the available presentation of the GGNF transformation is rather complex (it involves an algebraic study of the fixpoints of certain equational systems representing grammars.).",
        "Our aim here is to present a related, but much simpler, transformation, which from a theoretical viewpoint performs somewhat less than the GGNF transformation (it involves some encoding of the initial DCG, which the GGNF does not, and it only handles offline-parsable grammars, while the GGNF is defined for arbitrary DCGs),3 but in practice is extremely easy to implement and displays a comparable behavior when parsing with an OP grammar.",
        "The transformation consists of two steps: (1) empty-production elimination and (2) left-recursion elimination.",
        "The empty-production elimination algorithm is inspired by the usual procedure for context-free grammars.",
        "But there are some notable differences, due to the fact that removal of empty-productions is in general impossible for non-OP DCGs.",
        "The empty-but they are in fact at the core of the offline-parsability concept.",
        "See note 3. concept of offline-parsability (under a different name) goes back to [8], where it is shown to be linguistically relevant.",
        "production elimination algorithm is guaranteed to terminate only in the OP case:1 It produces a DC(1 declaratively equivalent to the original grammar, The left-recursion elimination algorithm is adapted from a transformation proposed in [4] in the context of a certain formalism (\"Lexical Grammars\") which we presented as a possible basis for building reversible grammars.",
        "The key observation (in slightly different terms) was that, in a DCG, if a nonterminal g is defined literally by the two rules (the first of which is left-recursive):",
        "then the replacement of these two rules by the three rules (where die is a new nonterminal symbol, which represents a kind of \"transitive closure\" of d):",
        "preserves the declarative semantics of the grammar!' We remarked in [4] that this transformation \"is closely related to left-corner parsing\", but did not give details.",
        "In a recent paper [7], Mark Johnson introduces \"a left-corner program transformation for natural language parsing\", which has sonic similarity to the above transformation, but which is applied to definite clause programs, rather than to D(101s.",
        "He proves that this transformation respects declarative equivalence, and also shows, using a model-theoretic approach, the close connection of his transformation with left-corner parsing [12, 9, 10].7 It must be noted that the left-recursion elimination procedure can lie applied to any DCG, whether OP or not.",
        "Even in the case where the grammar is OP, however, it will not lead to a terminating parsing algorithm unless empty productions have been prealably eliminated from the grammar, a problem which is shared by the usual left-corner parser-interpreter.",
        "4 The fact that the standard CFC: empty-production elimination transformation is always possible is related to the fact that this transformation does not preserve degrees of ambiguity.",
        "For instance the infinitely ambiguous grammar S [b] A, A A, A [ ] is simplified into the grammar S N. This type of simplification is generally impossible, in a I )(Xl.",
        "Consider for",
        "5 The method goes hack to a transformation used to compile oat certain local cases of left-recursion from IX-Xis in the context of the Machine Translation prototype CRITTER [3].",
        "6A proof of this fact, based on a comparison of proof-trees for the original and the transformed grammar, is given in [2].",
        "7fIis paper does not state termination conditions for the transformed program.",
        "Such termination conditions would probably involve some generalized notion of ofiline-parsability [6, 5, 13].",
        "Hy contrast, we prove termination only for DCGs which are OP in the original sense of Pereira and Warren, but this case seems to us to represent much of the core issue, and to lead to some direct extensions.",
        "For instance, the DCG transformation proposed here can be directly applied to \"guided\" programs in the sense of [4].",
        "Due to the space available, we do not give here correctness proofs for the algorithms presented, but expect to publish them in a fuller version of this paper.",
        "These algorithms have actually been implemented in a slightly extended version, where they are also used to decide whether the grammar proposed for transformation is in fact offline-parsable or not.",
        "2 Empty-production elimination It can be proven that, if D(;GO is an OP DCG, the following transformation, which involves repeated partial evaluation of rules that rewrite into the empty string, terminates after a finite number of steps and produces a grammar DCG without empty-productions which is equivalent to the initial grammar on nonempty strings:8 input: an offline-parsable D0(11.",
        "output: a DC.%G without empty rides equivalent to Defli I on non-empty strings.",
        "algorithm:",
        "initialize 1,15T1 to a list of the rules of DC01 set 1,19T2 to the empty list.",
        "while there exists all empty rule IAt: [] iu LIST do: move ER to LIST2.",
        "for each rule It: I3(...) a in I,IST1 such that ry contains an instance of A(...) (including new such rules created inside this loop) do: for each such instance A (Si , ...,Sk) unifiable with (1/1 , Tk) do: append to LIST) a rule 11,': 13(...). – / a' obtained from If by removing /1(51,..., Sk) from a (or by replacing it with [] if this was the only nonterminal in a), and by unifying the Ti's with the Si's. set 1)(.1l0 to LTS'I'l. For instance the grammar consisting in the nine rules appearing above the separation in fig. 1 is transformed into the grammar (see figure):"
      ]
    },
    {
      "heading": "3 Left-recursion elimination",
      "text": [
        "The transformation can be logically divided into two steps: (1) an encoding of DCG into a \"generic\" form DCG', and (2) a simple replacement of a certain group of left-recursive rules in DCG' by a certain equivalent non left-recursive group of rules, yielding a top-down interpretable DCG\".",
        "An example of the transformation DCG DCG' DCG\" is given in fig. 2.",
        "The encoding is performed by the following algorithm: input: an offline-parsable DCG without empty rules.",
        "output: an equivalent \"encoding\" DOG'.",
        "algorithm: initialize LIST to a list of the rules of DCG.",
        "initialize DCG' to the list of rules (literally):",
        "where a' is obtained by replacing any C(V1,..., V m) in a by g(C(V1, ..., V w)), or is set to [ ] in the case where a is empty.",
        "while there exists a rule 11 of the form A(T1,...,T1c) [terminal] a in LIST do: remove R from LIST.",
        "add to DCG' a rule It': t(A(T1, ...,Tk)) [terminal] a', where a' is obtained by replacing any C(V1, Vrn) in a by g(C(V1,..., Vm)), or is set to [] in the case where a is empty.",
        "The procedure is very simple.",
        "It involves the creation of a generic nonterminal g(X), of arity one, which performs a task equivalent to the original nonterminals s(X 1, .. , X n), vp(X 1, , Xm), ....",
        "The goal g(s(Xl, , X n)), for instance, plays the same role for parsing a sentence as did the goal s(Xl, , X n) in the original grammar.",
        "Two further generic nonterminals are introduced: 1(X) accounts for rules whose right-hand side begins with a terminal, while d(Y, X) accounts for rules whose right-hand side begins with a nonterminal.",
        "The rationale behind the encoding is best understood from the following examples, where represents rule rewriting:",
        "The second example illustrates the role played by d(Y, X) in the encoding.",
        "This nonterminal has the following interpretation: X is an \"immediate\" extension of Y using the given rule.",
        "In other words, Y corresponds to an \"immediate left-corner\" of X.",
        "The left-recursion elimination is now performed by the following \"algorithm\" :9 input: a DOG' encoded as above.",
        "output: an equivalent non left-recursive DOG\".",
        "algorithm: initialize DCG\" to DCG'.",
        "in DCG\", replace literally the rules:",
        "In this transformation, the new nonterminal d_tc plays the role of a kind of transitive closure of d. It can be seen that, relative to DCG\", for any string w and for any ground term z, the fact that g(z) rewrites into w – or, equivalently, that there exists a ground term x such that 1(x) d_tc(x, z) rewrites into w – is equivalent to the existence of a sequence of ground terms x = xl, xk z and a sequence of strings wi, • • • , wk such that t(x 1) rewrites into WI, d(x 1, x2) rewrites into w2, •••, d(xk- I, xk) rewrites into Wk, and such that w is the string concatenation w = wi • • • wk.",
        "From our previous remark on the meaning of d(Y, X), this can be interpreted as saying that \"consituent x is a left-corner of constituent z\", relatively to string w. The grammar DCG\" can now be compiled in the standard way--via the adjunction of two \"differential list\" arguments – into a Prolog program which can be executed directly.",
        "If we started from an offline-parsable grammar DCGO, this program will enumerate all solutions to the parsing problem and terminate after a finite number of steps.'°"
      ]
    }
  ]
}
