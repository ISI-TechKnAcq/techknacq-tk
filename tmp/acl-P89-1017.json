{
  "info": {
    "authors": [
      "Rene Leermakers"
    ],
    "book": "Annual Meeting of the Association for Computational Linguistics",
    "id": "acl-P89-1017",
    "title": "How to Cover a Grammar",
    "url": "https://aclweb.org/anthology/P89-1017",
    "year": 1989
  },
  "references": [
    "acl-E87-1022"
  ],
  "sections": [
    {
      "heading": "Renê Leermakers Philips Research Laboratories, P.O. Box 80.000 5600 JA Eindhoven, The Netherlands ABSTRACT",
      "text": [
        "A novel formalism is presented for Earley-like parsers.",
        "It accommodates the simulation of non-deterministic pushdown automata.",
        "In particular, the theory is applied to non-deterministic LR-parsers for RTN grammars."
      ]
    },
    {
      "heading": "1 Introduction",
      "text": [
        "A major problem of computational linguistics is the inefficiency of parsing natural language.",
        "The most popular parsing method for context-free natural language grammars, is the general context-free parsing method of Earley [1].",
        "It was noted by Lang [2], that Earley-like methods can be used for simulating a class of non-deterministic pushdown automata(NPDA).",
        "Recently, Tomita [3] presented an algorithm that simulates non-deterministic LR-parsers, and claimed it to be a fast algorithm for practical natural language processing systems.",
        "The purpose of the present paper is threefold: 1 A novel formalism is presented for Earley-like parsers.",
        "A key role herein is played by the concept of bilinear grammars.",
        "These are defined as context-free grammars, that satisfy the constraint that the right hand side of each grammar rule have at most two non-terminals.",
        "The construction of parse matrices for bilinear grammars can be accomplished in cubic time, by an algorithm called C-parser.",
        "It includes an elegant way to represent the (possibly infinite) set of parse trees.",
        "A case in point is the use of predict functions, which impose restrictions on the parse matrix, if part of it is known.",
        "The exact form and effectiveness of predict functions depend on the bilinear grammar at hand.",
        "In order to parse a general context-free grammar G, a possible strategy is to define a cover for G that satisfies the bilinear grammar constraint, and subsequently parse it with C-parser using appropriate predict functions.",
        "The resulting parsers are named Earley-like, and differ only in the precise description for deriving covers, and predict functions.",
        "2 We present the Lang algorithm by giving a bilinear grammar corresponding to an NPDA.",
        "Employing the correct predict functions, the parser for this grammar is equivalent to Lang's algorithm, although it works for a slightly different class of NPDA's.",
        "We show that simulation of non-deterministic LR-parsers can be performed in our version of the Lang framework.",
        "It follows that Earley-like Tomita parsers can handle all context-free grammars, including cyclic ones, although Tomita suggested differently[3].",
        "3 The formalism is illustrated by applying it to Recursive Transition Networks(RTN)[8].",
        "Applying the techniques of deterministic LR-parsing to grammars written as RTN's has been the subject of recent studies [9,10].",
        "Using this research, we show how to construct efficient non-deterministic LR-parsers for RTN's."
      ]
    },
    {
      "heading": "2 C-Parser",
      "text": [
        "The simplest parser that is applicable to all context-free languages, is the well-known Cocke-Younger-Kasami (CYK) parser.",
        "It requires the grammar to be cast in Chomsky normal form.",
        "The CYK parser constructs, for the sentence zi..x., a parse matrix T. To each part zi+1..xi of the input corresponds the matrix element the value of which is a set of non-terminals from which one can derive Z,..1..z.",
        "The algorithm can easily be generalized to work for any grammar, but its complexity then increases with the number of non-terminals at the right hand side of grammar rules.",
        "Bilinear grammars have the lowest complexity, disregarding linear grammars which do not have the generative power of general context-free grammars.",
        "Below we list the recursion relation T must satisfy for general bilinear grammars.",
        "We write the grammar as as a four-tuple (N, E, P, S), where N is the set of non-terminals, E the set of terminals, P the set of production rules, and S N the start symbol.",
        "We use variables I, J, K,L E N, j,132,33 E E*, and 1, j, ki ..k4 as indices of the matrix 7'1.",
        "The relation cin be solved for the diagonal elements T.„ independently of the input sentence.",
        "They are equal to the set of non-terminals that derive in one or more",
        "steps.",
        "Algorithms that construct T for given input, will be referred to as C-parsers.",
        "The time needed for constructing T is at most a cubic function of the input length n, while it takes an amount of space that is a quadratic function of n. The sentence is successfully parsed, if S E Ton.",
        "From T, one can simply deduce an output grammar 0, which represents the set of parse trees.",
        "Its non-terminals are triples <1,1, j >, where I is a non-terminal of the original bilinear grammar, and j are integers between 0 and n.",
        "The grammar rules of 0 are such that they generate only the sentence that was parsed.",
        "The parse trees according to the output grammar are isomorphic to the parse trees generated by the original grammar.",
        "The latter parse trees can be obtained from the former by replacing the triple non-terminals by their first element.",
        "Matrix elements of T are such that their members cover part of the input.",
        "This does not imply that all members are useful for constructing a possible parse of the input as a whole.",
        "In fact, many are useless for this purpose.",
        "Depending on the grammar, knowledge of part of T may give restrictions on the possibly useful contents of the rest of T. Making use of these restrictions, one may get more efficient parsers, with the same functionality.",
        "As an example, one has the generalized Earley prediction.",
        "It involves functions predicts, : -■ 2N(N is the set of non-terminals), such that one can prove that the useful contents of the Tjk are contained in the elements of a matrix e related to T by",
        "where 9., called the initial prediction, is some constant set of non-terminals that derive e. It follows that Tii can be calculated from the matrix elements Oki with i < k, 1 < j, i.e. the occurrences of T at the right hand side of the recurrence relation may be replaced by B.",
        "Hence 84, j > 0, can be calculated from the matrix elements"
      ]
    },
    {
      "heading": "V(/ Si A /31 =",
      "text": [
        "The algorithm that creates the matrix e in this way, scanning the input from left to right, is called a restricted C-parser.",
        "The above relation does not determine the diagonal elements of e uniquely, and a restricted C-parser is to find the smallest solution.",
        "Concerning the gain of efficiency, it should be noted that this is very grammar-dependent.",
        "For some grammars, restriction of the parser reduces its complexity, while for others predict functions may even be counter-productive [4]."
      ]
    },
    {
      "heading": "3 Bilinear covers",
      "text": [
        "A grammar G is said to be covered by a grammar C(G), if the language generated by both grammars is identical, and if for each sentence the set of parse trees generated by G can be recovered from the set of parse trees generated by C(G).",
        "The grammar C(G) is called a cover for G, and we will be interested in covers that are bilinear, and can thus be parsed by C-parser.",
        "It is rather surprising that at the heart of most parsing algorithms for context-free languages lies a method for deriving a bilinear cover."
      ]
    },
    {
      "heading": "3.1 Earley's method",
      "text": [
        "Earley's construction of items is a clear example of a construction of a bilinear cover CE(G) for each context-free grammar G. The terminals of CE(G) and G are identical, the non-terminals of CE(C) are the items (dotted rules[1]) IP, defined as follows.",
        "Let the non-terminal defined by rule i of grammar G be given by N,, then l is a • /3, with 101+1 k (a, # are used for sequences of terminals and non-terminals).",
        "We assume that only one rule, rule 0, of G rewrites the start symbol S. The length of the right-hand side of rule i is given by M, -1.",
        "The rules of CE(G) are derived as follows.",
        "• Let be an item of the form A a B#, and",
        "hence It\"' be A aB • #.",
        "Then if B is a terminal, /tB, and if B is non-terminal then for all j such that N, = B.",
        "• Initial items of the form Ni •a rewrite to e: E. • For each lone has the final rule .r?",
        "In [4] a similar construction was given, leading to a grammar in canonical two-form for each context-free grammar.",
        "Among other things it differs from the above in the appearance of the final rules, which axe indeed superfluous.",
        "We have introduced them to make the extension to RTN's, in section 4, more immediate.",
        "The description just given, yields a set of production rules consisting of sections Pi, that have the following structure: = U{1■-' z•:} e}U {I?",
        "where x E U, {4} U E. Note that the start symbol of the cover is 4.",
        "The construction of parse matrices T by C-parser yields the Earley algorithm, without its prediction part.",
        "By restricting the parser by the predict° function satisfying /71 E predicto(L) 3,,k((/:1-1 IN)) A E L), the initial prediction r being the smallest solution of BC = predicto(r) U WV° ,",
        "one obtains a conventional Earley parser (predictk = for k> 0).",
        "The cover is such that usually the predict action speeds up the parser considerably.",
        "There are many ways to define covers with dotted rules as non-terminals.",
        "For example, from recent work by Kruseman Aretz (6], we learn a prescription for a bilinear cover for G, which is smaller in size compared to Cs(G), at the cost of rules with longer right hand sides.",
        "The prescription is as follows (a, 8, y, it are sequences of terminals and non-terminals, b stands for sequences of terminals only, and A, B, C are non-terminals):",
        "• Let / be an item of the form A – • a • Bx, and K is an item B 7-, then J 110, where either",
        "J is item A aBb • C$ and x = 5C131, or J is item A aBb.",
        "and x =S.",
        "• Let / be an item of the form A --• Ba or A b., then I b."
      ]
    },
    {
      "heading": "3.2 Lang grammar",
      "text": [
        "In a similar fashion the items used by Lang [2] in his algorithm for non-deterministic pushdown automata (NPDA) may be interpreted as non-terminals of a bilinear grammar, which we will call the Lang grammar.",
        "We adopt restrictions on NPDA's similarly to [2], the main one being that one or two symbols be pushed on the stack in a single move, and each stack symbol is removed when it is read.",
        "If two symbols are pushed on the stack, the bottom one must be identical to the symbol that is removed in the same transition.",
        "Formally we write an NPDA as a 7-tuple (Q, E, r, 5, go, Co, F), where Q is the set of state symbols, E the input alphabet, r the pushdown symbols, 5 : Q x (r u {e}) x (E U {c}) gx({eluru(rxrp the transition function, go E Q the initial state, Co E F the start symbol, and F C Q is the set of final states.",
        "If the automaton is in state p, and a is the top of the stack, and the current symbol on the input tape is y, then it may make the following eight types of moves:",
        "We do not allow transitions such that (r, 7) E b(p,e,c), or (r, -ya) E b(p, a, e), and assume that the initial state can not be reached from other states.",
        "The non-terminals of the Lang grammar are the start symbol S and four-tuple entities (Lang's 'items') of the form < q, a, p, >, where p and q are states, and a and stack symbols.",
        "The idea is that sff there exists a computation that consumes input symbols starting at state p with a stack fitCo (the leftmost symbol is the top), and ending in state q with stack a13(0, and if the stack /3Co does not reoccur in intermediate configurations, then < g, a, p, >--** The rewrite rules of the Lang grammar are defined as follows (universal quantification over p, g,r,s E Q;a,13,7 E Is;x E EU e, is e E is understood):",
        "((r, 7) E b(p, a, z))V ((r, e) E b(p, e, x) A (a = 1)) < z,-1,P,a> – oya ((r, 7) E b(p, e, y))V ((r, 7a) E b(p, a, y)) < go, Co, go, Co >--• c (initial rule) From each NPDA one may deduce context-free grammars that generate the same language [5].",
        "The above construction yields such a grammar in bilinear form.",
        "It only works for automata, that have transitions like we use above.",
        "Lang grammars are rather big, in the rough form given above.",
        "Many of the non-terminals do not occur, however, in the derivation of any sentence.",
        "They can be removed by a standard procedure [5].",
        "In addition, during parsing, predict functions can be used to limit the number of possible contents of parse matrix elements.",
        "The following initial prediction and predict functions render the restricted C-parser functionally equivalent to Lang's original algorithm, albeit that Lang considered a class of NPDA's which is slightly different from the class we alluded to above:",
        "The Tomita parser [3] simulates an NPDA, constructed from a context-free grammar via LR-parsing tables.",
        "Within our formalism we can implement this idea, and arrive at an Earley-like version of the Tomita parser, which is able to handle general context-free grammars, including cyclic ones."
      ]
    },
    {
      "heading": "4 Extension to RTN's",
      "text": [
        "In the preceding section we discussed various ways of deriving bilinear covers.",
        "Reversely, one may try to discover what kinds of grammars are covered by certain bilinear grammars.",
        "A bilinear grammar C(G), generated from a context-free grammar by the Earley prescription, has peculiar properties.",
        "In general, the sections P, defined above constitute regular subgrammars, with the z as terminals.",
        "Alternatively, Pi may be seen as a finite state automaton with states I.",
        "Each rule 1?-1 /Ix; corresponds to a transition from If to labeled by zit.",
        "This correspondence between regular grammars and finite state",
        "automata is in fact a special instance of the correspondence between Lang bilinear grammars and NPDA's.",
        "The Pi of the above kind are very restricted finite state automata, generating only one string.",
        "It is a natural step to remove this restriction and study covers that are the union of general regular subgrammars.",
        "Such a grammar will cover a grammar, consisting of rules of the form Ni a, where a is a regular expression of terminals and non-terminals.",
        "Such grammars go under the names of RTN grammars [8], or extended context-free grammars [9], or regular right part grammars [10].",
        "Without loss of generality we may restrict the format of the finite state automata, and stipulate that it have one initial state and one final state /?, and only the following type of rules:",
        "• final rules /8 • rules If – 17z, where x 6 WM} U E, k <>0 and j <> Mi.",
        "• the initial rule e.",
        "For future reference we define define the set I of non-terminals as / = Us..{P) and its subset /° = l A covering prescription that turns an RTN into a set of such subgrammars, reduces to CE if applied to normal context-free grammars, and will be referred to by the same name, although in general the above format does not determine the cover uniquely.",
        "For some example definitions of items for RTN's (i.e. the II.",
        "), see [1,9]."
      ]
    },
    {
      "heading": "5 The CNLR Cover",
      "text": [
        "A different cover for RTN grammars may be derived from the one discussed in the previous section.",
        "So our starting point is that we have a bilinear grammar CE(G), consisting of regular subgrammars.",
        "We (approximately) follow the idea of Tomita, and construct an NPDA from an LR(0)-automaton, whose states are sets of items.",
        "In our case, the items are the non-terminals of CE(G).",
        "The full specification of the automaton is extracted from [9] in a straightforward way.",
        "Subsequently, the general prescription of chapter 3 yields a bilinear grammar.",
        "In this way we arrive at what we would like to call the canonical non-deterministic LR-parser (CNLR parser, for short)."
      ]
    },
    {
      "heading": "5.1 LR(0) states",
      "text": [
        "In order to derive the set Q of LR(0) states, which are subsets of I, we first need a few definitions.",
        "Let a be an element of 2', then closure(s) is the smallest element of 2\", such that",
        "Similarly, the sets gotoi(s, x), and got 02(3, x), where x E I° U E, are defined as",
        "The automaton we look for can be constructed in terms of the LR(0) states.",
        "In addition to the goto functions, we will need the predicate reduce, defined by reduce(s, /?)",
        "3a((1?",
        " – ■ E s).",
        "A point of interest is the possible existence of stacking conflicts[9].",
        "These arise if for some s, x both gotoi(s, x) and goto2(s, x) are not empty.",
        "Stacking conflicts cause an increase of non-determinism that can always be avoided by removing the conflicts.",
        "One method for doing this has been detailed in [9], and consists of the splitting in parts of the right hand side of grammar rules that cause conflicts.",
        "Here we need not and will not assume anything about the occurrence of stacking conflicts.",
        "Grammars, of which Earley covers do not give rise to stacking conflicts, form a proper subset of the set of extended context-free grammars.",
        "It could very well be that natural language grammars, written as RTN's in order to produce 'natural' syntax trees, generally belong to this subset.",
        "For an example, see section 6."
      ]
    },
    {
      "heading": "5.2 The automaton",
      "text": [
        "To determine the automaton we specify, in addition to the set of states Q, the set of stack symbols r QU l°u {Co}, the initial state go = closure({410}), the final states F = {slreduce(s, 18)), and the transition function 5:",
        "((t gotoi (s, Ag = c)V ((t = got02(s, -y) A q = s))} U{(7, 4)17 E Q A reduce(s, 1?))"
      ]
    },
    {
      "heading": "5.3 The grammar",
      "text": [
        "From the automaton, which is of the type discussed in section 3.2, we deduce the bilinear grammar S 3?",
        "cr, lito, Co >m reduce(s, 43) < t, r, g, # › – o< s, r, q, # y t = gotoi(s, y) < t,s,s,r y t = goto2(3, y) < t,ift,p, > – •< q, p,p, ar > < s, I?",
        ", g, > a t = gotoi(s, I?)",
        "< t, s,g, # > – •< s, I?, q, # >m_ t = goto2(s, I?)",
        "< p, I?",
        ", g, # >--o< s,p, g, # > reduce(s, I?)",
        "< qo, Co, fio, Co > – e, where s,t, q, pEQ,r EQU {Co}, a, E r, y E E. As was mentioned in section 3.2, this grammar can be reduced by a standard algorithm to contain only useful non-terminals."
      ]
    },
    {
      "heading": "5.3.1 A reduced form",
      "text": [
        "If the reduction algorithm of [5] is performed, it turns out that the structure of the above grammar is such that useful non-terminals < p, a, g, 8> satisfy aEQ=.a=q crOQ*p=q Furthermore, two non-terminals that differ only in their fourth tuple-element always derive the same strings of terminals.",
        "Hence, the fourth element can safely be discarded, as can the second if it is in Q and the first if the second is not in Q.",
        "The non-terminals then become pairs < a, s >, with a E r and s E Q.",
        "For such non-terminals, the predict functions, mentioned in section 2, must be changed:",
        "predictk(L)= l<a, $ >13, < s,q >E L} U Pik = n} The grammar gets the general form",
        "Note that the terminal < go, go > does not appear in this grammar, but will appear in the parse matrix because of the initial prediction 0`• Of course, when the automaton is fully specified for a particular language, the corresponding CNLR grammar can be reduced still further, see section 6.4."
      ]
    },
    {
      "heading": "5.3.2 Final form",
      "text": [
        "Even the grammar in reduced form contains many non-terminals that derive the same set of strings.",
        "In particular, all non-terminals that only differ in their second component generate the same language.",
        "Thus, the second component only encodes information for the predict functions.",
        "The redundancy can be removed by the following means.",
        "Define the function a : 2°, such that a(a) = {si < cr,s > is a useful non-terminal of the above grammar}.",
        "Then we may simply parse with the 'bare' grammar, the non-terminals of which are the automaton stack symbols r:",
        "using the predict functions = {go) predictk(L)= 0 if k 0 else predictk(L) = {aI3.",
        "(s E LA $ E (a))) U {Sjk = n}.",
        "The function a can also be deduced directly from the bare grammar, see section 7."
      ]
    },
    {
      "heading": "5.4 Parse trees",
      "text": [
        "Each parse tree r according to the original grammar can be obtained from a corresponding parse tree t according to the cover.",
        "Each subset of the set of nodes of t is partially ordered by the relation 'is descendant of'.",
        "Now consider the set of nodes of t that correspond to non-terminals I?.",
        "The 'is descendant of' ordering defines a projected tree that contains, apart from the terminals, only these nodes.",
        "The desired parse tree r is now obtained by replacing in the projected tree, each node I?",
        "by a node labeled by N,, the left hand side of grammar rule i of the original grammar."
      ]
    },
    {
      "heading": "6 Example",
      "text": [
        "The foregoing was rather technical and we will try to repair this by showing, very explicitly, how the formalism works for a small example grammar.",
        "In particular, we will for a small RTN grammar, derive the Earley cover of section 4, and the two covers of sections 5.3.1 and 5.3.2."
      ]
    },
    {
      "heading": "6.1 The grammar",
      "text": [
        "The following is a simple grammar for finite subordinate clauses in Dutch.",
        "So we have four regular expressions defining No = S, =VP, N2 = PP, N3 = N P ."
      ]
    },
    {
      "heading": "6.2 The Earley cover",
      "text": [
        "The above grammar is covered by four regular subgrammars:",
        "Note that the M in this case turn out as Afo = 4, MI, = 5, M2 3, M3 = 4."
      ]
    },
    {
      "heading": "6,3 The automaton",
      "text": [
        "The construction of section 5.1 yields the following set of states:",
        "The transitions are grouped into two parts.",
        "First we list the function goto2:",
        "Likewise, we have the gotos function, which gives the non-stacking transitions for our grammar:",
        "The predicate reduce holds for six pairs of states and non-terminals: reduce(qs, I8); reduce(q2o, n); reduee(qr, In; reduce(qn , 4); reduce(qa, Ig); reduce(q32, Ig)"
      ]
    },
    {
      "heading": "6.4 CNLR parser",
      "text": [
        "Given the automaton, the CNLR grammar follows according to section 5.3.",
        "After removal of the useless non-terminals we arrive at the following grammar, which is of the format of section 5.3.1.",
        "From this grammar, the function a can be deduced.",
        "It is given by",
        "Either by stripping the above cover, or by directly deducing it from the automaton, the bare cover can be obtained.",
        "We list it here for completeness.",
        "gm, q9, 4/12, Together with the predict functions defined in section 5.3.2, this grammar should provide an efficient parser for our example grammar."
      ]
    },
    {
      "heading": "7 Tadpole Grammars",
      "text": [
        "The function a has been defined, in section 5, via a grammar reduction algorithm.",
        "In this section we wish to show that an alternative method exists, and, moreover, that it can be applied to the class of bilinear tadpole grammars.",
        "This class consists of all bilinear grammars without epsilon rules, and with no useless symbols, with non-terminals (the head) preceding terminals (the tail) at the right hand side of rules.Thus, rules are of the form A a6 , where we use the symbol 6 as a variable over possibly empty sequences of terminals, and a denotes a possibly empty sequence of at most two non-terminals.",
        "Capital roman letters are used for non-terminals.",
        "Note that a CNLR cover is a member of this class of grammars, as are all grammars that are in Chomsky normal form.",
        "First we change the grammar a little bit by adding go to the set of non-terminals of the grammar, assuming that it was not there yet.",
        "Next, we create a new",
        "grammar, inspired by the grammar of 5.3.1, with pairs < A,C > as non-terminals.",
        "The rules of the new grammar are such that (with implicit universal quantification over all variables, as before)",
        "The start symbol of the new grammar, which can be seen as a parametrized version of the tadpole grammar, is defined to be < S, qo >.",
        "A non-terminal < B,C > is a useful one, whence C E a(B) according to the definition of a, if it occurs in a derivation of the parametrized grammar: S, qo oc < B,C > A, where ic is an arbitrary sequence of non-terminals, and A is a sequence of terminals and non-terminals.",
        "Then, we conclude that",
        "This definition may be rephrased without reference to the parametrized grammar.",
        "Define, for each non-terminal A a set firstnonts(A), such that firstnonts(A)= {BIA – •• BA}.",
        "The predict set 0(A) then is obtainable as o(B) = (C13.4,DAB E firstnonts(A)A"
      ]
    },
    {
      "heading": "D CA6)) U {golB E firstnonts(S)},",
      "text": [
        "where S is the start symbol.",
        "As in section 5.3.2, the initial prediction is even by 0.",
        "= {9o}."
      ]
    },
    {
      "heading": "8 An LL/LR-automaton",
      "text": [
        "In order to illustrate the amount of freedom that exists for the construction of automata and associated parsers, we shall construct a non-deterministic LL/LRautomaton and the associated cover, along the lines of section 5."
      ]
    },
    {
      "heading": "8.1 The automaton",
      "text": [
        "We change the goto functions, such that they yield sets of states rather that just one state, as follows:",
        "The set Q is changed accordingly to be the smallest one that satisfies",
        "Every state in this automaton is defined as a set closure({In) and is, as a consequence, completely characterized by the one non-terminal If.",
        "The reason for calling the above an LL/LR-automaton lies in the fact that the states of LR(0) automata for LL(1) grammars have exactly this property.",
        "The predicate reduce is defined as in section 5.1."
      ]
    },
    {
      "heading": "8.2 The LL/LR-cover",
      "text": [
        "The cover associated with the LL/LR-automaton just defined, is a simple variant of the cover of section 5.3.2:"
      ]
    },
    {
      "heading": "S s reduce(s,g)",
      "text": [
        "t '••••P sy E t E gotoi(s, y) t y 3,(t E goto2(s, y))",
        "As it is of the tadpole type, the predict mechanism works as explained in section 7.",
        "We just mentioned that each LL/LR-state, and hence each non-terminal of the LL/LR-cover, is completely characterized by one non-terminal, or 'item', of the Earley cover.",
        "This correspondence between their non-terminals leads to a tight connection between the two covers.",
        "Indeed, the cover we obtained from the LL/LRautomaton can be obtained from the cover of section 4, by eliminating the e-rules- c. Of course, the predict functions associated to both covers differ considerably, as it are the non-terminals deriving e, the items beginning with a dot, that are the object of prediction in the Earley algorithm, and they are no longer present in the LL/LR-cover."
      ]
    },
    {
      "heading": "9 Efficiency",
      "text": [
        "We have discussed a number of bilinear covers now, and we could add many more.",
        "In fact, the space of bilinear covers for each context-free grammar, or RTN grammar, is huge.",
        "The optimal one would be the one that makes C-parser spend the least time on the average sentence.",
        "In general, the least time will be more or less equivalent to the smallest content of the parse matrix.",
        "Naively, this content would be proportional to the size of the cover.",
        "Under this assumption, the smallest cover would be optimal.",
        "Note that the number of non-terminals of the CNLR cover is equal to the number of states of the LR-automaton plus the number of non-terminals of the original grammar.",
        "The size of the Earley cover is given by the number of items.",
        "In worst case situations the size of the CNLR cover is an exponential function of the size of the original grammar, whereas the size of the Earley cover clearly grows linearly with the size of the original grammar.",
        "For many grammars, however, the number of LR(0)-states, may be considerably smaller than the number of items.",
        "This seems to be the case for the natural language grammars considered by Tomita[3].",
        "His data even suggest that the number of LR(0) states is a sub-linear function of the original grammar size.",
        "Note, however, that predict functions may influence the relation between grammar size and average parse matrix content, as some grammars may allow more restrictive predict functions then others.",
        "Summarizing, it seems unlikely, that a single parsing approach would be optimal for all grammars.",
        "A viable goal of research would be to find methods for determining the optimal cover for a given grammar.",
        "Such research should have a solid experimental backbone.",
        "The matter gets still more complicated when the original grammar is an attribute grammar.",
        "Attribute evaluation may lead to the rejection of certain parse trees that are correct for the grammar without attributes.",
        "Then the ease and efficiency of on-the-fly attribute evaluation becomes important, in order to stop wrong parses as soon as possible.",
        "In the Rosetta machine translation system [11,12], we use an attributed RTN during the analysis of sentences.",
        "The attribute evaluation is bottom-up only, and designed in such a way that the grammar is covered by an attributed Earley cover.",
        "Other points concerning efficiency that we would like to discuss, are issues of precomputation.",
        "In the conventional Earley parser, the calculation of the cover is done dynamically, while parsing a sentence.",
        "However, it could just as well be done statically, i.e. before parsing, in order to increase parsing performance.",
        "For instance, set operations can be implemented more efficiently if the set elements are known non-terminals, rather than unknown items, although this would depend on the choice of programming language.",
        "The procedure of generating bilinear covers from LR-automata should always be performed statically, because of the amount of computation involved.",
        "Tomita has reported [3], that for a number of grammars, his parsing method turns out to be more efficient than the Earley Algorithm.",
        "It is not clear, whether his results would still hold if the creation of the cover for the Earley parser were being done statically.",
        "One „might be inclined to think that if use is made of precomputed sets of items, as in LR-parsers, one is bound to have a parser that is significantly different from and probably faster than Earley's algorithm, which computes these sets at parse time.",
        "The question is much more subtle as we showed in this paper.",
        "On the one hand, non-deterministic LR-parsing comes down to the use of certain covers for the grammar at hand, just like the Earley algorithm.",
        "Reversely, we showed that the Earley cover can, with minor modifications, be obtained from the LL/LR-automaton, which also uses precomputed sets of items."
      ]
    },
    {
      "heading": "10 Conclusions",
      "text": [
        "We studied parsing of general context-free languages, by splitting the process into two parts.",
        "Firstly, the grammar is turned into bilinear grammar format, and subsequently a general parser for bilinear grammars is applied.",
        "Our view on the relation between parsers and covers is similar to the work on covers of Nijholt [7] for grammars that are deterministically parsable.",
        "We established that the Lang algorithm for simulating pushdown automata, hides a prescription for deriving bilinear covers from automata that satisfy certain constraints.",
        "Reversely, the LR-parser construction technique has been presented as a way to derive automata from certain bilinear grammars.",
        "We found that the Earley algorithm is intimately related to an automaton that simulates non-deterministic LL-parsing and, furthermore, that non-deterministic LR-automata provide general parsers for context-free grammars, with the same complexity as the Earley algorithm.",
        "It should be noted, however, that there are as many parsers with this property, as there are ways to obtain bilinear covers for a given grammar."
      ]
    }
  ]
}
