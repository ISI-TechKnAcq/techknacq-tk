{
  "info": {
    "authors": [
      "Joakim Nivre"
    ],
    "book": "ACL-IJCNLP",
    "id": "acl-P09-1040",
    "title": "Non-Projective Dependency Parsing in Expected Linear Time",
    "url": "https://aclweb.org/anthology/P09-1040",
    "year": 2009
  },
  "references": [
    "acl-D07-1123",
    "acl-E06-1010",
    "acl-E06-1011",
    "acl-H05-1066",
    "acl-N07-1050",
    "acl-P05-1012",
    "acl-P05-1013",
    "acl-P06-2066",
    "acl-P07-1077",
    "acl-P08-1108",
    "acl-P97-1043",
    "acl-W04-0308",
    "acl-W04-2407",
    "acl-W05-1505",
    "acl-W06-2920",
    "acl-W06-2922",
    "acl-W06-2932",
    "acl-W06-2933",
    "acl-W07-2216",
    "acl-W07-2218"
  ],
  "sections": [
    {
      "text": [
        "We present a novel transition system for dependency parsing, which constructs arcs only between adjacent words but can parse arbitrary non-projective trees by swapping the order of words in the input.",
        "Adding the swapping operation changes the time complexity for deterministic parsing from linear to quadratic in the worst case, but empirical estimates based on treebank data show that the expected running time is in fact linear for the range of data attested in the corpora.",
        "Evaluation on data from five languages shows state-of-the-art accuracy, with especially good results for the labeled exact match score."
      ]
    },
    {
      "heading": "1. Introduction",
      "text": [
        "Syntactic parsing using dependency structures has become a standard technique in natural language processing with many different parsing models, in particular data-driven models that can be trained on syntactically annotated corpora (Yamada and Matsumoto, 2003; Nivre et al., 2004; McDonald et al., 2005a; Attardi, 2006; Titov and Henderson, 2007).",
        "A hallmark of many of these models is that they can be implemented very efficiently.",
        "Thus, transition-based parsers normally run in linear or quadratic time, using greedy deterministic search or fixed-width beam search (Nivre et al., 2004; Attardi, 2006; Johansson and Nugues, 2007; Titov and Henderson, 2007), and graph-based models support exact inference in at most cubic time, which is efficient enough to make global discriminative training practically feasible (McDonald et al., 2005a; McDonald et al., 2005b).",
        "However, one problem that still has not found a satisfactory solution in data-driven dependency parsing is the treatment of discontinuous syntactic constructions, usually modeled by non-projective dependency trees, as illustrated in Figure 1.",
        "In a projective dependency tree, the yield of every subtree is a contiguous substring of the sentence.",
        "This is not the case for the tree in Figure 1, where the subtrees rooted at node 2 (hearing) and node 4 (scheduled) both have discontinuous yields.",
        "Allowing non-projective trees generally makes parsing computationally harder.",
        "Exact inference for parsing models that allow non-projective trees is NP hard, except under very restricted independence assumptions (Neuhaus and Broker, 1997; McDonald and Pereira, 2006; McDonald and Satta, 2007).",
        "There is recent work on algorithms that can cope with important subsets of all non-projective trees in polynomial time (Kuhlmann and Satta, 2009; Gomez-Rodriguez et al., 2009), but the time complexity is at best O(n), which can be problematic in practical applications.",
        "Even the best algorithms for deterministic parsing run in quadratic time, rather than linear (Nivre, 2008a), unless restricted to a subset of non-projective structures as in Attardi (2006) and Nivre (2007).",
        "But allowing non-projective dependency trees also makes parsing empirically harder, because it requires that we model relations between non-adjacent structures over potentially unbounded distances, which often has a negative impact on parsing accuracy.",
        "On the other hand, it is hardly possible to ignore non-projective structures completely, given that 25% or more of the sentences in some languages cannot be given a linguistically adequate analysis without invoking non-projective structures (Nivre, 2006; Kuhlmann and Nivre, 2006; Havelka, 2007).",
        "Current approaches to data-driven dependency parsing typically use one of two strategies to deal with non-projective trees (unless they ignore them completely).",
        "Either they employ a non-standard parsing algorithm that can combine non-adjacent substructures (McDonald et al., 2005b; Attardi, 2006; Nivre, 2007), or they try to recover nonrooto Ai hearing2 is3 scheduled4 on5 the6 issue7 todays .9 Figure 1: Dependency tree for an English sentence (non-projective).",
        "projective dependencies by post-processing the output of a strictly projective parser (Nivre and Nilsson, 2005; Hall and Novak, 2005; McDonald and Pereira, 2006).",
        "In this paper, we will adopt a different strategy, suggested in recent work by",
        "Nivre (2008b) and Titov et al. (2009), and propose an algorithm that only combines adjacent substructures but derives non-projective trees by reordering the input words.",
        "The rest of the paper is structured as follows.",
        "In Section 2, we define the formal representations needed and introduce the framework of transition-based dependency parsing.",
        "In Section 3, we first define a minimal transition system and explain how it can be used to perform projective dependency parsing in linear time; we then extend the system with a single transition for swapping the order of words in the input and demonstrate that the extended system can be used to parse unrestricted dependency trees with a time complexity that is quadratic in the worst case but still linear in the best case.",
        "In Section 4, we present experiments indicating that the expected running time of the new system on naturally occurring data is in fact linear and that the system achieves state-of-the-art parsing accuracy.",
        "We discuss related work in Section 5 and conclude in Section 6."
      ]
    },
    {
      "heading": "2. Background Notions",
      "text": [
        "Given a set L of dependency labels, a dependency graph for a sentence x = wi,..., wn is a directed graph G = (VX, A), where 2.",
        "A C VX x L x Vx is a set of labeled arcs.",
        "The set VX of nodes is the set of positive integers up to and including n, each corresponding to the linear position of a word in the sentence, plus an extra artificial root node 0.",
        "The set A of arcs is a set of triples (i, l, j), where i and j are nodes and l is a label.",
        "For a dependency graph G = (Vx, A) to be well-formed, we in addition require that it is a tree rooted at the node 0, as illustrated in Figure 1.",
        "Following Nivre (2008a), we define a transition system for dependency parsing as a quadruple S = (C,T, cs,Ct), where"
      ]
    },
    {
      "heading": "1.. C is a set of configurations,",
      "text": [
        "2.",
        "T is a set of transitions, each of which is a (partial) function t : C – C,",
        "3. cs is an initialization function, mapping a sentence x = wi,..., wn to a configuration 4.",
        "Ct C C is a set of terminal configurations.",
        "In this paper, we take the set C of configurations to be the set of all triples c = (£, B, A) such that £ and B are disjoint sublists of the nodes Vx of some sentence x, and A is a set of dependency arcs over Vx (and some label set L); we take the initial configuration for a sentence x = wi,..., wn to be cs(x) = ([0], [1,..., n], { }); and we take the set Ct of terminal configurations to be the set of all configurations of the form c = ([0], [ ], A) (for any arc set A).",
        "The set T of transitions will be discussed in detail in Sections 3.1-3.2.",
        "We will refer to the list £ as the stack and the list B as the buffer, and we will use the variables a and // for arbitrary sublists of £ and B, respectively.",
        "For reasons of perspicuity, we will write £ with its head (top) to the right and B with its head to the left.",
        "Thus, c = ([a|i], [j|//], A) is a configuration with the node i on top of the stack £ and the node j as the first node in the buffer B.",
        "Given a transition system S = (C, T, cs, Ct), a transition sequence for a sentence x is a sequence Co,m = (c0, ci,..., cm) of configurations, such",
        "3. for every i (1 < i < m), c» = t(ci_i) for some t e T.",
        "The parse assigned to S by C0 m is the dependency graph GCm = (Vx, ACm), where ACm is the set of arcs in cm.",
        "An oracle for a transition system S is a function o : C – T. Ideally, o should always return the optimal transition t for a given configuration c, but all we require formally is that it respects the preconditions of transitions in T. That is, if o(c) = t then t is permissible in c. Given an oracle o, deterministic transition-based parsing can be achieved by the following simple algorithm:"
      ]
    },
    {
      "heading": "2. while c e C t",
      "text": []
    },
    {
      "heading": "4. return G C",
      "text": [
        "Starting in the initial configuration cs (x), the parser repeatedly calls the oracle function o for the current configuration c and updates c according to the oracle transition t. The iteration stops when a terminal configuration is reached.",
        "It is easy to see that, provided that there is at least one transition sequence in S for every sentence, the parser constructs exactly one transition sequence C0 m for a sentence x and returns the parse defined by the terminal configuration cm, i.e., = (Vx,Acto).",
        "Assuming that the calls o(c) and t(c) can both be performed in constant time, the worst-case time complexity of a deterministic parser based on a transition system S is given by an upper bound on the length of transition sequences in S.",
        "When building practical parsing systems, the oracle can be approximated by a classifier trained on treebank data, a technique that has been used successfully in a number of systems (Yamada and Matsumoto, 2003; Nivre et al., 2004; Attardi, 2006).",
        "This is also the approach we will take in the experimental evaluation in Section 4."
      ]
    },
    {
      "heading": "3. Transitions for Dependency Parsing",
      "text": [
        "Having defined the set of configurations, including initial and terminal configurations, we will now focus on the transition set T required for dependency parsing.",
        "The total set of transitions that will be considered is given in Figure 2, but we will start in Section 3.1 with the subset Tp (p for projective) consisting of the first three.",
        "In Section 3.2, we will add the fourth transition (Swap) to get the full transition set Tu (u for unrestricted).",
        "The minimal transition set Tp for projective dependency parsing contains three transitions:",
        "1.",
        "Left-Arq updates a configuration with i, j on top of the stack by adding ( j, l, i) to A and replacing i, j on the stack by j alone.",
        "it is permissible as long as i is distinct from 0.",
        "2.",
        "Right-Arq updates a configuration with i, j on top of the stack by adding (i, l, j) to A and replacing i, j on the stack by i alone.",
        "3.",
        "Shift updates a configuration with i as the first node of the buffer by removing i from the buffer and pushing it onto the stack.",
        "The system Sp = (C, Tp,cs,Ct) is sound and complete for the set of projective dependency trees (over some label set L) and has been used, in slightly different variants, by a number of transition-based dependency parsers (Yamada and",
        "A transition system S is sound for a class G of dependency graphs iff, for every sentence x and transition sequence C0 m for x in S, GCm e G. S is complete for G iff, for every sentence x and dependency graph G for x in G, there is a transition sequence C0 m for x in S such that GCm = G.",
        "Transition",
        "Condition",
        "Left-Arq",
        "(Hi,;],B,A) (M;],B,Au{(j,Z,i)»",
        "i = 0",
        "Right-Arq",
        "(Hi,;],B,A) ([<x|i],£,Au{(i,1,j)})",
        "Shift",
        "(a, [i|//],A) (Mi],//, A)",
        "Swap",
        "(Hi,; ],//,A) ([aj], [i|//],A)",
        "0 < i < j",
        "Nivre, 2008a).",
        "For proofs of soundness and completeness, see Nivre (2008a).",
        "As noted in section 2, the worst-case time complexity of a deterministic transition-based parser is given by an upper bound on the length of transition sequences.",
        "In Sp, the number of transitions for a sentence x = w1,..., wn is always exactly 2n, since a terminal configuration can only be reached after n Shift transitions (moving nodes 1,..., n from B to £) and n applications of Left-Arq or Right-Arq (removing the same nodes from £).",
        "hence, the complexity of deterministic parsing is O(n) in the worst case (as well as in the best case).",
        "we now consider what happens when we add the fourth transition from Figure 2 to get the extended transition set Tu.",
        "The Swap transition updates a configuration with stack [<r|i, j] by moving the node i back to the buffer.",
        "This has the effect that the order of the nodes i and j in the appended list £ + B is reversed compared to the original word order in the sentence.",
        "it is important to note that Swap is only permissible when the two nodes on top of the stack are in the original word order, which prevents the same two nodes from being swapped more than once, and when the leftmost node i is distinct from the root node 0.",
        "Note also that Swap moves the node i back to the buffer, so that Left-Arq, Right-Arq or Swap can subsequently apply with the node j on top of the stack.",
        "The fact that we can swap the order of nodes, implicitly representing subtrees, means that we can construct non-projective trees by applying",
        "Transition Stack (S)",
        "Buffer (B)",
        "Added Arc",
        "[root0]",
        "[Ai,..., .9]",
        "Shift",
        "[root0, Ai]",
        "[hearing2, .",
        ".",
        ".",
        ", .9]",
        "Shift",
        "[root0, A1, hearing2]",
        "[is3, .",
        ".",
        ".",
        ", .9]",
        "ladet",
        "[ROOT0, hearing2]",
        "[is3, .",
        ".",
        ".",
        ", .9]",
        "(2, DET, 1)",
        "Shift",
        "[ROOT0, hearing2, is3]",
        "[scheduled4, .",
        ".",
        ".",
        ", .9]",
        "Shift",
        "[root0, ..., is3, scheduled4]",
        "[on5,..., .9]",
        "Shift",
        "[root0, ..., scheduled4, on5]",
        "[the6, .",
        ".",
        ".",
        ", .9]",
        "Swap",
        "[ROOTo,..., is3, on5]",
        "[scheduled4, .",
        ".",
        ".",
        ", .9]",
        "Swap",
        "[ROOTo, hearing2, on5]",
        "[is3, .",
        ".",
        ".",
        ", .9]",
        "Shift",
        "[ROOTo,..., on5, is3]",
        "[scheduled4, .",
        ".",
        ".",
        ", .9]",
        "Shift",
        "[root0, ..., is3, scheduled4]",
        "[the6, .",
        ".",
        ".",
        ", .9]",
        "Shift",
        "[root0, ..., scheduled4, the6]",
        "[issue7, .",
        ".",
        ".",
        ", .9]",
        "Swap",
        "[rooTo,..., is3, thea]",
        "[scheduled4, .",
        ".",
        ".",
        ", .9]",
        "Swap",
        "[root0, ..., on5, the6]",
        "[is3, .",
        ".",
        ".",
        ", .9]",
        "Shift",
        "[rooTo,..., thea, is3]",
        "[scheduled4, .",
        ".",
        ".",
        ", .9]",
        "Shift",
        "[root0, ..., is3, scheduled4]",
        "[issue7, .",
        ".",
        ".",
        ", .9]",
        "Shift",
        "[root0, ..., scheduled4, issue7]",
        "[today8, .9]",
        "Swap",
        "[root0, ..., is3, issue7]",
        "[scheduled4, .",
        ".",
        ".",
        ", .9]",
        "Swap",
        "[root0, ..., the6, issue7]",
        "[is3, .",
        ".",
        ".",
        ", .9]",
        "ladet",
        "[ROOTo,..., on5, issue7]",
        "[is3, .",
        ".",
        ".",
        ", .9]",
        "(7, DET, 6)",
        "RApc",
        "[ROOTo, hearing2, on5]",
        "[is3, .",
        ".",
        ".",
        ", .9]",
        "(5, PC, 7)",
        "RANMOD",
        "[root0, hearing2]",
        "[is3, .",
        ".",
        ".",
        ", .9]",
        "(2, NMOD, 5)",
        "Shift",
        "[ROOTo,..., hearing2, is3]",
        "[scheduled4, .",
        ".",
        ".",
        ", .9]",
        "LAsbj",
        "[rooTo, is3]",
        "[scheduled4, .",
        ".",
        ".",
        ", .9]",
        "(3, SBJ, 2)",
        "Shift",
        "[root0 , is3, scheduled4]",
        "[today8, .9]",
        "Shift",
        "[root0, ..., scheduled4, today8]",
        "[.9]",
        "RAadv",
        "[root0 , is3, scheduled4]",
        "[.9]",
        "(4, ADV, 8)",
        "RAvg",
        "[rooTo, is3]",
        "[.9]",
        "(3, VG, 4)",
        "Shift",
        "[rooto, is3, .9]",
        "[]",
        "RAp",
        "[rooTo, is3]",
        "[]",
        "(3, P, 9)",
        "raroot",
        "[root0]",
        "[]",
        "(0, ROOT, 3)",
        "Shift otherwise",
        "Figure 4: Oracle function for Su = (C, Tu, cs, Ct) with target tree G = (VX, A).",
        "We use the notation A* to denote the subset of A that only contains the outgoing arcs of the node i.",
        "Left-Arq or Right-Arq to subtrees whose yields are not adjacent according to the original word order.",
        "This is illustrated in Figure 3, which shows the transition sequence needed to parse the example in Figure 1.",
        "For readability, we represent both the stack £ and the buffer B as lists oftokens, indexed by position, rather than abstract nodes.",
        "The last column records the arc that is added to the arc set A in a given transition (if any).",
        "Given the simplicity of the extension, it is rather remarkable that the system Su = (C, Tu, cs, Ct) is sound and complete for the set of all dependency trees (over some label set L), including all non-projective trees.",
        "The soundness part is trivial, since any terminating transition sequence will have to move all the nodes 1,..., n from B to £ (using Shift) and then remove them from £ (using Left-Arq or Right-Arq), which will produce a tree with root 0.",
        "For completeness, we note first that projectiv-ity is not a property of a dependency tree in itself, but of the tree in combination with a word order, and that a tree can always be made projective by reordering the nodes.",
        "For instance, let x be a sentence with dependency tree G = (VX, A), and let <G be the total order on VX defined by an inorder traversal of G that respects the local ordering of a node and its children given by the original word order.",
        "Regardless of whether G is projective with respect to x, it must by necessity be projective with respect to <G. We call <G the projective order corresponding to x and G and use it as our canonical way of finding a node order that makes the tree projective.",
        "By way of illustration, the projective order for the sentence and tree in Figure 1 is: A1<g hearing2 <g on5 <G thea <g issue7 <G is3<G scheduled4 <G today8 <G .9.",
        "if the words of a sentence x with dependency tree G are already in projective order, this means that G is projective with respect to x and that we can parse the sentence using only transitions in Tp, because nodes can be pushed onto the stack in projective order using only the Shift transition.",
        "If the words are not in projective order, we can use a combination of Shift and Swap transitions to ensure that nodes are still pushed onto the stack in projective order.",
        "More precisely, if the next node in the projective order is the kth node in the buffer, we perform k Shift transitions, to get this node onto the stack, followed by k – 1 Swap transitions, to move the preceding k – 1 nodes back to the buffer.",
        "In this way, the parser can effectively sort the input nodes into projective order on the stack, repeatedly extracting the minimal element of <Gfrom the buffer, and build a tree that is projective with respect to the sorted order.",
        "Since any input can be sorted using Shift and Swap, and any projective tree can be built using Shift, Left-Arq and Right-Arq, the system Su is complete for the set of all dependency trees.",
        "In Figure 4, we define an oracle function o for the system Su, which implements this \"sort and parse\" strategy and predicts the optimal transition t out of the current configuration c, given the target dependency tree G = (VX,A) and the projective order <G. The oracle predicts Left-Arq or Right Arq if the two top nodes on the stack should be connected by an arc and if the dependent node of this arc is already connected to all its dependents; it predicts Swap if the two top nodes are not in projective order; and it predicts Shift otherwise.",
        "This is the oracle that has been used to generate training data for classifiers in the experimental evaluation in Section 4.",
        "Let us now consider the time complexity of the extended system Su = (C, Tu, cs, Ct) and let us begin by observing that 2n is still a lower bound on the number of transitions required to reach a terminal configuration.",
        "A sequence of 2n transi-",
        "Figure 5: Abstract running time during training (black) and parsing (white) for Arabic (1460/146 sentences) and Danish (5190/322 sentences).",
        "tions occurs when no Swap transitions are performed, in which case the behavior of the system is identical to the simpler system Sp.",
        "This is important, because it means that the best-case complexity of the deterministic parser is still O(n) and that the we can expect to observe the best case for all sentences with projective dependency trees.",
        "The exact number of additional transitions needed to reach a terminal configuration is determined by the number of Swap transitions.",
        "Since Swap moves one node from £ to B, there will be one additional Shift for every Swap, which means that the total number of transitions is 2n + 2k, where k is the number of Swap transitions.",
        "Given the condition that Swap can only apply in a configuration c = ([<r|i, j], B, A) if 0 < i < j, the number of Swap transitions is bounded by n(n2~1), which means that 2n + n(n – 1) = n + n is an upper bound on the number of transitions in a terminating sequence.",
        "Hence, the worst-case complexity of the deterministic parser is O(n).",
        "The running time of a deterministic transition-based parser using the system Su is O(n) in the best case and O(n) in the worst case.",
        "But what about the average case?",
        "Empirical studies, based on data from a wide range of languages, have shown that dependency trees tend to be projective and that most non-projective trees only contain a small number of discontinuities (Nivre, 2006; Kuhlmann and Nivre, 2006; Havelka, 2007).",
        "This should mean that the expected number of swaps per sentence is small, and that the running time is linear on average for the range of inputs that occur in natural languages.",
        "This is a hypothesis that will be tested experimentally in the next section.",
        "4 Experiments",
        "Our experiments are based on five data sets from the CoNLL-X shared task: Arabic, Czech, Danish, Slovene, and Turkish (Buchholz and Marsi, 2006).",
        "These languages have been selected because the data come from genuine dependency treebanks, whereas all the other data sets are based on some kind of conversion from another type of representation, which could potentially distort the distribution of different types of structures in the data.",
        "In section 3.2, we hypothesized that the expected running time of a deterministic parser using the transition system Su would be linear, rather than quadratic.",
        "To test this hypothesis, we examine how the number of transitions varies as a function of sentence length.",
        "We call this the abstract running time, since it abstracts over the actual time needed to compute each oracle prediction and transition, which is normally constant but dependent on the type of classifier used.",
        "We first measured the abstract running time on the training sets, using the oracle to derive the transition sequence for every sentence, to see how many transitions are required in the ideal case.",
        "We then performed the same measurement on the test sets, using classifiers trained on the oracle transition sequences from the training sets (as described below in Section 4.2), to see whether the trained parsers deviate from the ideal case.",
        "The result for Arabic and Danish can be seen",
        "Table 1: Labeled accuracy; AS = attachment score (non-projective arcs in brackets); EM = exact match.",
        "in Figure 5, where black dots represent training sentences (parsed with the oracle) and white dots represent test sentences (parsed with a classifier).",
        "For Arabic there is a very clear linear relationship in both cases with very few outliers.",
        "Fitting the data with a linear function using the least squares method gives us m = 2.06n (R = 0.97) for the training data and m = 2.02n (R = 0.98) for the test data, where m is the number of transitions in parsing a sentence of length n. For Danish, there is clearly more variation, especially for the training data, but the least-squares approximation still explains most of the variance, with m = 2.22n (R = 0.85) for the training data and m = 2.07n (R = 0.96) for the test data.",
        "For both languages, we thus see that the classifier-based parsers have a lower mean number of transitions and less variance than the oracle parsers.",
        "And in both cases, the expected number of transitions is only marginally greater than the 2n of the strictly projective transition system Sp.",
        "We have chosen to display results for Arabic and Danish because they are the two extremes in our sample.",
        "Arabic has the smallest variance and the smallest linear coefficients, and Danish has the largest variance and the largest coefficients.",
        "The remaining three languages all lie somewhere in the middle, with Czech being closer to Arabic and Slovene closer to Danish.",
        "Together, the evidence from all five languages strongly corroborates the hypothesis that the expected running time for the system Su is linear in sentence length for naturally occurring data.",
        "in order to assess the parsing accuracy that can be achieved with the new transition system, we trained a deterministic parser using the new transition system Su for each of the five languages.",
        "For comparison, we also trained two parsers using",
        "Sp, one that is strictly projective and one that uses the pseudo-projective parsing technique to recover non-projective dependencies in a post-processing step (Nivre and Nilsson, 2005).",
        "We will refer to the latter system as Spp.",
        "All systems use SVM classifiers with a polynomial kernel to approximate the oracle function, with features and parameters taken from Nivre et al.",
        "(2006), which was the best performing transition-based system in the CoNLL-X shared task.",
        "Table 1 shows the labeled parsing accuracy of the parsers measured in two ways: attachment score (AS) is the percentage of tokens with the correct head and dependency label; exact match (EM) is the percentage of sentences with a completely correct labeled dependency tree.",
        "The score in brackets is the attachment score for the (small) subset of tokens that are connected to their head by a non-projective arc in the gold standard parse.",
        "For comparison, the table also includes results for the two best performing systems in the original CoNLL-X shared task, Malt-06 (Nivre et al., 2006) and MST-06 (McDonald et al., 2006), as well as the integrated system MSTMalt, which is a graph-based parser guided by the predictions of a transition-based parser and currently has the best reported results on the CoNLL-X data sets (Nivre and McDonald, 2008).",
        "Looking first at the overall attachment score, we see that Su gives a substantial improvement over Sp (and outperforms Spp) for Czech and Slovene, where the scores achieved are rivaled only by the combo system MSTMalt.",
        "For these languages, there is no statistical difference between Su and MSTMalt, which are both significantly better than all the other parsers, except Spp for Czech (McNemar's test, a = .05).",
        "This is accompanied by an improvement on non-projective arcs, where",
        "Arabic",
        "Czech",
        "Danish",
        "Slovene",
        "Turkish",
        "System",
        "AS",
        "EM",
        "AS",
        "EM",
        "AS",
        "EM",
        "AS",
        "EM",
        "AS",
        "EM",
        "67.1 (9.1)",
        "11.6",
        "82.4 (73.8)",
        "35.3",
        "84.2 (22.5)",
        "26.7",
        "75.2 (23.0)",
        "29.9",
        "64.9 (11.8)",
        "21.5",
        "Sp",
        "67.3 (18.2)",
        "11.6",
        "80.9 (3.7)",
        "31.2",
        "84.6 (0.0)",
        "27.0",
        "74.2 (3.4)",
        "29.9",
        "65.3 (6.6)",
        "21.0",
        "67.2 (18.2)",
        "11.6",
        "82.1 (60.7)",
        "34.0",
        "84.7 (22.5)",
        "28.9",
        "74.8 (20.7)",
        "26.9",
        "65.5 (11.8)",
        "20.7",
        "Malt-06",
        "66.7 (18.2)",
        "11.0",
        "78.4 (57.9)",
        "27.4",
        "84.8 (27.5)",
        "26.7",
        "70.3 (20.7)",
        "19.7",
        "65.7 (9.2)",
        "19.3",
        "MST-06",
        "66.9 (0.0)",
        "10.3",
        "80.2 (61.7)",
        "29.9",
        "84.8 (62.5)",
        "25.5",
        "73.4 (26.4)",
        "20.9",
        "63.2 (11.8)",
        "20.2",
        "MSTMalt",
        "68.6 (9.4)",
        "11.0",
        "82.3 (69.2)",
        "31.2",
        "86.7 (60.0)",
        "29.8",
        "75.9 (27.6)",
        "26.6",
        "66.3 (9.2)",
        "18.6",
        "Su outperforms all other systems for Czech and is second only to the two MST parsers (MST-06 and MSTMalt) for Slovene.",
        "It is worth noting that the percentage of non-projective arcs is higher for Czech (1.9%) and Slovene (1.9%) than for any of the other languages.",
        "For the other three languages, Su has a drop in overall attachment score compared to Sp, but none of these differences is statistically significant.",
        "In fact, the only significant differences in attachment score here are the positive differences between MSTMalt and all other systems for Arabic and Danish, and the negative difference between MST-06 and all other systems for Turkish.",
        "The attachment scores for non-projective arcs are generally very low for these languages, except for the two MST parsers on Danish, but Su performs at least as well as Spp on Danish and Turkish.",
        "(The results for Arabic are not very meaningful, given that there are only eleven non-projective arcs in the entire test set, of which the (pseudo-)projective parsers found two and Su one, while MSTMalt and MST-06 found none at all.)",
        "Considering the exact match scores, finally, it is very interesting to see that Su almost consistently outperforms all other parsers, including the combo system MSTMalt, and sometimes by a fairly wide margin (Czech, Slovene).",
        "The difference is statistically significant with respect to all other systems except MSTMalt for Slovene, all except MSTMaltand Spp for Czech, and with respect to MSTMaltfor Turkish.",
        "For Arabic and Danish, there are no significant differences in the exact match scores.",
        "We conclude that Su may increase the probability of finding a completely correct analysis, which is sometimes reflected also in the overall attachment score, and we conjecture that the strength of the positive effect is dependent on the frequency of non-projective arcs in the language."
      ]
    },
    {
      "heading": "5. Related Work",
      "text": [
        "Processing non-projective trees by swapping the order of words has recently been proposed by both Nivre (2008b) and Titov et al.",
        "(2009), but these systems cannot handle unrestricted non-projective trees.",
        "it is worth pointing out that, although the system described in Nivre (2008b) uses four transitions bearing the same names as the transitions of Su, the two systems are not equivalent.",
        "in particular, the system of Nivre (2008b) is sound but not complete for the class of all dependency trees.",
        "There are also affinities to the system of Attardi (2006) , which combines non-adjacent nodes on the stack instead of swapping nodes and is equivalent to a restricted version of our system, where no more than two consecutive Swap transitions are permitted.",
        "This restriction preserves linear worst-case complexity at the expense of completeness.",
        "Finally, the algorithm first described by Covington (2001) and used for data-driven parsing by Nivre (2007) , is complete but has quadratic complexity even in the best case."
      ]
    },
    {
      "heading": "6. Conclusion",
      "text": [
        "We have presented a novel transition system for dependency parsing that can handle unrestricted non-projective trees.",
        "The system reuses standard techniques for building projective trees by combining adjacent nodes (representing subtrees with adjacent yields), but adds a simple mechanism for swapping the order of nodes on the stack, which gives a system that is sound and complete for the set of all dependency trees over a given label set but behaves exactly like the standard system for the subset of projective trees.",
        "As a result, the time complexity of deterministic parsing is O(n) in the worst case, which is rare, but O(n) in the best case, which is common, and experimental results on data from five languages support the conclusion that expected running time is linear in the length of the sentence.",
        "Experimental results also show that parsing accuracy is competitive, especially for languages like Czech and Slovene where non-projective dependency structures are common, and especially with respect to the exact match score, where it has the best reported results for four out of five languages.",
        "Finally, the simplicity of the system makes it very easy to implement.",
        "Future research will include an in-depth error analysis to find out why the system works better for some languages than others and why the exact match score improves even when the attachment score goes down.",
        "in addition, we want to explore alternative oracle functions, which try to minimize the number of swaps by allowing the stack to be temporarily \"unsorted\"."
      ]
    },
    {
      "heading": "Acknowledgments",
      "text": [
        "Thanks to Johan Hall and Jens Nilsson for help with implementation and evaluation, and to Marco Kuhlmann and three anonymous reviewers for useful comments."
      ]
    }
  ]
}
