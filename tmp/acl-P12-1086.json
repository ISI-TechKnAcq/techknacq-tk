{
  "info": {
    "authors": [
      "Alexandre Davis",
      "Adriano Veloso",
      "Altigran Soares",
      "Alberto Laender",
      "Wagner Meira Jr."
    ],
    "book": "ACL",
    "id": "acl-P12-1086",
    "title": "Named Entity Disambiguation in Streaming Data",
    "url": "https://aclweb.org/anthology/P12-1086",
    "year": 2012
  },
  "references": [
    "acl-C98-1012",
    "acl-D07-1074",
    "acl-D11-1072",
    "acl-E06-1002",
    "acl-P04-1053",
    "acl-P11-1037"
  ],
  "sections": [
    {
      "heading": "Abstract",
      "text": [
        "The named entity disambiguation task is to resolve the many-to-many correspondence between ambiguous names and the unique real-world entity.",
        "This task can be modeled as a classification problem, provided that positive and negative examples are available for learning binary classifiers.",
        "High-quality sense-annotated data, however, are hard to be obtained in streaming environments, since the training corpus would have to be constantly updated in order to accomodate the fresh data coming on the stream.",
        "On the other hand, few positive examples plus large amounts of un-labeled data may be easily acquired.",
        "Producing binary classifiers directly from this data, however, leads to poor disambiguation performance.",
        "Thus, we propose to enhance the quality of the classifiers using finer-grained variations of the well-known Expectation-Maximization (EM) algorithm.",
        "We conducted a systematic evaluation using Twitter streaming data and the results show that our classifiers are extremely effective, providing improvements ranging from 1% to 20%, when compared to the current state-of-the-art biased SVMs, being more than 120 times faster."
      ]
    },
    {
      "heading": "1 Introduction",
      "text": [
        "Human language is not exact.",
        "For instance, an entity1 may be referred by multiple names (i.e., poly-semy), and also the same name may refer to different entities depending on the surrounding context (i.e.,",
        "homonymy).",
        "The task of named entity disambiguation is to identify which names refer to the same entity in a textual collection (Sarmento et al., 2009; Yosef et al., 2011; Hoffart et al., 2011).",
        "The emergence of new communication technologies, such as micro-blog platforms, brought a humongous amount of textual mentions with ambiguous entity names, raising an urgent need for novel disambiguation approaches and algorithms.",
        "In this paper we address the named entity disambiguation task under a particularly challenging scenario.",
        "We are given a stream of messages from a micro-blog channel such as Twitter2 and a list of names n1, n2, .",
        ".",
        ".",
        ", nN used for mentioning a specific entity e. Our problem is to monitor the stream and predict whether an incoming message containing ni indeed refers to e (positive example) or not (negative example).",
        "This scenario brings challenges that must be overcome.",
        "First, micro-blog messages are composed of a small amount of words and they are written in informal, sometimes cryptic style.",
        "These characteristics make hard the identification of entities and the semantics of their relationships (Liu et al., 2011).",
        "Further, the scarcity of text in the messages makes it even harder to properly characterize a common context for the entities.",
        "Second, as we need to monitor messages that keep coming at a fast pace, we cannot afford to gather information from external sources on-the-fly.",
        "Finally, fresh data coming in the stream introduces new patterns, quickly invalidating static disambiguation models.",
        "We hypothesize that the lack of information in each individual message and from external sources can be compensated by using information obtained from the large and diverse amount of text in a stream of messages taken as a whole, that is, thousands of messages per second coming from distinct sources.",
        "The information embedded in such a stream of messages may be exploited for entity disambiguation through the application of supervised learning methods, for instance, with the application of binary classifiers.",
        "Such methods, however, suffer from a data acquisition bottleneck, since they are based on training datasets that are built by skilled human annotators who manually inspect the messages.",
        "This annotation process is usually lengthy and laborious, being clearly unfeasible to be adopted in data streaming scenarios.",
        "As an alternative to such manual process, a large amount of unlabeled data, augmented with a small amount of (likely) positive examples, can be collected automatically from the message stream (Liu et al., 2003; Denis, 1998; Comite?",
        "et al, 1999; Letouzey et al., 2000).",
        "Binary classifiers may be learned from such data by considering unlabeled data as negative examples.",
        "This strategy, however, leads to classifiers with poor disambiguation performance, due to a potentially large number of false-negative examples.",
        "In this paper we propose to refine binary classifiers iteratively, by performing Expectation-Maximization (EM) approaches (Dempster et al., 1977).",
        "Basically, a partial classifier is used to evaluate the likelihood of an unlabeled example being a positive example or a negative example, thus automatically and (continuously) creating a labeled training corpus.",
        "This process continues iteratively by changing the label of some examples (an operation we call label-transition), so that, after some iterations, the combination of labels is expected to converge to the one for which the observed data is most likely.",
        "Based on such an approach, we introduce novel disambiguation algorithms that differ among themselves on the granularity in which the classifier is updated, and on the label-transition operations that are allowed.",
        "An important feature of the proposed approach is that, at each iteration of the EM-process, a new classifier (an improved one) is produced in order to account for the current set of labeled examples.",
        "We introduce a novel strategy to maintain the classifiers up-to-date incrementally after each iteration, or even after each label-transition operation.",
        "Indeed, we theoretically show that our classifier needs to be updated just partially and we are able to determine exactly which parts must be updated, making our disambiguation methods extremely fast.",
        "To evaluate the effectiveness of the proposed algorithms, we performed a systematic set of experiments using large-scale Twitter data containing messages with ambiguous entity names.",
        "In order to validate our claims, disambiguation performance is investigated by varying the proportion of false-negative examples in the unlabeled dataset.",
        "Our algorithms are compared against a state-of-the-art technique for named entity disambiguation based on classifiers, providing performance gains ranging from 1% to 20% and being roughly 120 times faster."
      ]
    },
    {
      "heading": "2 Related Work",
      "text": [
        "In the context of databases, traditional entity disambiguation methods rely on similarity functions over attributes associated to the entities (de Car-valho et al., 2012).",
        "Obviously, such an approach is unfeasible for the scenario we consider here.",
        "Still on databases, Bhattacharya and Getoor (2007) and Dong et.",
        "al (2005) propose graph-based disambiguation methods that generate clusters of co-referent entities using known relationships between entities of several types.",
        "Methods to disambiguate person names in email (Minkov et al., 2006) and Web pages (Bekkerman and McCallum, 2005; Wan et al., 2005) have employed similar ideas.",
        "In emails, information taken from the header of the messages leads to establish relationships between users and building a co-reference graph.",
        "In Web pages, reference information come naturally from links.",
        "Such graph-based approach could hardly be applied to the context we consider, in which the implied relationships between entities mentioned in a given micro-blog message are not clearly defined.",
        "In the case of textual corpora, traditional disambiguation methods represent entity names and their context (Hasegawa et al., 2004) (i.e., words, phrases and other names occurring near them) as weighted vectors (Bagga and Baldwin, 1998; Pedersen et al., 2005).",
        "To evaluate whether two names refer to the same entity, these methods compute the similar",
        "ity between these vectors.",
        "Clusters of co-referent names are then built based on such similarity measure.",
        "Although effective for the tasks considered in these papers, the simplistic BOW-based approaches they adopt are not suitable for cases in which the context is harder to capture due to the small number of terms available or to informal writing style.",
        "To address these problems, some authors argue that contextual information may be enriched with knowledge from external sources, such as search results and the Wikipedia (Cucerzan, 2007; Bunescu and Pa≈üca, 2006; Han and Zhao, 2009).",
        "While such a strategy is feasible in an off-line setting, two problems arise when monitoring streams of micro-blog messages.",
        "First, gathering information from external sources through the Internet can be costly and, second, informal mentions to named entities make it hard to look for related information in such sources.",
        "The disambiguation methods we propose fall into a learning scenario known as PU (positive and unlabeled) learning (Liu et al., 2003; Denis, 1998; Comite?",
        "et al, 1999; Letouzey et al., 2000), in which a classifier is built from a set of positive examples plus unlabeled data.",
        "Most of the approaches for PU learning, such as the biased-SVM approach (Li and Liu, 2003), are based on extracting negative examples from unlabeled data.",
        "We notice that existing approaches for PU learning are not likely to scale given the restrictions imposed by streaming data.",
        "Thus, we propose highly incremental approaches, which are able to process large-scale streaming data."
      ]
    },
    {
      "heading": "3 Disambiguation in Streaming Data",
      "text": [
        "Consider a stream of messages from a micro-blog channel such as Twitter and let n1, n2, .",
        ".",
        ".",
        ", nN be names used for mentioning a specific entity e in these messages.",
        "Our problem is to continually monitor the stream and predict whether an incoming message containing ni indeed refers to e or not.",
        "This task may be accomplished through the application of classification techniques.",
        "In this case, we are given an input data set called the training corpus (denoted as D) which consists of examples of the form <e,m, c>, where e is the entity, m is a message containing the entity name (i.e., any ni), and c ?",
        "{,} is a binary variable that specifies whether or not the entity name in m refers to the desired real-world entity e. The training corpus is used to produce a classifier that relates textual patterns (i.e., terms and sets of terms) in m to the value of c. The test set (denoted as T ) consists of a set of records of the form <e,m, ?>, and the classifier is used to indicate which messages in T refer to (or not) the desired entity.",
        "Supervised classifiers, however, are subject to a data acquisition bottleneck, since the creation of a training corpus requires skilled human annotators to manually inspect the messages.",
        "The cost associated with this annotation process may render vast amounts of examples unfeasible.",
        "In many cases, however, the acquisition of some positive examples is relatively inexpensive.",
        "For instance, as we are dealing with messages collected from micro-blog channels, we may exploit profiles (or hashtags) that are known to be strongly associated with the desired entity.",
        "Let us consider, as an illustrative example, the profile associated with a company (i.e., @bayer).",
        "Although the entity name is ambiguous, the sense of messages that are posted in this profile is biased towards the entity as being a company.",
        "Clearly, other tricks like this one can be used, but, unfortunately, they do not guarantee the absence of false-positives, and they are not complete since the majority of messages mentioning the entity name may appear outside its profile.",
        "Thus, the collected examples are not totally reliable, and disambiguation performance would be seriously compromised if classifiers were built upon these uncertain examples directly."
      ]
    },
    {
      "heading": "3.1 Expectation-Maximization Approach",
      "text": [
        "In this paper we hypothesize that it is worthwhile to enhance the reliability of unlabeled examples, provided that this type of data is inexpensive and the enhancement effort will be then rewarded with an improvement in disambiguation performance.",
        "Thus, we propose a new approach based on the Expectation-Maximization (EM) algorithm (Demp-ster et al., 1977).",
        "We assume two scenarios: ?",
        "the training corpusD is composed of a small set of truly positive examples plus a large amount of unlabeled examples.",
        "?",
        "the training corpus D is composed of a small set of potentially positive examples plus a large amount of unlabeled examples.",
        "In both scenarios, unlabeled examples are initially treated as negative ones, so that classifiers can be built from D. Therefore, in both scenarios, D may contain false-negatives.",
        "In the second scenario, however, D may also contain false-positives.",
        "Definition 3.1: The label-transition operation x?",
        "turns a negative example x ?",
        "D into a positive one x.",
        "The training corpus D becomes {(D ?",
        "x) ?",
        "x}.",
        "Similarly, the label-transition operation x?, turns a positive example x ?",
        "D into a negative one x.",
        "The training corpus D becomes {(D ?",
        "x) ?",
        "x}.",
        "Our Expectation Maximization (EM) methods employ a classifier which assigns to each example x ?",
        "D a probability ?",
        "(x,) of being negative.",
        "Then, as illustrated in Algorithm 1, label-transition operations are performed, so that, in the end of the process, it is expected that the assigned labels converge to the combination for which the data is most likely.",
        "In the first scenario only operations x?",
        "are allowed, while in the second scenario operations x?",
        "are also allowed.",
        "In both cases, a crucial issue that affects the effectiveness of our EM-based methods concerns the decision of whether or not performing the label-transition operation.",
        "Typically, a transition threshold ?min is employed, so that a label-transition operation x?",
        "is always performed if x is a negative example and ?",
        "(x,) ?",
        "?min.",
        "Similarly, operation x?",
        "is always performed if x is a positive example and ?",
        "(x,) > ?min.",
        "Algorithm 1 Expectation-Maximization Approach.",
        "Given: D: training corpus R: a binary classifier learned from D Expectation step: perform transition operations on examples in D Maximization step: update R and ?",
        "(x,) ?x ?",
        "D The optimal value for ?min is not known in advance.",
        "Fortunately, data distribution may provide hints about proper values for ?min.",
        "In our approach, instead of using a single value for ?min, which would be applied to all examples indistinctly, we use a specific ?xmin threshold for each example x ?",
        "D. Based on such an approach, we introduce fine-grained EM-based methods for named entity disambiguation under streaming data.",
        "A specific challenge is that the proposed methods perform several transition operations during each EM iteration, and each transition operation may invalidate parts of the current classifier, which must be properly updated.",
        "We take into consideration two possible update granularities: ?",
        "the classifier is updated after each EM iteration.",
        "?",
        "the classifier is updated after each label-transition operation.",
        "Incremental Classifier: As already discussed, the classifier must be constantly updated during the EM process.",
        "In this case, well-established classifiers, such as SVMs (Joachims, 2006), have to be learned entirely from scratch, replicating work by large.",
        "Thus, we propose as an alternative the use of Lazy Associative Classifiers (Veloso et al., 2006).",
        "Definition 3.2: A classification rule is a specialized association rule {X ??",
        "c} (Agrawal et al., 1993), where the antecedent X is a set of terms (i.e., a termset), and the consequent c indicates if the prediction is positive or negative (i.e., c ?",
        "{,}).",
        "The domain for X is the vocabulary of D. The cardinality of rule {X ?",
        "c} is given by the number of terms in the antecedent, that is |X |.",
        "The support of X is denoted as ?",
        "(X ), and is the number of examples in D having X as a subset.",
        "The confidence of rule {X ?",
        "c} is denoted as ?",
        "(X ??",
        "c), and is the conditional probability of c given the termsetX , that is, ?",
        "(X ??",
        "c) = ?(X?c)?",
        "(X ) .",
        "In this context, a classifier is denoted as R, and it is composed of a set of rules {X ??",
        "c} extracted from D. Specifically, R is represented as a pool of entries with the form <key, properties>, where key={X , c} and properties={?",
        "(X ), ?",
        "(X ?",
        "c), ?",
        "(X ?",
        "c)}.",
        "Each entry in the pool corresponds to a rule, and the key is used to facilitate fast access to rule properties.",
        "Once the classifier R is extracted from D, rules are collectively used to approximate the likelihood of an arbitrary example being positive () or negative ().",
        "Basically, R is interpreted as a poll, in which each rule {X ?",
        "c} ?",
        "R is a vote given by X for or .",
        "Given an example x, a rule {X ?",
        "c} is only considered a valid vote if it is applicable to x.",
        "Definition 3.3: A rule {X ?",
        "c} ?",
        "R is said to be applicable to example x ifX ?",
        "x, that is, if all terms in X are present in example x.",
        "We denote as Rx the set of rules in R that are applicable to example x.",
        "Thus, only and all the rules in Rx are considered as valid votes when classifying x.",
        "Further, we denote as Rcx the subset of Rx containing only rules predicting c. Votes in Rcx have different weights, depending on the confidence of the corresponding rules.",
        "Weighted votes for c are averaged, giving the score for c with regard to x (Equation 1).",
        "Finally, the likelihood of x being a negative example is given by the normalized score (Equation 2)."
      ]
    },
    {
      "heading": "Training Projection and Demand-Driven Rule",
      "text": [
        "Extraction: Demand-driven rule extraction (Veloso et al., 2006) is a recent strategy used to avoid the huge search space for rules, by projecting the training corpus according to the example being processed.",
        "More specifically, rule extraction is delayed until an example x is given for classification.",
        "Then, terms in x are used as a filter that configures the training corpus D so that just rules that are applicable to x can be extracted.",
        "This filtering process produces a projected training corpus, denoted asDx, which contains only terms that are present in x.",
        "As shown in (Silva et al., 2011), the number of rules extracted using this strategy grows polynomially with the size of the vocabulary.",
        "Extending the Classifier Dynamically: With demand-driven rule extraction, the classifierR is extended dynamically as examples are given for classification.",
        "Initially R is empty; a subset Rxi is appended to R every time an example xi is processed.",
        "Thus, after processing a sequence of m examples {x1, x2, .",
        ".",
        ".",
        ", xm}, R = {Rx1 ?Rx2 ?",
        ".",
        ".",
        ".",
        "?Rxm}.",
        "Before extracting rule {X ?",
        "c}, it is checked whether this rule is already in R. In this case, while processing an example x, if an entry is found with a key matching {X , c}, then the rule in R is used instead of extracting it from Dx.",
        "Otherwise, the rule is extracted from Dx and then it is inserted into R. Incremental Updates: Entries in R may become invalid when D is modified due to a label-transition operation.",
        "Given thatD has been modified, the classifier R must be updated properly.",
        "We propose to maintain R up-to-date incrementally, so that the updated classifier is exactly the same one that would be obtained by reconstructing it from scratch.",
        "Lemma 3.1: Operation x?",
        "(or x?)",
        "does not change the value of ?",
        "(X ), for any termset X .",
        "Proof: The operation x?",
        "changes only the label associated with x, but not its terms.",
        "Thus, the number of examples in D having X as a subset is essentially the same as in {(D ?",
        "x) ?",
        "x.",
        "The same holds for operation x?.",
        "Lemma 3.2: Operation x?",
        "(or x?)",
        "changes the value of ?",
        "(X ?",
        "c) iff termset X ?",
        "x.",
        "Proof: For operation x?, if X ?",
        "x, then {X ? }",
        "appears once less in {(D ?",
        "x) ?",
        "x} than in D. Similarly, {X ?}",
        "appears once more in {(D?",
        "x)?x} than inD.",
        "Clearly, if X 6?",
        "x, the number of times {X ?}",
        "(and {X ?})",
        "appears in {(D ?",
        "x)?x} remains the same as inD.",
        "The same holds for operation x?.",
        "Lemma 3.3: Operation x?",
        "(or x?)",
        "changes the value of ?",
        "(X ?",
        "c) iff termset X ?",
        "x.",
        "Proof: Comes directly from Lemmas 3.1 and 3.2.",
        "From Lemmas 3.1 to 3.3, the number of rules that have to be updated due to a label-transition operation is bounded by the number of possible termsets in x.",
        "The following theorem states exactly the rules in R that have to be updated due to a transition operation.",
        "Theorem 3.4: All rules in R that must be updated due to x?",
        "(or x?)",
        "are those in Rx.",
        "Proof: From Lemma 3.3, all rules {X ??",
        "c} ?",
        "R that have to be updated due to operation x?",
        "(or x?)",
        "are those for which X ?",
        "x.",
        "By definition, Rx contains only and all such rules.",
        "Updating ?",
        "(X ? )",
        "and ?",
        "(X ? )",
        "is straightforward.",
        "For operation x?, it suffices to iterate on Rx, incrementing ?",
        "(X ? )",
        "and decrementing ?",
        "(X ?",
        ").",
        "Similarly, for operation x?, it suffices to iterate on Rx, incrementing ?",
        "(X ? )",
        "and decrementing ?",
        "(X ?",
        ").",
        "The corresponding values"
      ]
    },
    {
      "heading": "3.2 Best Entropy Cut Method",
      "text": [
        "In this section we propose a method for finding the activation threshold, ?xmin, which is a fundamental step of our Expectation-Maximization approach.",
        "Definition 3.4: Let cy ?",
        "{,} be the label associated with an example y ?",
        "Dx.",
        "Consider N(Dx) the number of examples inDx for which cy=.",
        "Similarly, consider N(Dx) the number of examples in Dx for which cy=.",
        "Entropy Minimization: Our method searches for a threshold ?xmin that provides the best entropy cut in the probability space induced by Dx.",
        "Specifically, given examples {y1, y2, .",
        ".",
        ".",
        ", yk} in Dx, our method first calculates ?",
        "(yi,) for all yi ?",
        "Dx.",
        "Then, the values for ?",
        "(yi,) are sorted in ascending order.",
        "In an ideal case, there is a cut ?xmin such that:",
        "However, there are more difficult cases, for which it is not possible to obtain a perfect separation in the probability space.",
        "Thus, we propose a more general method to find the best cut in the probability space.",
        "The basic idea is that any value for ?xmin induces two partitions over the space of values for ?",
        "(yi,) (i.e., one partition with values that are lower than ?xmin, and another partition with values that are higher than ?xmin).",
        "Our method sets ?xmin to the value that minimizes the average entropy of these two partitions.",
        "Once ?xmin is calculated, it can be used to activate a label-transition operation.",
        "Next we present the basic definitions in order to detail this method.",
        "Definition 3.5: Consider a list of pairs O = {.",
        ".",
        ".",
        ", <cyi , ?",
        "(yi,)>, <cyj , ?",
        "(yj ,)>, .",
        ".",
        ".",
        "}, such that ?",
        "(yi,) ?",
        "?",
        "(yj ,).",
        "Also, consider f a candidate value for ?xmin.",
        "In this case,Of (?)",
        "is a sub-list of O, that is, Of (?)={.",
        ".",
        "., <cy, ?",
        "(yi,)>, .",
        ".",
        ".",
        "}, such that for all pairs in Of (?",
        "), ?",
        "(y,) ?",
        "f .",
        "Similarly, Of (>)={.",
        ".",
        "., <cy, ?",
        "(y,)>, .",
        ".",
        ".",
        "}, such that for all pairs inOf (>), ?",
        "(y,) > f .",
        "In other words, Of (?)",
        "andOf (>) are partitions ofO induced by f .",
        "Our method works as follows.",
        "Firstly, it calculates the entropy in O, as shown in Equation 3.",
        "Then, it calculates the sum of the entropies in each partition induced by f , according to Equation 4.",
        "Finally, it sets ?xmin to the value of f that minimizes E(O)?E(Of ), as illustrated in Figure 1."
      ]
    },
    {
      "heading": "3.3 Disambiguation Algorithms",
      "text": [
        "In this section we discuss four algorithms based on our incremental EM approach and following our Best Entropy Cut method.",
        "They differ among themselves on the granularity in which the classifier is updated and on the label-transition operations allowed: ?",
        "A1: the classifier is updated incrementally after each EM iteration (which may comprise several label-transition operations).",
        "Only operation x?",
        "is allowed.",
        "?",
        "A2: the classifier is updated incrementally after each EM iteration.",
        "Both operations x?",
        "and x?",
        "are allowed.",
        "?",
        "A3: the classifier is updated incrementally after each label-transition operation.",
        "Only operation x?",
        "is allowed.",
        "?",
        "A4: the classifier is updated incrementally after each label-transition operation.",
        "Both operations x?",
        "and x?",
        "are allowed."
      ]
    },
    {
      "heading": "4 Experimental Evaluation",
      "text": [
        "In this section we analyze our algorithms using standard measures such as AUC values.",
        "For each positive+unlabeled (PU) corpus used in our evaluation we randomly selected x% of the positive examples (P) to become unlabeled ones (U).",
        "This procedure enables us to control the uncertainty level of the corpus.",
        "For each level we have a different TPR-FPR combination, enabling us to draw ROC curves.We repeated this procedure five times, so that five executions were performed for each uncertainty level.",
        "Tables 2?5 show the average for the five runs.",
        "Wilcoxon significance tests were performed (p<0.05) and best results, including statistical ties, are shown in bold."
      ]
    },
    {
      "heading": "4.1 Baselines and Collections",
      "text": [
        "Our baselines include namely SVMs (Joachims, 2006) and Biased SVMs (B-SVM (Liu et al., 2003)).",
        "Although the simple SVM algorithm does not adapt itself with unlabeled data, we decided to use it in order to get a sense of the performance achieved by simple baselines (in this case, unlabeled data is simply used as negative examples).",
        "The B-SVM algorithm uses a soft-margin SVM as the underlying classifier, which is reconstructed from scratch after each EM iteration.",
        "B-SVM employs a single transition threshold ?min for the entire corpus, instead of a different threshold ?xmin for each x ?",
        "D. It is representative of the state-of-the-art for learning classifiers from PU data.",
        "We employed two different Twitter collections.",
        "The first collection, ORGANIZATIONS, is composed of 10 corpora3 (O1 to O10).",
        "Each corpus contains messages in English mentioning the name of an organization (Bayer, Renault, among others).",
        "All messages were labeled by five annotators.",
        "Label means that the message is associated with the organization, whereas label means the opposite.",
        "The other collection, SOCCER TEAMS, contains 6 large-scale PU corpora (ST1 to ST6), taken from a platform for real time event monitoring (the link to this platform is omitted due to blind review).",
        "Each corpus contains messages in Portuguese mentioning the name/mascot of a Brazilian soccer team.",
        "Both collections are summarized in Table 1."
      ]
    },
    {
      "heading": "4.2 Results",
      "text": [
        "All experiments were performed on a Linux PC with an Intel Core 2 Duo 2.20GHz and 4GBytes RAM.",
        "Next we discuss the disambiguation performance and the computational efficiency of our algorithms.",
        "ORGANIZATIONS Corpora: Table 2 shows average AUC values for each algorithm.",
        "Algorithm A4 was the best performer in all cases, suggesting the benefits of (i) enabling both types of label-transition operations and (ii) keeping the classifier up-to-date after each label-transition operation.",
        "Further, algorithm A3 performed better than algorithm A2 in most of the cases, indicating the importance of keeping the classifier always up-to-date.",
        "On average A1 provides gains of 4% when compared against B-SVM, while A4 provides gains of more than 20%.",
        "SOCCER TEAMS Corpora: Table 3 shows average AUC values for each algorithm.",
        "Again, algorithm A4 was the best performer, providing gains that are up to 13% when compared against the baseline.",
        "Also, algorithm A3 performed better than algorithm A2, and the effectiveness of Algorithm A1 is similar to the effectiveness of the baseline.",
        "Since the SOCCER TEAMS collection is composed of large-scale corpora, in addition to high effectiveness, another important issue to be evaluated is computational performance.",
        "Table 4 shows the results obtained for the evaluation of our algorithms.",
        "As it can be seen, algorithm A1 is the fastest one, since it is the simplest one.",
        "Even though being slower than algorithm A1, algorithm A4 runs, on average, 120 times faster than B-SVM.",
        "rithm.",
        "The time spent by algorithm A1 is similar to the time spent by algorithm A2.",
        "The time spent by algorithm A3 is similar to the time spent by algorithm A4."
      ]
    },
    {
      "heading": "5 Conclusions",
      "text": [
        "In this paper we have introduced a novel EM approach, which employs a highly incremental underlying classifier based on association rules, completely avoiding work replication.",
        "Further, two label-transition operations are allowed, enabling the correction of false-negatives and false-positives.",
        "We proposed four algorithms based on our EM approach.",
        "Our algorithms employ an entropy minimization method, which finds the best transition threshold for each example in D. All these properties make our algorithms appropriate for named entity disambiguation under streaming data scenarios.",
        "Our experiments involve Twitter data mentioning ambiguous named entities.",
        "These datasets were obtained from real application scenarios and from platforms currently in operation.",
        "We have shown that three of our algorithms achieve significantly higher disambiguation performance when compared against a strong baseline (B-SVM), providing gains ranging from 1% to 20%.",
        "Also importantly, for large-scale streaming data, our algorithms are more than 120 times faster than the baseline."
      ]
    },
    {
      "heading": "6 Acknowledgments",
      "text": [
        "This research is supported by InWeb ?",
        "The Brazilian National Institute of Science and Technology for the Web (CNPq grant no.",
        "573871/2008-6), by UOL (www.uol.com.br) through its UOL Bolsa Pesquisa program (process number 20110215172500), and by the authors?",
        "individual grants from CAPES, CNPq and Fapemig."
      ]
    }
  ]
}
