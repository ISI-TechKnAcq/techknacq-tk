{
  "info": {
    "authors": [
      "Kevin Gimpel",
      "Mohit Bansal"
    ],
    "book": "EMNLP",
    "id": "acl-D14-1139",
    "title": "Weakly-Supervised Learning with Cost-Augmented Contrastive Estimation",
    "url": "https://aclweb.org/anthology/D14-1139",
    "year": 2014
  },
  "references": [
    "acl-J92-4003",
    "acl-N09-1009",
    "acl-N10-1083"
  ],
  "sections": [
    {
      "text": [
        "Proceedings of the 2014 Conference on Empirical Methods in Natural Language Processing (EMNLP), pages 1329?1341, October 25-29, 2014, Doha, Qatar.",
        "Abstract",
        "We generalize contrastive estimation in two ways that permit adding more knowledge to unsupervised learning.",
        "The first allows the modeler to specify not only the set of corrupted inputs for each observa-tion, but also how bad each one is.",
        "The second allows specifying structural preferences on the latent variable used to explain the observations.",
        "They require setting additional hyperparameters, which can be problematic in unsupervised learning, so we investigate new methods for unsupervised model selection and system combination.",
        "We instantiate these ideas for part-of-speech induction without tag dic-tionaries, improving over contrastive estimation as well as strong benchmarks from the PASCAL 2012 shared task."
      ]
    },
    {
      "heading": "1 Introduction",
      "text": [
        "Unsupervised NLP aims to discover useful structure in unannotated text.",
        "This structure might be part-of-speech (POS) tag sequences (Merialdo, 1994), morphological segmentation (Creutz and Lagus, 2005), or syntactic structure (Klein and Manning, 2004), among others.",
        "Unsupervised systems typically improve when researchers incorporate knowledge to bias learning to capture characteristics of the desired structure.",
        "1 There are many successful examples of adding knowledge to improve learning without labeled examples, including: sparsity in POS tag distributions (Johnson, 2007; Ravi and Knight, 2009; Ganchev et al., 2010), short attachments for dependency parsing (Smith and Eisner, 2006), 1 We note that doing so strains the definition of the term unsupervised.",
        "Hence we will use the term weakly-supervised to refer to methods that do not explicitly train on labeled examples for the task of interest, but do use some form of task-specific knowledge.",
        "agreement of word alignment models (Liang et al., 2006), power law effects in lexical distributions (Blunsom and Cohn, 2010; Blunsom and Cohn, 2011), multilingual constraints (Smith and Eisner, 2009; Ganchev et al., 2009; Snyder et al., 2009; Das and Petrov, 2011), and orthographic cues (Spitkovsky et al., 2010c; Spitkovsky et al., 2011b), inter alia.",
        "Contrastive estimation (CE; Smith and Eisner, 2005) is a general approach to weakly-supervised learning with a particular way of incorporating knowledge.",
        "CE increases the likelihood of the observations at the expense of those in a particular neighborhood of each observation.",
        "The neighborhood typically contains corrupted versions of the observations.",
        "The latent structure is marginalized out for both the observations and their corruptions; the intent is to learn latent structure that helps to explain why the observation was generated rather than any of the corrupted alternatives.",
        "In this paper, we present a new objective function for weakly-supervised learning that generalizes CE by including two types of cost functions, one on observations and one on output structures.",
        "The first (?4) allows us to specify not only the set of corrupted observations, but also how bad each corruption was.",
        "We use n-gram language models to measure the severity of each corruption.",
        "The second (?5) allows us to specify preferences on desired output structures, regardless of the input sentence.",
        "For POS tagging, we attempt to learn language-independent tag frequencies by computing counts from treebanks for 11 languages not used in our POS induction experiments.",
        "For example, we encourage tag sequences that contain adjacent nouns and penalize those that contain adjacent adpositions.",
        "We consider several unsupervised ways to set hyperparameters for these cost functions (?7), including the recently-proposed log-likelihood estimator of Bengio et al. (2013).",
        "We also circumvent 1329 hyperparameter selection via system combination, developing a novel voting scheme for POS induction that aligns tag identifiers across runs.",
        "We evaluate our approach, which we call cost-augmented contrastive estimation (CCE), on POS induction without tag dictionaries for five languages from the PASCAL shared task (Gelling et al., 2012).",
        "We find that CCE improves over both standard CE as well as strong baselines from the shared task.",
        "In particular, our final average accuracies are better than all entries in the shared task that use the same number of tags.",
        "2 Related Work Weakly-supervised techniques can be roughly categorized in terms of whether they influence the model, the learning procedure, or explicitly target the output structure.",
        "Examples abound in NLP; we focus on those that have been applied to POS tagging.",
        "There have been many efforts at biasing models, including features (Smith and Eisner, 2005a; Berg-Kirkpatrick et al., 2010), sparse priors (Johnson, 2007; Goldwater and Griffiths, 2007; Toutanova and Johnson, 2007), sparsity in tag transition distributions (Ravi and Knight, 2009), small models via minimum description length criteria (Vaswani et al., 2010; Poon et al., 2009), a one-tag-per-type constraint (Blunsom and Cohn, 2011), and power law effects via Bayesian nonparametrics (Van Gael et al., 2009; Blunsom and Cohn, 2010; Blunsom and Cohn, 2011).",
        "We focus below on efforts that induce bias into the learning (?2.1) or more directly in the output structure (?2.2), as they are more closely related to our contributions in this paper.",
        "2.1 Biasing Learning Some unsupervised methods do not change the model or attempt to impose structural bias; rather, they change the learning.",
        "This may involve optimizing a different objective function for the same model, e.g., by switching from soft to hard EM (Spitkovsky et al., 2010b).",
        "Or it may involve changing the objective during learning via annealing (Smith and Eisner, 2004) or more general multi-objective techniques (Spitkovsky et al., 2011a; Spitkovsky et al., 2013).",
        "Other learning modifications relate to automatic data selection, e.g., choosing examples for generative learning (Spitkovsky et al., 2010a) or automatically generating negative examples for discriminative unsupervised learning (Li et al., 2010; Xiao et al., 2011).",
        "CE does both, automatically generating negative examples and changing the objective function to include them.",
        "Our observation cost function alters CE's objective function, sharpening the effective distribution of the negative examples.",
        "2.2 Structural Bias Our output cost function is used to directly specify preferences on desired output structures.",
        "Several others have had similar aims.",
        "For dependency grammar induction, Smith and Eisner (2006) fa-vored short attachments using a fixed-weight feature whose weight was optionally annealed during learning.",
        "Their bias could be implemented as an output cost function in our framework.",
        "Posterior regularization (PR; Ganchev et al., 2010) is a general framework for declaratively specifying preferences on model outputs.",
        "Naseem et al. (2010) proposed universal syntactic rules for unsupervised dependency parsing and used them in a PR regime; we use analogous universal tag sequences in our cost function.",
        "Our output cost is similar to posterior regularization.",
        "The difference is that we specify preferences via an arbitrary cost function on output structures, while PR uses expectation constraints on posteriors of the model.",
        "We compare to the PR tag induction system of Grac?a et al. (2011) in our experiments, improving over it in several settings.",
        "2.3 Exploiting Resources Much of the work mentioned above also benefits from leveraging existing resources.",
        "These may be curated or crowdsourced resources like the Wik-tionary (Li et al., 2012), or traditional annotated treebanks for languages other than those under investigation (Cohen et al., 2011).",
        "In this paper, we use tag statistics from treebanks for 11 languages to impose our structural bias for a different set of languages used in our POS induction experiments.",
        "Substantial recent work has improved many NLP tasks by leveraging multilingual or parallel text (Cohen and Smith, 2009; Snyder et al., 2009; Wang and Manning, 2014), including unsupervised POS tagging (Naseem et al., 2009; Das and Petrov, 2011; T?ackstr?om et al., 2013; Ganchev and Das, 2013).",
        "This sort of multilingual guidance could also be captured by particular output cost functions, though we leave this to future work.",
        "1330 3 Unsupervised Structure Learning We consider a structured unsupervised learning setting.",
        "We use X to denote our set of possible structured inputs, and for a particular x ?",
        "X, we use Y(x) to denote the set of valid structured outputs for x.",
        "We are given a dataset of inputs {x (i) } N i=1 .",
        "To map inputs to outputs, we start by building a model of the joint probability distribution p?(x,y).",
        "We use a log-linear parameterization with feature vector f and weight vector ?",
        ": p?",
        "(x,y) = exp { ?",
        "> f(x,y) } ?",
        "x??X,y??Y(x?)",
        "exp { ?",
        "> f(x ?",
        ",y ? )",
        "} where the sum in the denominator ranges over all possible inputs and all valid outputs for them.",
        "In this paper, we consider ways of learning the parameters ?.",
        "Given ?, at test time we output a y for a new x using, e.g., Viterbi or minimum Bayes risk decoding; we use the latter in this paper.",
        "3.1 EM and Contrastive Estimation We start by reviewing two ways of choosing ?.",
        "The expectation-maximization algorithm (EM; Dempster et al., 1977) finds a local optimum of the marginal (log-)likelihood of the observations {x (i) } N i=1 .",
        "The marginal log-likelihood is a sum over all x (i) of the gain function ?",
        "EM (x (i) ): ?",
        "EM (x (i) ) = log ?",
        "y?Y(x(i)) p?",
        "(x (i) ,y) = log ?",
        "y?Y(x(i)) exp { ?",
        "> f(x (i) ,y) } ?",
        "log ?",
        "x??X,y??Y(x?)",
        "exp { ?",
        "> f(x ?",
        ",y ? )",
        "} ?",
        "??",
        "?",
        "Z(?)",
        "The difficulty is the final term, logZ(?",
        "), which requires summing over all possible inputs and all valid outputs for them.",
        "This summation is typically intractable for structured problems, and may even diverge.",
        "For this reason, EM is typically only used to train log-linear model weights when Z(?)",
        "= 1, e.g., for hidden Markov models, probabilistic context-free grammars, and models composed of locally-normalized log-linear models (Berg-Kirkpatrick et al., 2010), among others.",
        "There have been efforts at approximating the summation over elements of X, whether by limiting sequence length (Haghighi and Klein, 2006), only summing over observations in the training data (Riezler, 1999), restricting the observation space based on the task (Dyer et al., 2011), or using Gibbs sampling to obtain an unbiased sample of the full space (Della Pietra et al., 1997; Rosen-feld, 1997).",
        "Contrastive estimation (CE) addresses this challenge by using a neighborhood function N : X?",
        "2 X that generates a set of inputs that are ?corrup- tions?",
        "of an input x; N(x) always includes x. Using shorthand N i for N(x (i) ), CE corresponds to maximizing the sum over inputs x (i) of the gain ?",
        "CE (x (i) )= log Pr(x (i) | N i ) = log ?",
        "y?Y(x(i)) p?",
        "(x (i) ,y) ?",
        "x?",
        "?N i ?",
        "y??Y(x?)",
        "p?",
        "(x ?",
        ",y ? )",
        "= log ?",
        "y?Y(x(i)) exp { ?",
        "> f(x (i) ,y) } ?",
        "log ?",
        "x?",
        "?N i ?",
        "y??Y(x?)",
        "exp { ?",
        "> f(x ?",
        ",y ? )",
        "} Two logZ(?)",
        "terms cancel out, leaving the summation over input/output pairs in the neighborhood instead of the full summation over pairs.",
        "Two desiderata govern the choice of N. One is to make the summation over its elements computationally tractable.",
        "If N(x) = X for all x ?",
        "X, we obtain EM, so a smaller neighborhood typically must be used in practice.",
        "The second consideration is to target learning for the task of interest.",
        "For POS tagging and dependency parsing, Smith and Eisner (2005a, 2005b) used neighborhood functions that corrupted the observations in systematic ways, e.g., their TRANS1 neighborhood contains the original sentence along with those that result from transposing a single pair of adjacent words.",
        "The intent was to force the learner to explain why the given sentences were observed at the expense of the corrupted sentences.",
        "Next we present our modifications to contrastive estimation.",
        "Both can be viewed as adding specialized cost functions that penalize some part of the structured input/output pair.",
        "4 Modeling Corruption Costs While CE allows us to specify a set of corrupted x for each x (i) via the neighborhood function N, it says nothing about how bad each corruption is.",
        "The same type of corruption might be harmful in one context and not harmful in another.",
        "This fact was suggested as the reason why certain neighborhoods did not work as well for POS 1331 tagging as others (Smith and Eisner, 2005a).",
        "One poorly-performing neighborhood consisted of sentences in which a single word of the original was deleted.",
        "Deleting a single word in a sentence might not harm grammaticality.",
        "By contrast, neighborhoods that transpose adjacent words led to better results.",
        "These kinds of corruptions are expected to be more frequently harmful, at least for languages with relatively rigid word order.",
        "How-ever, there may still be certain transpositions that are benign, at least for grammaticality.",
        "To address this, we introduce an observation cost function ?",
        ": X ?",
        "X ?",
        "R ?0 that indicates how much two observations differ.",
        "Using ?, we define the following gain function ?",
        "CCE 1 (x (i) ) = log ?",
        "y?Y(x(i)) exp { ?",
        "> f(x (i) ,y) } ?",
        "log ?",
        "x?",
        "?N i ?",
        "y??Y(x?)",
        "exp { ?",
        "> f(x ?",
        ",y ? )",
        "+ ?",
        "(x (i) ,x ? )",
        "} The function ?",
        "inflates the score of neighborhood entries with larger differences from the observed x (i) .",
        "This gain function is inspired by ideas from structured large-margin learning (Taskar et al., 2003; Tsochantaridis et al., 2005), specifically softmax-margin (Povey et al., 2008; Gimpel and Smith, 2010).",
        "Softmax-margin extends conditional likelihood by allowing the user to specify a cost function to give partial credit for structures that are partially correct.",
        "Conditional likelihood, by contrast, treats all incorrect structures equally.",
        "While softmax-margin uses a cost function to specify how two output structures differ, our gain function ?",
        "CCE 1 uses a cost function ?",
        "to specify how two inputs differ.",
        "But the motivations are sim-ilar: since poor structures have their scores artificially inflated by ?, learning pays more attention to them, choosing weights that penalize them more than the lower-cost structures.",
        "4.1 Observation Cost Functions What types of cost functions should we consider?",
        "For efficient inference, we want to ensure that ?",
        "decomposes additively across parts of the corrupted input x ?",
        "in the same way as the features; we assume unigram and bigram features in this paper.",
        "In addition, the choice of the observation cost function ?",
        "is tied to the choice of neighborhood function.",
        "In our experiments, we use neighborhoods that change the order of words in the observation but not the set of words.",
        "Our first cost function simply counts the number of novel bigrams introduced when corrupting the original: ?",
        "I (x (i) ,x) = ?",
        "|x|+1 ?",
        "j=1 I [ x j?1 x j /?",
        "2grams(x (i) ) ] where x j is the jth word of sentence x, x 0 is the start-of-sentence marker, x |x|+1 is the end-of-sentence marker, 2grams(x) returns the set of bigrams in x, I[] returns 1 if its argument is true and 0 otherwise, and ?",
        "is a constant to be tuned.",
        "We call this cost function MATCH.",
        "Only x (i) (which is always contained in N i ) is guaranteed to have cost 0.",
        "In the TRANS1 neighborhood, corrupted sequences will be penalized more if their transpositions occur in the middle of the sentence rather than at the beginning or end.",
        "We also consider a version that weights the indicator by the negative log probability of the novel bigram: ?",
        "LM (x (i) ,x) = ?",
        "|x|+1 ?",
        "j=1 ?log P(x j |x j?1 )I [ x j?1 x j /?",
        "2grams(x (i) ) ] where P(x j |x j?1 ) is obtained from a bigram language model.",
        "Among novel bigrams in the corruption x, if the second word is highly surprising conditioned on the first, the bigram will incur high cost.",
        "We refer to ?",
        "LM (x (i) ,x) as MATLM.",
        "5 Expressing Structural Preferences Our second modification to CE allows us to specify structural preferences for outputs y.",
        "We first note that there exist objective functions for supervised structure prediction that never require computing the feature vector for the true output y (i) .",
        "Examples include Bayes risk (Kaiser et al., 2000; Povey and Woodland, 2002) and structured ramp loss (Do et al., 2008).",
        "These two objectives do, however, need to compute a cost function cost(y (i) ,y), which requires the true output y (i) .",
        "We start with the following form of structured ramp loss from Gimpel and Smith (2012), transformed here to a gain function: max y?Y(x(i)) ( ?",
        "> f(x (i) ,y)?",
        "cost(y (i) ,y) ) ?",
        "max y?",
        "?Y(x(i)) ( ?",
        "> f(x (i) ,y ? )",
        "+ cost(y (i) ,y ? )",
        ") (1) Maximizing this gain function for supervised learning corresponds to increasing the model score 1332 of outputs that have both high model score (?",
        "> f ) and low cost, while decreasing the model score of outputs with high model score and high cost.",
        "For unsupervised learning, we do not have y (i) , so we simply drop y (i) from the cost function.",
        "The result is an output cost function pi : Y ?",
        "R ?0 which captures our a priori knowledge about desired output structures.",
        "The value of pi(y) should be large for outputs y that are far from the ideal.",
        "In this paper, we consider POS induction and use intrinsic evaluation; however, in a real-world sce-nario, the output cost function could use signals derived from the downstream task in which the tags are being used.",
        "Given pi, we convert each max to a log ?",
        "exp in Eq. 1 and introduce the contrastive neighborhood into the second term, defining our new gain function ?",
        "CCE 2 (x (i) ) = log ?",
        "y?Y(x(i)) exp { ?",
        "> f(x (i) ,y)?",
        "pi(y) } ?",
        "log ?",
        "x?",
        "?N i ?",
        "y??Y(x?)",
        "exp { ?",
        "> f(x ?",
        ",y ? )",
        "+ pi(y ? )",
        "} Gimpel (2012) found that using such ?softened?",
        "versions of the ramp losses worked better than the original versions (e.g., Eq. 1) when training machine translation systems.",
        "5.1 Output Cost Functions The output cost pi should capture our desiderata about y for the task of interest.",
        "We consider universal POS tag subsequences analogous to the universal syntactic rules of Naseem et al. (2010).",
        "In doing so, we use the universal tags of Petrov et al. (2012): NOUN, VERB, ADJ (ad- jective), ADV (adverb), PRON (pronoun), DET (determiner), ADP (pre/postposition), NUM (nu- meral), CONJ (conjunction), PRT (particle), ?.?",
        "(punctuation), and X (other).",
        "We aimed for a set of rules that would be robust across languages.",
        "So, we used treebanks for 11 languages from the CoNLL 2006/2007 shared tasks (Buchholz and Marsi, 2006; Nivre et al., 2007) other than those used in our POS induction experiments.",
        "In particular, we used Arabic, Bulgarian, Catalan, Czech, English, Spanish, Ger-man, Hungarian, Italian, Japanese, and Turkish.",
        "We replicated shorter treebanks a sufficient number of times until they were a similar size as the largest treebank.",
        "Then we counted gold POS tag unigrams and bigrams from the concatenation.",
        "tag unigram count cost X 50783 3.83 NUM 174613 2.59 PRT 179131 2.57 ADV 330210 1.96 CONJ 436649 1.68 PRON 461880 1.62 DET 615284 1.33 ADJ 694685 1.21 ADP 906922 0.95 VERB 1018989 0.83 .",
        "1042662 0.81 NOUN 2337234 0 tag bigram count cost DET PRT 109 84.41 DET CONJ 518 68.82 NUM ADV 1587 57.63 NOUN NOUN 409828 2.09 DET NOUN 454980 1.04 NOUN .",
        "504897 0 Table 1: Counts and costs for universal tags based on treebanks for 11 languages not used in POS induction experiments.",
        "Where #(y) is the count of tag y in the treebank concatenation, the cost of y is u(y) = log ( max y ?",
        "#(y ? )",
        "#(y) ) and, where #(?y 1 , y 2 ?)",
        "is the count of tag bigram ?y 1 , y 2 ?, the cost of ?y 1 , y 2 ?",
        "is u(?y 1 , y 2 ?)",
        "= 10?log ( max ?y ?",
        "1 ,y ?",
        "2 ?",
        "#(?y ?",
        "1 , y ?",
        "2 ?)",
        "#(?y 1 , y 2 ?)",
        ") We use a multiplier of 10 in order to exaggerate count differences among bigrams, which generally are closer together than unigram counts.",
        "In Table 1, we show counts and costs for all tag unigrams and selected tag bigrams.",
        "2 Given these costs for individual tag unigrams and bigrams, we use the following pi function, which we call UNIV: pi(y) = ?",
        "|y|+1 ?",
        "j=1 u(y j ) + u(?y j?1 , y j ?)",
        "where ?",
        "is a constant to be tuned and y j is the jth tag of y.",
        "We define y 0 to be the beginning-of-sentence marker and y |y|+1 to be the end-of-sentence marker (which has unigram cost 0).",
        "Many POS induction systems use one-tag-per-type constraints (Blunsom and Cohn, 2011; Gelling et al., 2012), which often lead to higher 2 The complete tag bigram list is provided in the supplementary material.",
        "1333 max ?",
        "N?",
        "i=1 log ?",
        "y?Y(x(i)) exp { ?>f(x(i),y) } ?",
        "log ?",
        "x?",
        "?N i ?",
        "y??Y(x?)",
        "exp { ?>f(x?,y?)",
        "} (2) max ?",
        "N?",
        "i=1 log ?",
        "y?Y(x(i)) exp { ?>f(x(i),y)?",
        "pi(y) } ?",
        "log ?",
        "x?",
        "?N i ?",
        "y??Y(x?)",
        "exp { ?>f(x?,y?)",
        "+ ?(x(i),x?)",
        "+ pi(y?)",
        "} (3) Figure 1: Contrastive estimation (Eq. 2) and cost-augmented contrastive estimation (Eq. 3).",
        "L2 regularization terms ( C 2 ?",
        "|?| j=1 ?",
        "2 j ) are not shown here but were used in our experiments.",
        "accuracies even though the gold standard is not constrained in this way.",
        "This constraint can be encoded as an output cost function, though it would require approximate inference (Poon et al., 2009).",
        "6 Cost-Augmented CE We extended the objective function underlying CE by defining two new types of cost functions, one on observations (?4) and one on outputs (?5).",
        "We combine them into a single objective, which we call cost-augmented contrastive estimation (CCE), shown as Eq. 3 in Figure 1.",
        "If the cost functions ?",
        "and pi factor in the same way as the features f , then it is straightforward to implement CCE atop an existing CE implementation.",
        "The additional terms in the cost functions can be implemented as features with fixed weights (albeit where the weight differs depending on the context).",
        "7 Model Selection Our modifications give increased flexibility, but require setting new hyperparameters.",
        "In addition to the choice of the cost functions, each has a weight: ?",
        "for ?",
        "and ?",
        "for pi.",
        "We need ways to set these weights that do not require labeled data.",
        "Smith and Eisner (2005a) chose the hyperparameter values that yielded the best CE objective on held-out development data.",
        "We use their strategy, though we experiment with two others as well.",
        "3 In particular, we estimate held-out data log-likelihood via the method of Bengio et al. (2013) and also consider ways of combining outputs from multiple models.",
        "7.1 Estimating Held-Out Log-Likelihood Bengio et al. (2013) recently proposed ways to efficiently estimate held-out data log-likelihood 3 When using their strategy for CCE, we compute the CE criterion only, omitting the costs.",
        "We do so because the weights of the cost terms can have a large impact on the magnitude of the objective, making it difficult to do a fair comparison of models with different cost weights.",
        "for generative models.",
        "They showed empirically that a simple, biased version of their conservative sampling-based log-likelihood (CSL) estimator can be useful for model selection.",
        "The biased CSL requires a Markov chain on the variables in the model (i.e., x and y) as well as the ability to compute p?(x|y).",
        "It generates consecutive samples of y from a Markov chain initialized at each x in a development set D, with S Markov chains run for each x.",
        "We compute and sum p?",
        "(x|y j ) for each sampled y j , then sum over all x in D. The result is a biased estimate for the log-likelihood of D. Bengio et al. showed that these biased estimates could give the same model ranking as unbiased estimates, though more efficiently.",
        "They also showed that taking the single, initial sample from the S Markov chains resulted in the same model ranking as using many samples from each chain.",
        "We follow suit here.",
        "Our Markov chain is a blocked Gibbs sampler in which we alternate between sampling from p?",
        "(y|x) and p?(x|y).",
        "Since we only use a single sample from each Markov chain and initialize each chain to x, this simply amounts to drawing S samples from p?(y|x).",
        "To sample from p?",
        "(y|x), we use the exact algorithm obtained by running the backward algorithm and then performing left-to-right sampling of tags using the local features and requisite backward terms to define the local tag distributions.",
        "We then compute p?",
        "(x|y) for each sampled y.",
        "If there are no features in f that look at more than one word (which is the case with the features used in our experiments), then this probability factors: p?",
        "(x|y) = ?",
        "|y| k=1 p?",
        "(xk|yk) This is easily computable assuming that we have normalization constants Z(y) cached for each tag y.",
        "To compute each Z(y), we sum over all words observed in the training data (replacing some with a special UNK token; see below).",
        "We can then compute likelihoods for individual words and mul-1334 tiply them across the words in the sentence to compute p?(x|y).",
        "To summarize, we get a log-likelihood estimate for development setD = {x (i) } |D| i=1 by sampling S times from p?",
        "(y|x (i) ) for each x (i) , getting samples {{y (i),j } S j=1 } |D| i=1 , then we compute ?",
        "|D| i=1 ?",
        "S j=1 log p?",
        "(x (i) |y (i),j ) We used values of S ?",
        "{1, 10, 100}, finding that the ranking of models was consistent across S values.",
        "We used S = 10 in all results reported below.",
        "We note that this estimator was originally presented for generative models, and that (C)CE is not a generative training criterion.",
        "It seeks to maximize the conditional probability of an observation given its neighborhood.",
        "Nonetheless, when implementing our log-likelihood estimator, we treat the model as a generative model, computing the Z(y) constants by summing over all words in the vocabulary.",
        "7.2 System Combination We can avoid choosing a single model by combining the outputs of multiple models via system combination.",
        "We decode test data by using posterior decoding.",
        "To combine the outputs of multiple models, we find the max-posterior tag under each model, then choose the highest vote-getter, breaking ties arbitrarily.",
        "However, when doing POS induction without a tag dictionary, the tags are simply unique identifiers and may not have consistent meaning across runs.",
        "To address this, we propose a novel voting scheme that is inspired by the widely-used 1-to-1 accuracy metric for POS induction (Haghighi and Klein, 2006).",
        "This metric maps system tags to gold tags to maximize accuracy with the constraint that each gold tag is mapped to at most once.",
        "The optimal mapping can be found by solving a maximum weighted bipartite matching problem.",
        "We adapt this idea to map tags between two sys-tems, rather than between system tags and gold tags.",
        "Given k systems that we want to combine, we choose one to be the backbone and map the remaining k ?",
        "1 systems?",
        "outputs to the backbone.",
        "4 After mapping each system's output to the backbone system, we perform simple majority voting among all k systems.",
        "To choose the backbone, we 4 We use the LEMON C++ toolkit (Dezs et al., 2011) to solve the maximum weighted bipartite matching problems.",
        "consider each of the k systems in turn as backbone and maximize the sum of the weights of the weighted bipartite matching solutions found.",
        "This is a heuristic that attempts to choose a backbone that is similar to all other systems.",
        "We found that highly-weighted matchings often led to high POS tagging accuracy metrics.",
        "We call this voting scheme ALIGN.",
        "To see the benefit of ALIGN, we also compare to a simple scheme (NA ?",
        "IVE) that performs majority voting without any tag mapping.",
        "8 Experiments Task and Datasets We consider POS induction without tag dictionaries using five freely-available datasets from the PASCAL shared task (Gelling et al., 2012).",
        "5 These include Danish (DA), using the Copenhagen Dependency Treebank v2 (Buch- Kromann et al., 2007); Dutch (NL), using the Alpino treebank (Bouma et al., 2001); Portuguese (PT), using the Floresta Sint?a(c)tica treebank (Afonso et al., 2002); Slovene (SL), using the jos500k treebank (Erjavec et al., 2010); and Swedish (SV), using the Talbanken treebank (Nivre et al., 2006).",
        "We use their provided training, development, and test sets.",
        "Evaluation We fix the number of tags in our models to 12, which matches the number of universal tags from Petrov et al. (2012).",
        "We use both many-to-1 (M-1) and 1-to-1 (1-1) accuracy as our evaluation metrics, using the universal tags for the gold standard (which was done for the official evaluation for the shared task).",
        "6 We note that our pi function assigns identities to tags (e.g., tag 1 is assumed to be NOUN), so we could use actual tagging accuracy when training with the pi cost function.",
        "But we use M-1 and 1-1 accuracy to enable easier comparison both among different settings and to prior work.",
        "Baselines From the shared task, we compare to all entries that used 12 tags.",
        "These include 5 http://wiki.cs.ox.ac.uk/ InducingLinguisticStructure/SharedTask 6 It is common to use a greedy algorithm to compute 1-to-1 accuracy, e.g., as in the shared task scoring script (http://www.dcs.shef.ac.uk/ ?",
        "tcohn/ wils/eval.tar.gz), though the optimal mapping can be computed efficiently via the maximum weighted bipartite matching algorithm, as stated above.",
        "We use the shared task scorer for all results here for ease of comparison.",
        "When we instead evaluate using the optimal mapping, we find that accuracies are usually only slightly higher than those found by the greedy algorithm.",
        "1335 BROWN clusters (Brown et al., 1992), clusters obtained using the mkcls tool (Och, 1995), and the featurized HMM with sparsity constraints trained using posterior regularization (PR), described by Grac?a et al. (2011).",
        "The PR system achieved the highest average 1-1 accuracy in the shared task.",
        "We restrict our attention to systems that use 12 tags because the M-1 and 1-1 metrics are highly dependent upon the number of hypothesized tags.",
        "In general, using more tags leads to higher M-1 and lower 1-1 (Gelling et al., 2012).",
        "By keeping the number of tags fixed, we hope to provide a cleaner comparison among approaches.",
        "We compare to two other baselines: an HMM trained with 500 iterations of EM and an HMM trained with 100 iterations of stepwise EM (Liang and Klein, 2009).",
        "We used random initialization as done by Liang and Klein: we set each parameter in each multinomial to exp{1 + c}, where c ?",
        "U [0, 1], then normalized to get probability distributions.",
        "For stepwise EM, we used mini-batch size 3 and stepsize reduction power 0.7.",
        "For all models we trained, including both baselines and CCE, we used only the training data during training and used the unannotated development data for certain model selection criteria.",
        "No labels were used except for final evaluation on the test data.",
        "Therefore, we need a way to handle unknown words in test data.",
        "When running EM and stepwise EM, while reading in the final 10% of sentences in the training set, we replace novel words with the special token UNK.",
        "We then replace unknown words in test data with UNK.",
        "8.1 CCE Setup Features We use standard indicator features on tag-tag transitions and tag-word emissions, the spelling features from Smith and Eisner (2005a), and additional emission features based on Brown clusters.",
        "The latter features are simply indicators for tag-cluster pairs?analogous to tag-word emissions in which the word is replaced by its Brown cluster identifier.",
        "We run Brown clustering (Liang, 2005) on the POS training data for each language, once with 12 clusters and once with 40, then add tag-cluster emission features for each clustering and one more for their conjunction.",
        "7 7 To handle unknown words: for words that only appear in the final 10% of training sentences, we replace them with UNK when firing their tag-word emission features.",
        "We use special Brown cluster identifiers reserved for UNK.",
        "But we still use all spelling features derived from the actual word Learning We solve Eq. 2 and Eq. 3 by running LBFGS until convergence on the training data, up to 100 iterations.",
        "We tag the test data with minimum Bayes risk decoding and evaluate.",
        "We use two neighborhood functions: ?",
        "TRANS1: the original sentence along with all sentences that result from doing a single transposition of adjacent words.",
        "?",
        "SHUFF10: the original sentence along with 10 random permutations of it.",
        "We use L2 regularization, adding C 2 ?",
        "|?| j=1 ?",
        "2 j to the objectives shown in Figure 1.",
        "We use a fixed (untuned) C = 0.0001 for all experiments reported below.",
        "8 We initialize each CE model by sampling weights from N(0, 1).",
        "Cost Functions The cost functions ?",
        "and pi have constants ?",
        "and ?",
        "which balance their contributions relative to the model score and must be tuned.",
        "We consider the ways proposed in Section 7, namely tuning based on the contrastive estimation criterion computed on development data (CE), the log-likelihood estimate on development data with S = 10 (LL), and our two system combination algorithms: na?",
        "?ve voting (NA ?",
        "IVE) and aligned voting (ALIGN), both of which use as input the 4 system outputs whose hyperparameters led to the highest values for the CE criterion on development data.",
        "We used ?",
        "?",
        "{3 ?",
        "10 ?4 , 10 ?3 , 3 ?",
        "10 ?3 , 0.01, 0.03, 0.1, 0.3} and ?",
        "?",
        "{3 ?",
        "10 ?6 , 10 ?5 , 3 ?",
        "10 ?5 , 10 ?4 , 3 ?",
        "10 ?4 }.",
        "Setting ?",
        "= ?",
        "= 0 gives us CE, which we also compare to.",
        "When using both MATLM and UNIV simul-taneously, we first choose the best two ?",
        "values by the LL criterion and the best two ?",
        "values by the CE criterion when using only those individual costs.",
        "This gives us 4 pairs of values; we run experiments with these pairs and choose the pair to report using each of the model selection criteria.",
        "For system combination, we use the 4 system outputs resulting from these 4 pairs.",
        "For training bigram language models for the MATLM cost, we use the language's POS training data concatenated with its portion of the Eu-roparl v7 corpus (Koehn, 2005) and the text of its type.",
        "For unknown words at test time, we use the UNK emission feature, the Brown cluster features with the special UNK cluster identifiers, and the word's actual spelling features.",
        "8 In subsequent experiments we tried C ?",
        "{0.01, 0.001} for the baseline CE setting and found minimal differences.",
        "1336 neigh-cost mod.",
        "DA NL PT SL SV avg borhood sel.",
        "M-1 1-1 M-1 1-1 M-1 1-1 M-1 1-1 M-1 1-1 M-1 1-1 SHUFF10 none N/A 45.0 38.0 55.1 45.7 54.2 38.0 54.7 45.7 47.4 31.3 51.3 39.7 MATCH CE 48.9 31.5 56.5 46.4 54.2 37.7 55.9 46.8 48.9 33.8 52.9 39.2 LL 49.9 34.4 56.5 46.4 54.1 38.9 57.2 48.9 48.9 33.8 53.3 40.5 MATLM CE 49.1 34.3 59.6 50.4 53.6 37.1 55.0 46.2 48.8 33.1 53.2 40.2 LL 50.2 40.0 59.6 50.4 53.1 36.0 58.0 48.4 48.8 33.1 53.9 41.6 TRANS1 none N/A 58.5 42.7 62.5 49.5 70.7 43.8 58.6 46.1 58.7 53.8 61.8 47.2 MATCH CE 58.5 42.5 66.3 53.3 70.6 43.3 59.1 45.6 59.3 54.2 62.7 47.8 LL 58.8 42.8 66.3 53.3 70.6 43.3 60.3 43.7 59.8 54.9 63.1 47.6 MATLM CE 59.4 43.5 63.8 50.1 70.2 43.0 58.5 46.1 59.2 54.8 62.2 47.5 LL 58.7 42.8 66.5 60.4 70.5 43.6 59.1 47.7 59.2 54.8 62.8 49.9 Table 2: Results for observation cost functions.",
        "The CE baseline corresponds to rows where cost=?none?.",
        "Other rows are CCE.",
        "Best score for each column and each neighborhood is bold.",
        "Wikipedia.",
        "The word counts for the Wikipedias used range from 18M for Slovene to 1.9B for Dutch.",
        "We used modified Kneser-Ney smoothing as implemented by SRILM (Stolcke, 2002).",
        "8.2 Results We present two sets of results.",
        "First we compare our MATCH and MATLM observation cost functions for our two neighborhoods and two ways of doing model selection.",
        "Then we do a broader com-parison, comparing both types of costs and their combination to our full set of baselines.",
        "Observation Cost Functions In Table 2, we show results for observation cost functions.",
        "We note that the TRANS1 neighborhood works much better than the SHUFF10 neighborhood, but we find that using cost functions can close the gap in certain cases, particularly for Dutch and Slovene for which the SHUFF10 MATLM scores approach or exceed the TRANS1 scores without a cost.",
        "Since the SHUFF10 neighborhood exhibits more diversity than TRANS1, we expect to see larger gains from using observation cost functions.",
        "We do in fact see larger gains in M-1, e.g., average improvements are 1.6-2.6 for SHUFF10 and 0.41.3 for TRANS1, though 1-1 gains are closer.",
        "For TRANS1, while MATCH does reach a slightly higher average M-1 than MATLM, the latter does much better in 1-1 (49.9 vs. 47.6 when using LL for model selection).",
        "For SHUFF10, MATLM consistently does better than MATCH.",
        "Nonetheless, we suspect MATCH works as well as it does because it at least differentiates the observation (which is always part of the neighborhood) from the corruptions.",
        "We find that the LL model selection criterion consistently works better than the CE criterion for model selection.",
        "When using LL model selection and fixing the neighborhood, all average scores are better than their CE baselines.",
        "For M-1, the average improvement is 1.0 to 2.6 points, and for 1-1 the average improvement ranges from 0.4 to 2.7.",
        "We find the best overall performance when using MATLM with LL model selection with the TRANS1 neighborhood, and we report this setting in our subsequent experiments.",
        "Output Cost Function Table 3 shows results when using our UNIV output cost function, as well as our full set of baselines.",
        "All (C)CE experiments used the TRANS1 neighborhood.",
        "We find that our contrastive estimation baseline (cost=?none?)",
        "has a higher average M-1 (61.8) than all results from the shared task, but its average 1-1 accuracy is lower than that reached by posterior regularization, the best system in the shared task according to 1-1.",
        "Using an observation cost function increases both M-1 and 1-1: MATLM yields an average 1-1 of 49.9, nearing the 50.1 of PR while exceeding it in M-1 by nearly 2 points.",
        "When using the UNIV cost function, we see some variation in performance across model selection criteria, but we find improvements in both M-1 and 1-1 accuracy under most settings.",
        "When doing model selection via ALIGN voting, we roughly match the average 1-1 of PR, and when using the CE criterion, we beat it by 1 point on average (51.3 vs. 50.1).",
        "Combined Costs When using the UNIV cost, we find that model selection via CE works better than LL.",
        "So for the combined costs, we took the two best MATLM weights (?",
        "values) according to LL and the two best UNIV weights (?",
        "val-ues) according to CE and ran combined cost experiments (MATCHLM+UNIV) with the four pairs of hyperparameters.",
        "Then from among these four, 1337 system DA NL PT SL SV avg M-1 1-1 M-1 1-1 M-1 1-1 M-1 1-1 M-1 1-1 M-1 1-1 HMM, EM 42.5 28.1 53.0 40.6 59.4 33.7 50.3 34.7 49.3 33.9 50.9 34.2 HMM, stepwise EM 51.7 38.2 61.6 45.2 66.5 46.7 53.6 35.7 55.3 39.6 57.7 41.1 BROWN 47.1 39.2 57.3 43.1 67.6 51.6 58.3 42.3 57.6 51.3 57.6 45.5 mkcls 53.1 44.2 63.0 54.1 68.1 46.3 50.4 40.6 57.3 43.6 58.4 45.8 posterior regularization 53.8 45.6 57.6 45.4 74.4 56.1 60.0 48.5 58.8 54.9 60.9 50.1 contrastive estimation cost model sel.",
        "none N/A 58.5 42.7 62.5 49.5 70.7 43.8 58.6 46.1 58.7 53.8 61.8 47.2 MATCH LL 58.8 42.8 66.3 53.3 70.6 43.3 60.3 43.7 59.8 54.9 63.1 47.6 MATLM LL 58.7 42.8 66.5 60.4 70.5 43.6 59.1 47.7 59.2 54.8 62.8 49.9 UNIV CE 59.7 45.6 60.6 51.1 70.0 62.7 60.9 44.1 57.1 52.8 61.7 51.3 LL 59.5 42.2 62.1 56.3 70.7 43.1 60.9 44.1 57.1 52.8 62.1 47.7 NA ?",
        "IVE 59.2 45.6 62.2 52.8 72.7 52.7 60.0 43.8 56.2 53.0 62.2 49.6 ALIGN 61.6 47.3 63.7 54.5 74.4 53.1 59.7 42.1 56.6 53.2 63.2 50.0 MATLM CE 59.8 45.7 60.4 48.4 70.0 62.8 52.9 45.0 59.4 54.9 60.5 51.4 + LL 59.3 42.5 61.9 56.2 70.8 43.1 59.3 41.9 60.0 55.1 62.3 47.8 NA ?",
        "IVE 58.5 44.4 64.9 60.3 65.4 52.1 55.5 45.9 59.0 54.4 60.6 51.4 UNIV ALIGN 61.1 45.4 66.2 60.9 75.8 49.8 59.5 48.2 59.0 54.4 64.3 51.7 Table 3: Unsupervised POS tagging accuracies for five languages, showing results for three systems from the PASCAL shared task as well as three other baselines (EM, stepwise EM, and contrastive estimation).",
        "All (C)CE results use the TRANS1 neighborhood.",
        "The best score in each column is bold.",
        "we again chose results by CE, LL, and both voting schemes.",
        "The results are shown in the lower part of Table 3.",
        "We find different trends in M-1 and 11 depending on whether we use CE or LL for model selection, which may be due to our limited hyperparameter search stemming from computational constraints.",
        "However, by comparing NA ?",
        "IVE to ALIGN, we see a consistent benefit from aligning tags before voting, leading to our highest average accuracies.",
        "In particular, using MATCHLM+UNIV and ALIGN, we improve over CE by 2.5 in M-1 and 4.5 in 1-1, also improving over the best results from the shared task.",
        "9 Conclusion We have shown how to modify contrastive estimation to use additional sources of knowledge, both in terms of observation and output cost functions.",
        "We adapted a recently-proposed technique for estimating the log-likelihood of held-out data, finding it to be effective as a model selection criterion when using observation cost functions.",
        "We improved tagging accuracy by using weak supervision in the form of universal tag frequencies.",
        "We proposed a system combination method for POS induction systems that consistently performs better than na?",
        "?ve voting and circumvents hyperparameter selection.",
        "We reported results on par with or exceeding the best systems from the PASCAL 2012 shared task.",
        "Contrastive estimation has been shown effective for numerous NLP tasks, including dependency grammar induction (Smith and Eisner, 2005b), bilingual part-of-speech induction (Chen et al., 2011), morphological segmentation (Poon et al., 2009), and machine translation (Xiao et al., 2011).",
        "The hope is that our contributions can benefit these and other applications of weakly-supervised learning.",
        "Acknowledgments We thank the anonymous reviewers for their insightful comments and Waleed Ammar, Chris Dyer, David McAllester, Sasha Rush, Nathan Schneider, Noah Smith, and John Wieting for helpful discussions.",
        "References"
      ]
    }
  ]
}
