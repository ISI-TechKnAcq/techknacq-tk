{
  "info": {
    "authors": [
      "Yael Cohen-Sygal",
      "Shuly Wintner"
    ],
    "book": "Computational Linguistics",
    "id": "acl-J11-1003",
    "title": "Towards Modular Development of Typed Unification Grammars",
    "url": "https://aclweb.org/anthology/J11-1003",
    "year": 2011
  },
  "references": [
    "acl-C00-2087",
    "acl-C96-1034",
    "acl-C96-2106",
    "acl-I05-2035",
    "acl-J92-4004",
    "acl-P06-1018",
    "acl-P06-1019",
    "acl-W02-0103",
    "acl-W02-1502",
    "acl-W02-1506",
    "acl-W04-1510"
  ],
  "sections": [
    {
      "text": [
        "Yael Sygal* University of Haifa",
        "Shuly Wintner** University of Haifa",
        "Development of large-scale grammars for natural languages is a complicated endeavor: Grammars are developed collaboratively by teams of linguists, computational linguists, and computer scientists, in a process very similar to the development oflarge-scale software.",
        "Grammars are written in grammatical formalisms that resemble very-high-level programming languages, and are thus very similar to computer programs.",
        "Yet grammar engineering is still in its infancy: Few grammar development environments support sophisticated modularized grammar development, in the form ofdistribution ofthe grammar development effort, combination ofsub-grammars, separate compilation and automatic linkage, information encapsulation, and so forth.",
        "This workprovides preliminary foundations for modular construction of (typed) unification grammars for natural languages.",
        "Much ofthe information in such formalisms is encoded by the type signature, and we subsequently address the problem through the distribution ofthe signature among the different modules.",
        "We define signature modules and provide operators of module combination.",
        "Modules may specify only partial information about the components ofthe signature and may communicate through parameters, similarly to function calls in programming languages.",
        "Our definitions are inspired by methods and techniques of programming language theory and software engineering and are motivated by the actual needs ofgrammar developers, obtained through a careful examination of existing grammars.",
        "We show that our definitions meet these needs by conforming to a detailed set of desiderata.",
        "We demonstrate the utility of our definitions by providing a modular design of the HPSG grammar of Pollard and Sag."
      ]
    },
    {
      "heading": "1.. Introduction",
      "text": [
        "Development of large-scale grammars for natural languages is an active area of research in human language technology.",
        "Such grammars are developed not only for purposes of theoretical linguistic research, but also for natural language applications such as machine translation, speech generation, and so on.",
        "Wide-coverage grammars are being developed for various languages (Abeille, Candito, and Kinyon 2000; XTAG Research",
        "* Department of Computer Science, University of Haifa, 31905 Haifa, Israel.",
        "E-mail: yael.sygal@gmail.com.",
        "** Department of Computer Science, University of Haifa, 31905 Haifa, Israel.",
        "E-mail: shuly@cs.haifa.ac.il.",
        "Submission received: 3 June 2009; revised submission received: 21 June 2010; accepted for publication: 14 September 2010.",
        "Group 2001; Oepen et al.",
        "2002; Hinrichs, Meurers, and Wintner 2004; Bender et al.",
        "2005; King et al.",
        "2005; Müller 2007) in several theoretical frameworks, including TAG (Joshi, Levy, and Takahashi 1975), LFG (Dalrymple 2001), HPSG (Pollard and Sag 1994), and XDG (Debusmann, Duchier, and Rossberg 2005).",
        "Grammar development is a complex enterprise: It is not unusual for a single grammar to be developed by a team including several linguists, computational linguists, and computer scientists.",
        "The scale of grammars is overwhelming – large-scale grammars can be made up by tens of thousands of line of code (Oepen et al.",
        "2000) and may include thousands of types (Copestake and Flickinger 2000).",
        "Modern grammars are written in grammatical formalisms that are often reminiscent of very-high-level, declarative (mostly logical) programming languages, and are thus very similar to computer programs.",
        "This raises problems similar to those encountered in large-scale software development (Erbach and Uszkoreit 1990).",
        "Although whereas software engineering provides adequate solutions for the programmer, grammar engineering is still in its infancy.",
        "In this work we focus on typed unification grammars (TUG), and their implementation in grammar-development platforms such as LKB (Copestake 2002), ALE (Carpenter and Penn 2001), TRALE (Meurers, Penn, and Richter 2002), or Grammix (Müller 2007).",
        "Such platforms conceptually view the grammar as a single entity (even when it is distributed over several files), and provide few provisions for modular grammar development, such as mechanisms for defining modules that can interact with each other through well-defined interfaces, combination of sub-grammars, separate compilation and automatic linkage of grammars, information encapsulation, and so forth.",
        "This is the main issue that we address in this work.",
        "We provide a preliminary yet thorough and well-founded solution to the problem of grammar modularization.",
        "We first specify a set of desiderata for a beneficial solution in Section 1.1, and then survey related work, emphasizing the shortcomings of existing approaches with respect to these desiderata.",
        "Much of the information in typed unification grammars is encoded in the signature, and hence the key is facilitating a modularized development of type signatures.",
        "In Section 2 we introduce a definition of signature modules, and show how two signature modules combine and how the resulting signature module can be extended to a standalone type signature.",
        "We lift our definitions from signatures to full grammar modules in Section 3.",
        "In Section 4 we use signature modules and their combination operators to work out a modular design of the HPSG grammar of Pollard and Sag (1994), demonstrating the utility of signature modules for the development of linguistically motivated grammars.",
        "We then outline MODALE, an implementation of our solutions which supports modular development of type signatures in the context of both ALE and TRALE (Section 5).",
        "We show in Section 6 how our solution complies with the desiderata of Section 1.1, and conclude with directions for future research.",
        "The motivation for modular grammar development is straightforward.",
        "Like software development, large-scale grammar development is much simpler when the task can be cleanly distributed among different developers, provided that well-defined interfaces govern the interaction among modules.",
        "From a theoretical point of view, modularity",
        "1 This article extends and revises Cohen-Sygal and Wintner (2006) and Sygal and Wintner (2008).",
        "Modular Typed Unification Grammars",
        "facilitates the definition of cleaner semantics for the underlying formalism and the construction of correctness proofs.",
        "The engineering benefits of modularity in programming languages are summarized by Mitchell (2003, page 235), and are equally valid for grammar construction:",
        "In an effective design, each module can be designed and tested independently.",
        "Two important goals in modularity are to allow one module to be written with little knowledge of the code in another module and to allow a module to be redesigned and reimplemented without modifying other parts of the system.",
        "A suitable notion of modularity should support \"reuse of software, abstraction mechanisms for information hiding, and import/export relationships\" (Brogi et al.",
        "1994, page 1363).",
        "Similarly, Bugliesi, Lamma, and Mello (1994, page 444) state that",
        "[a] modular language should allow rich forms of abstraction, parametrization, and information hiding; it should ease the development and maintenance of large programs as well as provide adequate support or reusability and separate and efficient compilation; it should finally encompass a non-trivial notion of program equivalence to make it possible to justify the replacement of equivalent components.",
        "In the linguistic literature, however, modularity has a different flavor which has to do with the way linguistic knowledge is organized, either cognitively (Fodor 1983) or theoretically (Jackendoff 2002, pages 218-230).",
        "Although we do not directly subscribe to this notion of modularity in this work, it may be the case that an engineering-inspired definition of modules will facilitate a better understanding of the linguistic notion.",
        "Furthermore, although there is no general agreement among linguists on the exact form of grammar modularity, a good solution for grammar development must not reflect the correctness of linguistic theories but rather provide the computational framework for their implementation.",
        "To consolidate the two notions of modularity, and to devise a solution that is on one hand inspired by developments in programming languages and on the other useful for linguists, a clear understanding of the actual needs of grammar developers is crucial.",
        "A first step in this direction was done by Erbach and Uszkoreit (1990).",
        "In a similar vein, we carefully explored two existing grammars: the LINGO grammar matrix (Bender, Flickinger, and Oepen 2002), which is a framework for rapid development of cross-linguistically consistent grammars; and a grammar of a fragment of modern Hebrew, focusing on inverted constructions (Melnik 2006).",
        "These grammars were chosen since they are comprehensive enough to reflect the kind of data large-scale grammars encode, but are not too large to encumber this process.",
        "Inspired by established criteria for modularity in programming languages, and motivated by our observation of actual grammars, we define the following desiderata for a beneficial solution for (typed unification) grammar modularization:",
        "Signature focus: Much of the information in typed formalisms is encoded by the signature.",
        "This includes the type hierarchy, the appropriateness specification, and the",
        "2 The LINGO grammar matrix is not a grammar per se, but rather a framework for grammar development for several languages.",
        "We focused on its core grammar and several of the resulting, language-specific grammars.",
        "type constraints.",
        "Hence, modularization must be carried out mainly through the distribution of the signature between the different modules.Partiality: Modules should provide means for specifying partial information about the components of a grammar: both the grammar itself and the signature over which it is defined.",
        "Extensibility: Although modules can specify partial information, it must be possible to deterministically extend a module (which can be the result of the combination of",
        "several modules) into a full grammar.",
        "Consistency: Contradicting information in different modules must be detected when",
        "modules are combined.",
        "Flexibility: The grammar designer should be provided with as much flexibility as",
        "possible.",
        "Modules should not be unnecessarily constrained.",
        "(Remote) Reference: A good solution should enable one module to refer to entities defined in another.",
        "Specifically, it should enable the designer of module Mi to use an entity (e.g., a type or a feature structure) defined in Mj without specifying the entity explicitly.",
        "Parsimony: When two modules are combined, the resulting module must include all the information encoded in each of the modules and the information resulting from the combination operation.",
        "Additional information must only be added if it is essential to render the module well-defined.",
        "Associativity: Module combination must be associative and commutative: The order in which modules are combined must not affect the result.",
        "However, this desideratum is not absolute – it is restricted to cases where the combination formulates a simple union of data.",
        "In other cases, associativity and commutativity should be considered with respect to the benefit the system may enjoy if they are abandoned.",
        "Privacy: Modules should be able to hide (encapsulate) information and render it unavailable to other modules.",
        "The solution we advocate here satisfies all these requirements.",
        "It facilitates collaborative development of grammars, where several applications of modularity are conceivable:",
        "• A single large-scale grammar developed by a team.",
        "• Development of parallel grammars for multiple languages under a single theory, as in Bender et al.",
        "(2005), King et al.",
        "(2005), or Müller (2007).",
        "Here, a core module is common to all grammars, and language-specific fragments are developed as separate modules.",
        "• A sequence of grammars modeling language development, for example language acquisition or (historical) language change (Wintner, Lavie, and MacWhinney 2009).",
        "Here, a \"new\" grammar is obtained from a \"previous\" grammar; formal modeling of such operations through module composition can shed new light on the linguistic processes that take place as language develops.",
        "3 We restrict ourselves to standard type signatures (as defined by Carpenter [1992] and Penn [2000]), ignoring type constraints which are becoming common in practical systems.",
        "We defer an extension of our results to type constraints to future work.",
        "Modular Typed Unification Grammars",
        "1.2.1 Modularity in Programming Languages.",
        "Vast literature addresses modularity in programming languages, and a comprehensive survey is beyond the scope of this work.",
        "As unification grammars are in many ways very similar to logic programming languages, our desiderata and solutions are inspired by works in this paradigm.",
        "Modular interfaces of logic programs were first suggested by O'keefe (1985) and Gaifman and Shapiro (1989).",
        "Combination operators that were proved suitable for Prolog include the algebraic operators ® and ® of Mancarella and Pedreschi (1988); the union and intersection operators of Brogi et al.",
        "(1990); the closure operator of Brogi, Lamma, and Mello (1993); and the set of four operators (encapsulation, union, intersection, and import) defined by Brogi and Turini (1995).",
        "For a comprehensive survey, see Bugliesi, Lamma, and Mello (1994).",
        "The 'merge' operator that we present in Section 2.4.2 is closely related to union operations proposed for logic programming languages.",
        "We define no counterpart of intersection-type operations, although such operations are indeed conceivable.",
        "Our 'attachment' operation is more in line with Gaifman and Shapiro (1989).",
        "1.2.2 Initial Approaches: Modularized Parsing.",
        "Early attempts to address modularity in linguistic formalisms share a significant disadvantage: The modularization is of the parsing process rather than the grammar.",
        "Kasper and Krieger (1996) describe a technique for dividing a unification-based grammar into two components, roughly along the syntax/semantics axis.",
        "Their motivation is efficiency; observing that syntax usually imposes constraints on permissible structures, and semantics usually mostly adds structure, they propose to parse with the syntactic constraints first, and apply the semantics later.",
        "This is achieved by recursively deleting the syntactic and semantic information (under their corresponding attributes in the rules and the lexicon) for the semantic and syntactic parsers, respectively.",
        "This proposal requires that a single grammar be given, from which the two components can be derived.",
        "A more significant disadvantage of this method is that coreferences between syntax and semantics are lost during this division (because reentrancies that represent the connection between the syntax and the semantics are removed).",
        "Kasper and Krieger observe that the intersection of the languages generated by the two grammars does not yield the language of the original grammar.",
        "Zajac and Amtrup (2000) present an implementation of a pipeline-like composition operator that enables the grammar designer to break a grammar into sub-grammars that are applied in a sequential manner at run-time.",
        "Such an organization is especially useful for dividing the development process into stages that correspond to morphological processing, syntax, semantics, and so on.",
        "The notion of composition here is such that sub-grammar Gi+1 operates on the output of sub-grammar Gi; such an organization might not be suitable for all grammar development frameworks.",
        "A similar idea is proposed by Basili, Pazienza, and Zanzotto (2000); it is an approach to parsing that divides the task into sub-tasks, whereby a module component Pi takes an input sentence at a given state of analysis Si and augments this information in Si+1 using a knowledge base Ki.",
        "Here, too, it is the processing system, rather than the grammar, which is modularized in a pipeline fashion.",
        "1.2.3 Modularity in Typed Unification Grammars.",
        "Keselj(2001) presents a modular Head-driven Phrase Structure Grammar (HPSG), where each module is an ordinary HPSG grammar, including an ordinary type signature, but each of the sets FEAT,TYPE,and RULES is divided into two disjoint sets of private and public elements.",
        "The public sets consist of those elements that can communicate with elements from corresponding sets in other modules, and private elements are those that are internal to the module.",
        "Merging two modules is then defined by set union; in particular, the type hierarchies are merged by unioning the two sets of types and taking the transitive closure of the union of the two BCPOs (see Definition 2).",
        "The success of the merge of two modules requires that the union of the two BCPOs be a BCPO.",
        "While this work is the first to concretely define signature modules, it provides a highly insufficient mechanism for supporting modular grammar development: The requirement that each module include a complete type hierarchy imposes strong limitations on the kind of information that modules can specify.",
        "It is virtually impossible to specify partial information that is consistent with the complete type hierarchy requirement.",
        "Furthermore, module composition becomes order-dependent as we show in Example 8 (Section 2.4.2).",
        "Finally, the only channel of interaction between modules is the names of the types.",
        "Our work is similar in spirit to Keselj (2001), but it overcomes these shortcomings and complies with the desiderata of Section 1.1.",
        "Kaplan, King, and Maxwell (2002) introduce a system designed for building a grammar by both extending and restricting another grammar.",
        "An LFG grammar is presented to the system in a priority-ordered sequence of files containing phrase-structure rules, lexical entries, abbreviatory macros and templates, feature declarations, and finite-state transducers for tokenization and morphological analysis.",
        "The grammar can include only one definition of an item of a given type with a particular name (e.g., there can be only one NP rule, potentially with many alternative expansions), and items in a file with higher priority override lower priority items of the same type with the same name.",
        "The override convention makes it possible to add, delete, or modify rules.",
        "However, when a rule is modified, the entire rule has to be rewritten, even if the modifications are minor.",
        "Moreover, there is no real concept of modularization in this approach because the only interaction among files is overriding of information.",
        "King et al.",
        "(2005) augment LFG with a makeshift signature to allow modular development of untyped unification grammars.",
        "In addition, they suggest that any development team should agree in advance on the feature space.",
        "This work emphasizes the observation that the modularization of the signature is the key for modular development of grammars.",
        "However, the proposed solution is ad hoc and cannot be taken seriously as a concept of modularization.",
        "In particular, the suggestion for an agreement on the feature space undermines the essence of modular design.",
        "To support rapid prototyping of deep grammars, Bender and Flickinger (2005) propose a framework in which the grammar developer can select pre-written grammar fragments, accounting for common linguistic phenomena that vary across languages (e.g., word order, yes-no questions, and sentential negation).",
        "The developer can specify how these phenomena are realized in a given language, and a grammar for that language is automatically generated, implementing that particular realization of the phenomenon, integrated with a language-independent grammar core.",
        "This framework addresses modularity in the sense that the entire grammar is distributed between several fragments that can be combined in different ways, according to the user's choice.",
        "However, the notion of modularity is rather different here, as modules are pre-written pieces of code which the grammar designer does not develop and whose interaction he or she has little control over.",
        "1.2.4 Modularity in Related Formalisms.",
        "The previously mentioned works emphasize the fact that existing approaches to modular grammar development in the area of unification grammars are still insufficient.",
        "The same problem has also been addressed in some",
        "Modular Typed Unification Grammars",
        "other, related, formalisms; we now survey such works and discuss the applicability of the proposed solutions to the problem of modularity in typed unification grammars.",
        "Wintner (2002) defines the concept of modules for CFGs: The set of nonterminals is partitioned into three disjoint classes of internal, exported,andimported elements.",
        "The imported elements are those that are supplied to the module by other modules, the exported elements are those it provides to the outside world, and the internal ones are local to it.",
        "Two modules can be combined only if the set of internal elements of each module is disjoint from the exported and imported sets of the other module as well as if the exported sets are disjoint.",
        "Then the combination of two modules is done by simple measures of set union.",
        "This is the infrastructure underlying the definition of modular HPSG discussed earlier (Keselj 2001).",
        "Provisions for modularity have also been discussed in the context of tree-adjoining grammars (TAG) (Joshi, Levy, and Takahashi 1975).",
        "A wide-coverage TAG may contain hundreds or even thousands of elementary trees, and syntactic structure can be redundantly repeated in many of them (XTAG Research Group 2001; Abeille, Candito, and Kinyon 2000).",
        "Consequently, maintenance and extension of such grammars is a complex task.",
        "To address these issues, several high-level formalisms were developed (Vijay-Shanker 1992; Candito 1996; Duchier and Gardent 1999; Kallmeyer 2001).",
        "These formalisms take the metagrammar approach, where the basic units are tree descriptions (i.e., formulas denoting sets of trees) rather than trees.",
        "Tree descriptions are constructed bya tree logic and combined through conjunction or inheritance; a module in this approach is merely a tree description, and modules are combined by means of the control logic.",
        "When trees are semantic objects, (i.e., the denotation of tree descriptions), there can be various ways to refer to nodes in the trees in order to control the possible combination of grammar modules.",
        "Several mechanisms have been suggested to facilitate reference across modules (Candito 1996; Perrier 2000; Crabbe and Duchier 2004; Kahane 2006).",
        "The solution that we propose here embraces the idea of moving from concrete objects (e.g., a concrete type signature) to descriptions thereof; but we take special care to do so in a way that maintains the associativity of the main grammar combination operator, in contrast to some earlier approaches (Sygal and Wintner 2009).",
        "Debusmann, Duchier, and Rossberg (2005) introduce Extensible Dependency Grammar (XDG), which is a general framework for dependency grammars that supports modular grammar design.",
        "An XDG grammar consists of dimensions, principles,anda lexicon; it characterizes a set of well-formed analyses.",
        "Each dimension is an attributed labeled graph, and when a grammar consists of multiple dimensions (e.g., multigraphs), they share the same set of nodes.",
        "A lexicon for a dimension is a set of total assignments of nodes and labels.",
        "The main mechanism XDG uses to control analyses are principles, that can be either local (imposing a constraint on the possible analysis of a specific dimension) or multidimensional (constraining the analysis of several dimensions with respect to each other).",
        "In XDG, principles are formulated using a type-system that includes several kinds of elementary types (e.g., nodes, edges, graphs, and even multigraphs) and complex types that are constructed incrementally over the elementary types.",
        "Then, parameters range over types to formulate parametric principles.",
        "A feasible XDG analysis amounts to a labeled graph in which each dimension is a subgraph, such that all (parametric) principles are maintained (this may require nodes in different subgraphs to be identified).",
        "XDG supports modular grammar design where each dimension graph is a grammar module, and module interaction is governed through multidimensional parametric principles.",
        "This work emphasizes the importance of types as a mechanism for modularity.",
        "Our work shares with XDG the use of graphs as the basic components and the use of parameters to enforce interaction among modules.",
        "In both works, each module introduces constraints on the type system and interaction among modules through parameters is used to construct a multigraph in which some of the nodes are identified.",
        "In our approach, however, the type system is part of the grammar specification, and modules are combined via explicit combination operations.",
        "In contrast, in XDG the type mechanism is used externally, to describe objects, and a general description logic is used to impose constraints.",
        "Another major difference has to do with expressive power: Whereas unification grammars are Turing-equivalent, XDG is probably mildly context-sensitive (Debusmann 2006).",
        "The grammar formalism (GF) (Ranta 2007) is a typed functional programming language designed for multilingual grammars.",
        "Ranta introduces a module system for GF where a module can be either one of three kinds: abstract, concrete,oraresource module.",
        "Each of them reflects the kind of data this module may include.",
        "A module of type abstract includes abstract syntax trees which represent grammatical information, such as semantic or syntactic data.",
        "A module of type concrete includes relations between trees in the abstract module and relations between strings in the target language.",
        "Communication between modules of these two types is carried out through inheritance hierarchies similarly to object-oriented programs.",
        "Resource modules are a means for code-sharing, independently of the hierarchies.",
        "The system of modules supports development of multilingual grammars through replacement of certain modules with others.",
        "A given grammar can also be extended by adding new modules.",
        "Additionally, to avoid repetition of code with minor variations, GF allows the grammar writer to define operations which produce new elements.",
        "GF is purposely designed for multilingual grammars which share a core representation, and individual extensions to different languages are developed independently.",
        "As such, the theoretical framework it provides is tailored for such needs, but is lacking where general purpose modular applications are considered (see section 1.1 for examples of such conceivable applications).",
        "Mainly, GF forces the developer to pre-decide on the relations between all modules (through the concrete module and inheritance hierarchies), whereas in an ideal solution the interaction between all modules should be left to the development process.",
        "Each module should be able to independently declare its own interface with other modules; then, when modules combine they may do so in any way that is consistent with the interfaces of other modules.",
        "Furthermore, reference to mutual elements in GF is carried out only through naming, again resulting in a weak interface for module interaction.",
        "Finally, the operations that the grammar writer can define in GF are macros, rather than functions, as they are expanded by textual replacement."
      ]
    },
    {
      "heading": "2.. Modularization of the Signature",
      "text": [
        "We assume familiarity with theories of (typed) unification grammar, as formulated by, for example, Carpenter (1992) and Penn (2000).",
        "The definitions in this section set the notation and recall basic notions.",
        "For a partial function F,T(x)I'('F(x)î') means that F is defined (undefined) for the value x;'F(x) = F(y)' means that either F is defined both for x and for y and assigns them equal values or it is undefined for both.",
        "Definition 1",
        "Given a partially ordered set (P, <},the setof upper bounds of a subset S C P is the set Su = {y e P \\Vx e Sx < y}.",
        "Modular Typed Unification Grammars",
        "For a given partially ordered set (P, <},if S C P has a least element then it is unique, and is denoted min(S).",
        "Definition 2",
        "A partially ordered set (P, <} is a bounded complete partial order (BCPO) iff for every S C P such that Su = 0, Su has a least element, called a least upper bound (lub) and denoted S.",
        "Definition 3",
        "A type hierarchy is a non-empty, finite, bounded complete partial order (TYPE, Q}.",
        "Every type hierarchy (TYPE, Q} always has a least type (written _L), because the subset S = 0 of TYPE has the non-empty set of upper bounds, Su = TYPE, which must have a least element due to bounded completeness.",
        "Definition 4",
        "Let (TYPE, Q} be a type hierarchy and let x, y e TYPE.If x Q y, then x is a supertype of y and y is a subtype of x.If x Q y, x = y andthereisno z such that x Q z Q y and z = x, y then x is an immediate supertype of y and y is an immediate subtype of x.",
        "We follow the definitions of Carpenter (1992) and Penn (2000) in viewing subtypes as greater than their supertypes (hence the least element _ and the notion of lub), rather than the other way round (inducing a glb interpretation), which is sometimes common in the literature (Copestake 2002).",
        "Definition 5",
        "Given a type hierarchy (TYPE, Q} and a finite set of features FEAT,an appropriateness specification is a partial function, Approp :TYPE x F EAT – TYPE such that for every 1.",
        "(Feature Introduction) there is a type Intro(F) e TYPE such that:",
        "• for every t e TYPE,if Approp(t,F)j, then Intro(F) Q t,and",
        "2.",
        "(Upward Closure / Right Monotonocy) if Approp (s, F)j and s Q t, then Approp(t,F)i and Approp(s, F) Q Approp(t, F).",
        "Definition 6",
        "A type signature is a structure (TYPE, Q,FEAT,Approp}, where (TYPE, Q} is a type hierarchy, FEAT is a finite set of features, FEAT and TYPE are disjoint, and Approp is an appropriateness specification.",
        "Again, note that type constraints are not addressed in this work.",
        "We define signature modules (also referred to as modules herein), which are structures that provide a framework for modular development of type signatures.",
        "These structures follow two guidelines.",
        "1.",
        "Signature modules contain partial information about a signature: part of the subtyping relation (sometimes referred to in the literature as type subsumption) and part of the appropriateness specification.",
        "The key here is a move from concrete type signatures to descriptions thereof; rather than specify types, a description is a graph whose nodes denote types and whose arcs denote elements of the subtyping and appropriateness relations of signatures.",
        "2.",
        "Modules may choose which information to expose to other modules and how other modules may use the information they encode.",
        "The denotation of nodes is extended by viewing them as parameters: Similarly to parameters in programming languages, these are entities through which information can be imported to or exported from other modules.",
        "This is done similarly to the way parametric principles are used by Debusmann, Duchier, and Rossberg (2005).",
        "We begin by defining the basic structure of signature modules in Section 2.3.",
        "We then introduce (Section 2.4) two combination operators for signature modules which facilitate interaction and (remote) reference among modules.",
        "We end this section by showing how to extend a signature module into a bona fide type signature (Section 2.5).",
        "The definition of a signature module is conceptually divided into two levels of information.",
        "The first includes all the genuine information that may be encoded by a signature, such as subtyping and appropriateness relations, types, and so forth.",
        "The second level includes the parametric casting of nodes.",
        "This casting is not part of the core of a signature, but rather a device that enables advanced module communication.",
        "Consequently, we define signature modules in two steps.",
        "First, we define partially specified signatures (PSSs), which are finite directed graphs that encode partial information about the signature.",
        "Then, we extend PSSs to signature modules which are structures, based on PSSs, that provide also a complete mechanism for module interaction and (remote) reference.",
        "We assume enumerable, disjoint sets TYPE of types, FEAT of features, and NODES of nodes, over which signatures are defined.",
        "Definition 7",
        "A partially labeled graph (PLG) over TYPE and FEAT is a finite, directed labeled graph P = (Q, T, Ap}, where:",
        "1.",
        "Q C NODES is a finite, nonempty set of nodes.",
        "2.",
        "T : Q – TYPE is a partial function, marking some of the nodes with types.",
        "Modular Typed Unification Grammars",
        "3. dC Q x Q is a relation specifying (immediate) subtyping.",
        "4.",
        "Ap C Q x FEAT x Q is a relation specifying appropriateness.",
        "A partially specified signature (PSS) over TYPE and FEAT is a partially labeled graph P = (Q, T, d, Ap}, where:",
        "5.",
        "T is one to one.",
        "6.",
        "'d' is antireflexive; its reflexive-transitive closure, denoted'd', is antisymmetric.",
        "7.",
        "(Relaxed Upward Closure) for all q1,q[,q2 e Q and F e FEAT,if",
        "A PSS is a finite, directed graph whose nodes denote types and whose edges denote the subtyping and appropriateness relations.",
        "Nodes can be marked by types through the function T, but can also be anonymous (unmarked).",
        "Anonymous nodes facilitate reference, in one module, to types that are defined in another module.",
        "T is one-to-one (item 5), because we require that two marked nodes denote different types.",
        "The'd' relation (item 3) specifies an immediate subtyping order over the nodes, with the intention that this order hold later for the types denoted by nodes.",
        "This is why 'd' is required to be a partial order (item 6).",
        "The type hierarchy of an ordinary type signature is required to be a BCPO, but current approaches (Copestake 2002) relax this requirement to allow more flexibility in grammar design.",
        "Similarly, the type hierarchy of PSSs is partially ordered but this order is not necessarily a bounded complete one.",
        "Only after all modules are combined is the resulting subtyping relation extended to a BCPO (see Section 2.5); any intermediate result can be a general partial order.",
        "Relaxing the BCPO requirement also helps guarantee the associativity of module combination (see Example 8).",
        "Consider now the appropriateness relation.",
        "In contrast to type signatures, Ap is not required to be a function.",
        "Rather, it is a relation which may specify several appropriate nodes for the values of a feature F at a node q (item 4).",
        "The intention is that the eventual value of Approp(T(q),F)bethe lub of the types of all those nodes q' such that Ap(q,F, q').",
        "This relaxation reflects our initial motivation of supporting partiality in modular grammar development, since different modules may specify different appropriate values according to their needs and available information.",
        "After all modules are combined, all the specified values are replaced by a single appropriate value, their lub (see Section 2.5).",
        "In this way, each module may specify its own appropriate values without needing to know the value specification of other modules.",
        "We do restrict the Ap relation, however, by a relaxed version of upward closure (item 7).",
        "Finally, the feature introduction condition of type signatures (Definition 5, item 1) is not enforced by signature modules.",
        "This, again,",
        "4 The fact that the subtyping relation is only extended to a BCPO after all modules are combined implies a lack of incrementality in the system that may be problematic for grammar developers, as modules cannot be tested and evaluated independently.",
        "This situation, however, is not unlike the scenario of programming languages, where modules can typically be developed and compiled, but not tested, independently of a complete system.",
        "results in more flexibility for the grammar designer; the condition can be restored, if it is desirable, after all modules combine (see Section 2.5).",
        "Example 1",
        "A simple PSS P1 is depicted in Figure 1, where solid arrows represent the 'd'(subtyp-ing) relation and dashed arrows, labeled by features, the Ap relation.",
        "P1 stipulates two subtypes of cat, n and v, with a common subtype, gerund.The feature AGR is appropriate for all three categories, with distinct (but anonymous) values for Approp(n, AGR)and Approp(v, AGR).",
        "Approp(gerund, AGR) will eventually be the lub of Approp(n, AGR)and Approp(v, AGR), hence the multiple outgoing AGR arcs from gerund.",
        "Observe that in P1, 'd'isnot aBCPO, Ap is not a function, and the feature introduction condition does not hold.",
        "Definition 8",
        "A pre-signature module over TYPE and FEAT is a structure S = (P,Int,Imp, Exp} where P = (Q, T, d, Ap} isaPLG and:"
      ]
    },
    {
      "heading": "1.. Int C Q is a set of internal types",
      "text": []
    },
    {
      "heading": "2.. Imp C Q is an ordered set of imported parameters",
      "text": []
    },
    {
      "heading": "3.. Exp C Q is an ordered set of exported parameters",
      "text": [
        "5. for all q e Q such that q e Int, T(q)[",
        "We refer to elements of (the sequences) Imp and Exp using indices, with the notation Imp[i], Exp[j], respectively.",
        "A signature module over TYPE and FEAT is a pre-signature module S = (P, Int, Imp, Exp} in which P is a PSS.",
        "Signature modules extend the denotation of nodes by viewing them as parameters: Similarly to parameters in programming languages, parameters are entities through which information can be imported from or exported to other modules.",
        "The nodes of a signature module are distributed among three sets of internal, imported,and exported nodes.",
        "If a node is internal it cannot be imported or exported; but a node",
        "Figure 1",
        "A partially specified signature, P1.",
        "Modular Typed Unification Grammars Figure 2",
        "A signature module, S1.",
        "can be simultaneously imported and exported.",
        "A node which does not belong to any of the sets is called external.",
        "All nodes denote types, but they differ in the way they communicate with nodes in other modules.",
        "As their name implies, internal nodes are internal to one module and cannot interact with nodes in other modules.",
        "Such nodes provide a mechanism similar to local variables in programming languages.",
        "Non-internal nodes may interact with the nodes in other modules: Imported nodes expect to receive information from other modules, while exported nodes provide information to other modules.",
        "External nodes differ from imported and exported nodes in the way they may interact with other modules, and provide a mechanism similar to global variables in programming languages.",
        "Because anonymous nodes facilitate reference, in one module, to information encoded in another module, such nodes cannot be internal.",
        "The imported and exported nodes are ordered in order to control the assignment of parameters when two modules are combined, as will be shown subsequently.",
        "In the examples, the classification of nodes is encoded graphically as follows:",
        "Internal Imported Exported External Example 2",
        "Figure 2 depicts a module S1, based on the PSS of Figure 1.",
        "S1 = (P1,Int1,Imp1,Exp1}, where P1 is the PSS of Figure 1, Int1 = 0, Imp1 = {q4, q5},and Exp1 = 0.",
        "Herein, the metavariable q (with or without subscripts) ranges over nodes, S (with or without subscripts) - over (pre-)signature modules, P (with or without subscripts) over PLGs and PSSs, and Q, T, d, Ap (with the same subscripts) over their constituents.",
        "We introduce two operators for combining signature modules.",
        "The first operator, merge, is a symmetric operation which simply combines the information encoded in the two",
        "5Infact,Imp and Exp can be general sets, rather than lists, as long as the combination operations can deterministically map nodes from Exp to nodes of Imp.",
        "For simplicity, we limit the discussion to the familiar case of lists, where matching elements from Exp to Imp is done by the location of the element on the list, see Definitions 13 and 14.",
        "modules.",
        "The second operator, attachment, is a non-symmetric operation which uses the concept of parameters and is inspired by function composition.",
        "A signature module is viewed as a function whose input is a graph with a list of designated imported nodes and whose output is a graph with a list of designated exported nodes.",
        "When two signature modules are attached, similarly to function composition, the exported nodes of the second module instantiate the imported parameters of the first module.",
        "Additionally, the information encoded by the second graph is added to the information encoded by the first one.",
        "The parametric view of modules facilitates interaction between modules in two channels: by naming or by reference.",
        "Through interaction by naming, nodes marked by the same type are coalesced.",
        "Interaction by reference is achieved when the imported parameters of the calling module are coalesced with the exported nodes of the called module, respectively.",
        "The merge operation allows modules to interact only through naming, whereas attachment facilitates both ways of interaction.",
        "For both of the operators, we assume that the two signature modules are consistent: One module does not include types which are internal to the other module and the two signature modules have no common nodes.",
        "If this is not the case, nodes, and in particular internal nodes, can be renamed without affecting the operation.",
        "Definition 9",
        "We begin by introducing the compactness algorithm which is used when two modules are combined as a mechanism to coalesce corresponding nodes in the two modules.",
        "2.4.1 Compactness.",
        "When two modules are combined, a crucial step in the combination is the identification of corresponding nodes in the two modules that should be coalesced.",
        "Such pairs of nodes can be either of two kinds:",
        "1.",
        "Two typed nodes which are labeled by the same type should be coalesced (along with their attributes).",
        "2.",
        "Two anonymous nodes which are indistinguishable, that is, have isomorphic environments, should be coalesced.",
        "The environment of a node q is the subgraph that includes all the reachable nodes via any kind of arc (from q or to q) up to and including a typed node.",
        "The intuition is that if two anonymous nodes have isomorphic environments, then they cannot be distinguished and therefore should coincide.",
        "Two nodes, only one of which is anonymous, can still be otherwise indistinguishable.",
        "Such nodes will, eventually, be coalesced, but only after all modules are combined (to ensure the associativity of module combination).",
        "Modular Typed Unification Grammars",
        "Additionally, during the combination of modules, some arcs may become redundant (such arcs are not prohibited by the definition of a module).",
        "Redundant arcs can be of two kinds:",
        "1.",
        "A subtyping arc (q1, q2) is redundant if it is a member of the transitive closure of d, where d excludes (q1, q2).",
        "2.",
        "An appropriateness arc (q1,F, q2) is redundant if there exists q3 e Q such that q2 d q3 and (q1, F, q3) e Ap.",
        "(q1, F, q2) is redundant due to the lub intention of appropriateness arcs: The eventual value of Approp(T(q1),F) will be an upper bound of (at least) both q2 and q3.",
        "Because q2 d q3, (q1, F, q2) is redundant.",
        "Redundant arcs encode information that can be inferred from other arcs and therefore may be removed without affecting the data encoded by the signature module.",
        "While our main interest is in signature modules, the compactness algorithm is defined over the more general case of pre-signature modules.",
        "This more general notion will be helpful in the definition of module combination.",
        "Informally, when a pre-signature module is compacted, redundant arcs are removed, nodes marked by the same type are coalesced, and anonymous indistinguishable nodes are identified.",
        "Additionally, the parameters and arities are induced from those of the input pre-signature module.",
        "All parameters may be coalesced with each other, as long as they are otherwise indistinguishable.",
        "If (at least) one of the coalesced nodes is an internal node, then the result is an internal node.",
        "Otherwise, if one of the nodes is imported then the resulting parameter is imported as well.",
        "Similarly, if one of the nodes is exported then the resulting parameter is exported.",
        "Notice that in the case of signature modules, because T is one to one, an internal node may be coalesced only with other internal nodes.",
        "The actual definitions of indistinguishability and the compactness algorithm are mostly technical and are therefore deferred to the Appendix.",
        "We do provide two simple examples to illustrate the general idea.",
        "Example 3",
        "Consider the signature module of Figure 3.",
        "(q1, q4) is a redundant subtyping arc because even without this arc, there is a subtyping path from q1 to q4.",
        "(q1,F, q3)isa redundant appropriateness arc: Eventually the appropriate value of q1 and F should be the lub of q3 and q5,but since q5 is a subtype of q3,itissufficient to requirethatitbeat least q5.",
        "Example 4",
        "Consider S2, the pre-signature module depicted in Figure 4.",
        "Note that S2 is not a signature module (because it includes two nodes labeled by a) and that compactness is defined over pre-signature modules rather than signature modules as this is the case for which it will be used during combination.",
        "In compact(S2), q1 and q2 are coalesced because they are both marked by the type a. Additionally, q3 and q6 are coalesced with q4and q7, respectively, because these are two pairs of anonymous nodes with isomorphic environments.",
        "q5 is not coalesced with q3 and q4 because q5 is typed and q3 and q4 are not, even though they are otherwise indistinguishable.",
        "q8 is not coalesced with q6 and q7 because they are distinguishable: q8 has a supertype marked by a whereas q6 and q7have anonymous supertypes.",
        "Figure 3",
        "A signature module with redundant arcs.",
        "Figure 4",
        "Compactness.",
        "2.4.2 Merge.",
        "The merge operation combines the information encoded by two signature modules: Nodes that are marked by the same type are coalesced along with their attributes.",
        "Nodes that are marked by different types cannot be coalesced and must denote different types.",
        "The main complication arises when two anonymous nodes are considered – such nodes are coalesced only if they are indistinguishable.",
        "The merge of two modules is defined in several stages: First, the two graphs are unioned (this is a simple pointwise union of the coordinates of the graph, see Definition 10).",
        "Then, the resulting graph is compacted, coalescing nodes marked by the same type as well as indistinguishable anonymous nodes.",
        "However, the resulting graph does not necessarily maintain the relaxed upward closure condition, and therefore some modifications are needed.",
        "This is done by Ap-Closure (see Definition 11).",
        "Finally, the addition of appropriateness arcs may turn two anonymous distinguishable nodes into indistinguishable ones and may also add redundant arcs, therefore another compactness step is needed (Definition 12).",
        "Definition 10 two consistent pre-signature modules.",
        "The union of S1 and S2, denoted S1 U S2,isthe pre-signature module (where '•' is the concatenation operator).",
        "Modular Typed Unification Grammars",
        "Definition 11",
        "Let S = ((Q, T, d, Ap},Int,Imp,Exp} be a pre-signature module.",
        "The Ap-Closure of S, denoted ApCl(S), is the pre-signature module ((Q, T, d, Ap'},Int,Imp, Exp} where",
        "Ap-Closure adds to a pre-signature module the required arcs for it to maintain the relaxed upward closure condition: Arcs are added to create the relations between elements separated between the two modules and related by mutual elements.",
        "Notice that Ap C Ap' by choosing q1 = q1.",
        "Two signature modules can be merged only if the resulting subtyping relation is indeed a partial order, where the only obstacle can be the antisymmetry of the resulting relation.",
        "The combination of the appropriateness relations, in contrast, cannot cause the merge operation to fail because any violation of the appropriateness conditions in signature modules can be deterministically resolved.",
        "Note that our specification language does not support inequations; there is no way to specify that two nodes must not be identified with each other.",
        "Such extensions are indeed possible, but are beyond the scope of this work.",
        "Definition 12",
        "If S1 and S2 are mergeable, then their merge, denoted S1 W S2,is:",
        "compact(ApCl(compact(S1 U S2)))",
        "In the merged module, pairs of nodes marked by the same type and pairs of indistinguishable anonymous nodes are coalesced.",
        "An anonymous node cannot be coalesced with a typed node, even if they are otherwise indistinguishable, because that would result in a non-associative combination operation.",
        "Anonymous nodes are assigned types only after all modules combine (see Section 2.5.1).",
        "If a node has multiple outgoing Ap-arcs labeled with the same feature, these arcs are not replaced by a single arc, even if the lub of the target nodes exists in the resulting signature module.",
        "Again, this is done to guarantee the associativity of the merge operation (see Example 9).",
        "Figure 5",
        "Merge: intermediate steps.",
        "Example 5",
        "Let S3 and S4 be the signature modules depicted in Figure 5.",
        "S3 W S4 and the intermediate pre-signature modules are also shown in this figure.",
        "First, S3 and S4 are unioned.",
        "Then, in compact(S3 U S4) the two nodes typed by a are coalesced, as are the nodes typed by c. Notice that this pre-signature module is not a signature module because it does not maintain the relaxed upward closure condition.",
        "To enforce this condition appropriate-nessarcsare addedtoyield ApCl(compact(S3 U S4)), but this signature module includes indistinguishable anonymous nodes and therefore another compactness operation is required to yield the final result.",
        "Example 6",
        "Figure 6 depicts a naive agreement module, S5.",
        "Combined with S1 of Figure 1, S1 W S5 = S5 W S1 = S6.",
        "All dashed arrows are labeled AGR, but these labels are suppressed for readability.",
        "In what follows, by standard convention, Ap arcs that can be inferred by upward closure are not depicted.",
        "Figure 6",
        "Merge.",
        "Modular Typed Unification Grammars",
        "Merge.",
        "Example 7",
        "Let S7 and S8 be the signature modules depicted in Figure 7.",
        "S7 includes general agreement information and S8 specifies detailed values for several specific properties.",
        "Then, S7 W S8 = S8 W S7 = S9.",
        "In this way, the high level organization of the agreement module is encoded by S7,and S8 provides low level details pertaining to each agreement feature individually.",
        "The following example motivates our decision to relax the BCPO condition and defer the conversion of signature modules to BCPOs to a separate resolution stage (Section 2.5).",
        "Example 8",
        "Let S10, S11, S12 be the signature modules depicted in Figure 8.",
        "The merge of S10 with S11results in a non-BCPO.",
        "However, the additional information supplied by S12 resolves the problem, and S10 W S11 W S12 is bounded complete.",
        "Example 9",
        "Let S13, S14, S15 be the signature modules depicted in Figure 9.",
        "In S13 the appropriate value for a and F is b and in S14 it is c. Hence S13 W S14 states that the appropriate value for a and F should be lub(b, c).",
        "Although in this module there is no such element, in S15lub(b, c) is determined to be d.In S13 W S14 W S15 the two outgoing arcs from the node marked by a are not replaced by a single arc whose target is the node marked by d,since",
        "Figure 7 Figure 8",
        "BCPO relaxation.",
        "Figure 9",
        "Merge of signature modules.",
        "other signature modules may specify that the lub of b and c is some type other than d. These multiple outgoing arcs are preserved to maintain the associativity of the merge operation.",
        "Proposition 1",
        "Merge is commutative: For any two signature modules, S1, S2,Let S = S1 W S2 and S' = S2 W S1 where P, P' are their underlying PSSs, respectively.",
        "Then P = P'.",
        "In particular, either both are defined or both are undefined.",
        "The proof follows immediately from the fact that the merge operation is defined by set union and equivalence relations which are commutative operations.",
        "Proposition 2",
        "Merge is associative up to isomorphism: for all S1, S2, S3,Let S = (S1 W S2) W S3 and S' = S1 W (S2 W S3) where P, P' are their underlying PSSs, respectively.",
        "Then P ~ P'.",
        "6 The definition of signature module isomorphism is a simple extension of graph isomorphism; see the Appendix for more details.",
        "S12",
        "d",
        "e",
        "c",
        "O",
        "O",
        "O",
        "\\aAb\\c aAb\\c",
        "a/ \\&",
        "O O O O",
        "o o",
        "O O",
        "Sio W Sn",
        "Sw im",
        "iyj 5i2",
        "d",
        "e",
        "O",
        "O",
        "d e",
        "V/",
        "O O",
        "o",
        "a/ \\",
        "&",
        "o",
        "O O O",
        "O",
        "S13",
        "Si 4",
        "Sl5",
        "a",
        "O-",
        " – O",
        "F",
        "a c",
        "0---0",
        "F",
        "O",
        "o o",
        "Sl3l",
        "D Si4",
        "Sl3 It",
        "J Si 4",
        "W Sis",
        "c O",
        "a",
        " – o",
        "F",
        "---",
        "F",
        "b",
        "O",
        "F",
        "-o-",
        "\\ 6",
        "-*o",
        "F",
        "Modular Typed Unification Grammars",
        "The proof of associativity is similar in spirit to the proof of the associativity of (polarized) forest combination (Sygal and Wintner 2009) and is therefore suppressed.",
        "2.4.3 Attachment.",
        "Consider again S1 and S9, the signature modules of Figures 1 and 7, respectively.",
        "S1 stipulates two distinct (but anonymous) values for Approp(n, AGR) and Approp(v, AGR).",
        "S9 stipulates two nodes, typed nagr and vagr, with the intention that these nodes be coalesced with the two anonymous nodes of S1.",
        "However, the 'merge' operation defined in the previous section cannot achieve this goal, since the two anonymous nodes in S1 have different attributes from their corresponding typed nodes in S9.",
        "In order to support such a unification of nodes we need to allow a mechanism that specifically identifies two designated nodes, regardless of their attributes.",
        "The parametric view of nodes facilitates exactly such a mechanism.",
        "The attachment operation is an asymmetric operation, like function composition, where a signature module, S1, receives as input another signature module, S2.The information encoded in S2 is added to S1 (as in the merge operation), but additionally, the exported parameters of S2 are assigned to the imported parameters of S1 : Each of the exported parameters of S2 is forced to coalesce with its corresponding imported parameter of S1, regardless of the attributes of these two parameters (i.e., whether they are indistinguishable or not).",
        "Definition 13"
      ]
    },
    {
      "heading": "3.. S 1 and S 2 are mergeable",
      "text": [
        "The first condition requires that the number of formal parameters of the calling module be equal to the number of actual parameters in the called module.",
        "The second condition states that if two typed parameters are attached to each other, they are marked by the same type.",
        "If they are marked by two different types they cannot be coalesced.",
        "Finally, the last two conditions guarantee the antisymmetry of the subtyping relation in the resulting signature module: The third condition requires the two signature modules to be mergeable.",
        "The last condition requires that no subtyping cycles be created by the attachment of parameters: If q1 is a supertype of q'1 in S1 and q2 is a supertype of q'2 in S2, then q'2 and q2 cannot be both attached to q1 and q'1, respectively.",
        "Notice that as in the merge operation, two signature modules can be attached only if the resulting subtyping",
        "7 A variant of attachment can be defined in which if two typed parameters, which are attached to each other, are marked by two different types, then the type of the exported node overrides the type of the imported node.",
        "relation is indeed a partial order, where the only obstacle can be the antisymmetry of the resulting relation.",
        "The combination of the appropriateness relations, in contrast, cannot cause the attachment operation to fail because any violation of the appropriateness conditions in signature modules can be deterministically resolved.",
        "Definition 14",
        "• the order of Imp and Exp is induced by the order of Imp1 and Exp1, respectively",
        "When a module S2 is attached to a module S1, all the exported nodes of S2 are first attached to the imported nodes of S1, respectively, through the equivalence relation, '='.",
        "In this way, for each imported node of S1, all the information encoded by the corresponding exported node of S2 is added.",
        "Notice that each equivalence class of '=' contains either one or two nodes.",
        "In the former case, these nodes are either non-imported nodes of S1 or non-exported nodes of S2.",
        "In the latter, these are pairs of an imported node of S1 and its corresponding exported node from S2.",
        "Hence '=' is trivially transitive.",
        "Then, similarly to the merge operation, pairs of nodes marked by the same type and pairs of indistinguishable anonymous nodes are coalesced.",
        "In contrast to the merge operation, in the attachment operation two distinguishable anonymous nodes, as well as an anonymous node and a typed node, can be coalesced.",
        "This is achieved by the parametric view of nodes and the view of one module as an input to another module.",
        "The imported and exported nodes of the resulting module are the equivalence classes of the imported and exported nodes of the first module, S1, respectively.",
        "The nodes of S2 which are neither internal nor exported are classified as external nodes in the resulting module.",
        "This asymmetric view of nodes stems from the view of S1 receiving S2 as input: In this way, S1 may import further information from other modules.",
        "8 Relaxed variants of these conditions are conceivable; for example, one can require \\ Imp-^ \\ < \\ Exp2 \\ rather than \\ Imp1 \\ = \\ Exp2 \\ ;orthat T1 (Imp1 [i]) and T2 (Exp2 [i] ) be consistent rather than equal.",
        "Modular Typed Unification Grammars",
        "Notice that in the attachment operation internal nodes facilitate no interaction between modules, external nodes facilitate interaction only through naming, and imported and exported nodes facilitate interaction both through naming and by reference.",
        "Example 10",
        "Consider again S1 and S9, the signature modules of Figures 1 and 7, respectively.",
        "Let S1a and S9a be the signature modules of Figure 10 (these signature modules have the same underlying graphs as those of S1 and S9, respectively, with different classification of nodes).",
        "Notice that all nodes in both S1a and S9a are non-internal.",
        "Let Imp1a = {q4, q5) and let Exp9a = {p9,p10).",
        "S1a(S9a) is depicted in the same figure.",
        "Notice how q4,q5 are coalesced with p9, p10, respectively, even though q4, q5 are anonymous and p9, p10 are typed and each pair of nodes has different attributes.",
        "Such unification of nodes cannot be achieved with the merge operation.",
        "Attachment.",
        "2.4.4 Example: Parametric Lists.",
        "Lists and parametric lists are extensively used in typed unification-based formalisms, for example in HPSG.",
        "The mathematical foundations for parametric lists were established by Penn (2000).",
        "As an example of the utility of signature modules and the attachment operation, we show how they can be used to construct parametric lists in a straightforward way.",
        "Consider Figure 11.",
        "The signature module List depicts a parametric list module.",
        "It receives as input, through the imported node q3, a node which determines the type of the list members.",
        "The entire list can then be used through the exported node q4.Notice that q2 is an external anonymous node.",
        "Although its intended denotation is the type ne-list, it is anonymous in order to be unique for each copy of the list, as will be shown subsequently.",
        "Now, if Phrase is a simple module consisting of one exported node, of type phrase, then the signature module obtained by List(Phrase) is obtained by coalescing q3, the imported node of List with the single exported node of Phrase.",
        "Other modules can now use lists of phrases; for example, the module Struct uses an imported node as the appropriate value for the feature COMP-DTRS.",
        "Via attachment, this node can be instantiated by List(Phrase)asinStruct(List(Phrase)).",
        "The single node of Phrase instantiates the imported node of List, thus determining a list of phrases.",
        "The entire list is then attached to the signature module Struct, where the root of the list instantiates the imported node typed by phrase-list in Struct.",
        "More copies of the list with other list members can be created by different calls to the module List.",
        "Each such call creates a unique copy of the list, potentially with different types of list elements.",
        "Uniqueness is guaranteed by the anonymity of the node q2 of List: q2 can be coalesced only with anonymous nodes with the exact same attributes, that is, only with nodes whose appropriate value for the feature FIRST is a node typed",
        "Implementing parametric lists with signature modules.",
        "Modular Typed Unification Grammars",
        "by phrase.If q2 would have been typed by neJist it could be coalesced with any other node marked by the same type, such as other such nodes from different copies of the list, resulting in a list whose members have various types.",
        "Observe that the uniqueness of each copy of the list could be achieved also by declaring q2 an internal node, but this solution prevents other modules from referring to this node, as is reasonably desired.",
        "q1(of List)istyped by elist.",
        "Because only one copy of this node is required for all the list copies, there is no problem with typing this node.",
        "Compared with the parametric type signatures of Penn (2000), our implementation of parametric lists is simple and general: It falls out directly as one application of signature modules, whereas the construction of Penn requires dedicated machinery (parametric subtyping, parametric appropriateness, coherence, etc.)",
        "We conjecture that signature modules can be used to simulate parametric type signatures in the general case, although we do not have a proof of such a result.",
        "2.4.5 Example: The 'Addendum' Operator in LKB.",
        "The 'addendum' operator was added to the type definition language of LKB (Copestake 2002) in 2005, to allow the grammar developer to add attributes to an already defined type without the need to repeat previously defined attributes of that type.",
        "The need for such an operation arose as a consequence of the development of frameworks that generate grammars from prewritten fragments (e.g., the LINGO grammar matrix, Bender, Flickinger, and Oepen 2002), since editing of framework-source files may lead to errors.",
        "Signature modules trivially support this operator, either by the merge operation (in which case different attributes of a typed node are gathered from different modules) or by attachment, where attributes can be assigned to a specific node, even without specifying its type.",
        "Signature modules encode only partial information, and are therefore not required to conform with all the constraints imposed on ordinary signatures.",
        "After modules are combined, however, the resulting signature module must be extended into a bona fide signature.",
        "For that purpose we use four algorithms, each of which deals with one property:",
        "1.",
        "Name resolution: This algorithm assigns types to anonymous nodes (Section 2.5.1).",
        "2.",
        "Appropriateness consolidation: This algorithm determinizes Ap, converts it from a relation to a function and enforces upward closure (Section 2.5.2).",
        "3.",
        "Feature introduction completion: This algorithm (whose use is optional) enforces the feature introduction condition.",
        "This is done using the algorithm of Penn (2000).",
        "4.",
        "BCPO completion: This algorithm extends '%'toaBCPO.Again, we use the algorithm of Penn (2000).",
        "9See http://depts.uashington.edu/uucl/tuiki/bin/vieu.cgi/Main/TypeAddendum.",
        "The input to the resolution algorithm is a signature module and its output is a bona fide type signature.",
        "Algorithm 1 (Resolve (S))"
      ]
    },
    {
      "heading": "1.. S : = NameResolution(S)",
      "text": []
    },
    {
      "heading": "4.. S : = ApConsolidate(S)",
      "text": []
    },
    {
      "heading": "5.. S : = FeatureIntroductionCompletion(S)",
      "text": []
    },
    {
      "heading": "8.. S : = ApConsolidate(S)",
      "text": []
    },
    {
      "heading": "9.. return S",
      "text": [
        "The order in which the four algorithms are executed is crucial for guaranteeing that the result is indeed a bona fide signature.",
        "First, the resolution algorithm assigns types to anonymous nodes via the name resolution algorithm (stage 1).",
        "The BCPO completion algorithm (stage 2) of Penn (2000) adds types as least upper bounds for sets of types which have upper bounds but do not have a minimal upper bound.",
        "However, the algorithm does not determine the appropriateness specification of these types.",
        "A natural solution to this problem is to use Ap-Closure (stage 3) but this may lead to a situation in which the newly added nodes have multiple outgoing Ap-arcs with the same label.",
        "To solve the problem, we execute the BCPO completion algorithm before the Ap-consolidation algorithm (stage 4), which also preserves bounded completeness.",
        "Now, the feature introduction completion algorithm (stage 5) of Penn assumes that the subtyping relation is a BCPO and that the appropriateness specification is indeed a function and hence, it is executed after the BCPO completion and Ap-consolidation algorithms.",
        "However, as Penn observes, this algorithm may disrupt bounded completeness and therefore the result must undergo another BCPO completion and therefore another Ap-consolidation (stages 6-8).",
        "A signature module is extended to a type signature after all the information from the different modules have been gathered.",
        "Therefore, there is no need to preserve the classification of nodes and only the underlying PSS is of interest.",
        "However, because the resolution procedure uses the compactness algorithm which is defined over signature modules, we define the following algorithms over signature modules as well.",
        "In cases where the node classification needs to be adjusted, we simply take the trivial classification (i.e., Int = Imp = Exp = 0).",
        "2.5.1 Name Resolution.",
        "During module combination only pairs of indistinguishable anonymous nodes are coalesced.",
        "Two nodes, only one of which is anonymous, can still be otherwise indistinguishable but they are not coalesced during combination to ensure the associativity of module combination.",
        "The goal of the name resolution procedure is to assign a type to every anonymous node, by coalescing it with a typed node with an identical environment, if one exists.",
        "If no such node exists, or if there is more than one such node, the anonymous node is given an arbitrary type.",
        "Modular Typed Unification Grammars",
        "The name resolution algorithm iterates as long as there are nodes to coalesce.",
        "In each iteration, for each anonymous node the set of its typed equivalent nodes is computed (stage 1).",
        "Then, using the computation of stage 1, anonymous nodes are coalesced with their corresponding typed node, if such a node uniquely exists (stage 2.1).",
        "Coalescing all such pairs may result in a signature module that may include indistinguishable anonymous nodes and therefore the signature module is compacted (stage 2.2).",
        "Compactness can trigger more pairs that need to be coalesced, and therefore this procedure is repeated (stage 2.3).",
        "When no pairs that need to be coalesced are left, the remaining anonymous nodes are assigned arbitrary names and the algorithm halts.",
        "We first define NodeCoalesce(S, q, q'): this is a signature module S' that is obtained from S by coalescing q with q'.",
        "Definition 15",
        "The input to the name resolution algorithm is a signature module and its output is a signature module whose typing function, T, is total.",
        "Let S = {{Q, T, %, Ap), Int, Imp, Exp) be a signature module, and let NAMES c TYPE be an enumerable set of fresh types from which arbitrary names can be taken to mark nodes in Q.",
        "The following algorithm marks all the anonymous nodes in S:",
        "1. for all q e Q such that T(q)j, compute Qq = {q' e Q \\ T(q')[ and q' is equivalent to q}.",
        "3.",
        "Mark remaining anonymous nodes in Q with arbitrary unique types from NAMES and halt.",
        "For a given anonymous node, the calculation of its typed equivalent nodes is mostly technical and is therefore suppressed.",
        "Name resolution result for S10.",
        "Example 11",
        "Consider the signature module S6 depicted in Figure 6.",
        "Executing the name resolution algorithm on this module results in the signature module of Figure 12 (AGR-labels are suppressed for readability.)",
        "The two anonymous nodes in S6 are coalesced with the nodes marked nagr and vagr, as per their attributes.",
        "Compare to Figure 1, in particular how two anonymous nodes in S1 are assigned types from S5 (Figure 6).",
        "2.5.2 Appropriateness Consolidation.",
        "For each node q, the set of outgoing appropriateness arcs with the same label F, {(q,F, q')}, is replaced by the single arc (q,F,qi), where qi is marked by the lub of the types of all q'.Ifno lub exists, a new node is added and is marked by the lub.",
        "The result is an appropriateness relation which is a function, and in which upward closure is preserved; feature introduction is dealt with separately.",
        "The input to the following procedure is a signature module whose typing function, T, is total; its output is a signature module whose typing function is total and whose appropriateness relation is a function that maintains upward closure.",
        "Let S = ((Q, T, d, Ap),Int,Imp,Exp) be a signature module.",
        "For each q e Q and F e FEAT,let",
        "Algorithm 3 (ApConsolidate (S 1.",
        "2.",
        "Find a node q and a feature F for which ltarget(q,F)| > 1and forall q' e Q such that q' d q, ^arget(q', F^< 1(i.e., q is a minimal node with respect to a topological ordering of Q).",
        "If no such pair exists, halt 3.",
        "If target(q, F)has a lub, p, then:",
        "for all q' e target(q, F), remove the arc (q, F, q')from Ap add the arc (q, F,p)to Ap",
        "Modular Typed Unification Grammars",
        "Otherwise, If target(q, F)has no lub, add a new node, p,to Q with:",
        "Mark p with a fresh type from NAMES For all q' e target(q, F), remove the arc (q, F, q')from Ap Add (q, F,p)to Ap",
        "The order in which nodes are selected in step 2 of the algorithm is from supertypes to subtypes.",
        "This is done to preserve upward closure.",
        "When a set of outgoing appropriateness arcs with the same label F, {(q,F, q')}, is replaced by a single arc (q,F,ql), all the subtypes of all q' are added as subtypes of ql (stage 3c).",
        "This is done to maintain the upwardly closed intention of appropriateness arcs (see Example 13).",
        "Additionally, ql is added as an appropriate value for F and all the subtypes of q.",
        "This is achieved by the Ap-Closure operation (stage 5).",
        "Again, this is done to preserve upward closure.",
        "If a new node is added (stage 3), then its subtypes are inherited from its immediate supertypes.",
        "Its appropriate features and values are also inherited from its immediate supertypes through the Ap-Closure operation (stage 5).",
        "In both stages 3 and 4, a final step is compaction of the signature module in order to remove redundant arcs.",
        "Example 12",
        "Consider the signature module depicted in Figure 12.",
        "Executing the appropriateness consolidation algorithm on this module results in the module depicted in Figure 13.",
        "Example 13",
        "Consider the signature modules depicted in Figure 14.",
        "Executing the appropriateness consolidation algorithm on S16, the two outgoing arcs from a labeled with F are first replaced by a single outgoing arc to a newly added node, new1, which is the lub of b and c. During this first iteration, new1isalsoaddedasasupertypeof e and f .The result of these operations is S17.Noticethatin S16,the arc (a, F, b) is interpreted as \"the appropriate value of a and F is at least b.\"",
        "In particular, this value may be e. S17 maintains",
        "Appropriateness consolidation: result.",
        "Appropriateness consolidation.",
        "this interpretation by means of the subtyping arc that is added from new1toe.",
        "Then, the two outgoing arcs from d labeled with F (to e and f ) are replaced by a single outgoing arc to a newly added node, new2, which is the lub of e and f. The result of these operations is S18, which is also the final result."
      ]
    },
    {
      "heading": "3.. Grammar Modules",
      "text": [
        "Before extending signature modules to grammar modules, we first recall basic notions of typed unification grammars.",
        "For the following definitions we assume that a type signature (TYPE, E,FEAT, Approp) has been specified.",
        "Definition 16",
        "A path is a finite sequence of features, and the set PATHS = FEAT* is the collection of paths.",
        "e is the empty path.",
        "Definition 17",
        "A typed pre-feature structure (pre-TFS) is a triple (n, G, ix) where:",
        "• n C PATHS is a non-empty set of Paths",
        "• G : n – TYPE is a total function, assigning a type for all paths",
        "• txC n x n is a relation specifying reentrancy",
        "A typed feature structure (TFS) is a pre-TFS A = (n, G, tx) for which the following requirements hold:",
        "• n is prefix-closed: if na e n then n e n (where n, a e PATHS)",
        "• A is fusion-closed: if na e n and n tx n' then n'a e n and na tx rta",
        "• <x\\ is an equivalence relation with a finite index (with [cxi]the setofits equivalence classes) including at least the pair (e,e)",
        "• G respects the equivalence: if n cx n2 then G(n1) = G(n2)",
        "Modular Typed Unification Grammars",
        "Definition 18",
        "ATFS A = (n, G, >3) is well-typed iff whenever n e n and F e Feat are such that nF e n, then Approp(G(n),F)j,and Approp(G(n),F) C G(nF).",
        "A grammar is defined over a concrete type signature and is a structure including a set of rules (each constructed from a series of TFSs), a lexicon mapping words to sets of TFSs and a start symbol which is a TFS.",
        "We are now ready to define grammar modules and the way in which they interact.",
        "A grammar module is a structure M = (S, G), where S is a signature module and G is a grammar.",
        "The grammar is defined over the signature module analogously to the way ordinary grammars are defined over type signatures, albeit with two differences:",
        "1.",
        "TFSs are defined over type signatures, and therefore each path in the TFS is associated with a type.",
        "When TFSs are defined over signature modules this is not the case, because signature modules may include anonymous nodes.",
        "Therefore, the standard definition of TFSs is modified such that every path in a TFS is assigned a node in the signature module over which it is defined, rather than a type.",
        "2.",
        "Enforcing all TFSs in the grammar to be well-typed is problematic for three reasons:",
        "(a) Well-typedness requires that G(nF) be an upper bound of all the (target) nodes which are appropriate for G(n)andF.",
        "However, each module may specify only a subset of these nodes.",
        "The whole set of target nodes is known only after all modules combine.",
        "(b) A module may specify several appropriate values for G(n)andF, but it may not specify any upper bound for them.",
        "(c) Well-typedness is not preserved under module combination.",
        "The natural way to preserve well-typedness under module combination requires addition of nodes and arcs, which would lead to a non-associative combination.",
        "To solve these problems, we enforce only a relaxed version of well typedness.",
        "The relaxation is similar to the way upward closure is relaxed: Whenever G(n) = q, G(nF)isrequiredtobeasubtypeofone of the values q' such that (q, F, q' ) e Ap.",
        "This relaxation supports the partiality and associativity requirements of modular grammar development (Section 1.1).",
        "After all modules are combined, the resulting grammar is extended to maintain well-typedness.",
        "The two combination operators, merge and attachment, are lifted from signature modules to grammar modules.",
        "In both cases, the components of the grammars are combined using simple set union.",
        "This reflects our initial observation (Section 1.1) that most of the information in typed formalisms is encoded by the signature, and therefore modularization is carried out mainly through the distribution of the signature between the different modules; the lifting of the signature combination operation to operations on full grammar modules is therefore natural and conservative.",
        "The main fragments of the signature.",
        "A signature module, Sign.",
        "Finally, grammar modules are extended to bona fide typed unification grammars by extending the underlying signature module into an ordinary type signature and adjusting the grammar accordingly."
      ]
    },
    {
      "heading": "4.. Modular Construction of the Basic HPSG Signature",
      "text": [
        "To demonstrate the utility of signature modules for practical grammar engineering we use signature modules and their combination operators in this section to work out a modular design of the HPSG grammar of Pollard and Sag (1994).",
        "This is a grammar of English whose signature, covering several aspects of syntax and semantics, is developed throughout the book.",
        "The signature is given (Pollard and Sag 1994, Appendix A1) as one unit, making it very hard to conceptualize and, therefore, to implement and maintain.",
        "We reverse-engineered this signature, breaking it up into smaller-scale modules that emphasize fragments of the theory that are more local, and the interactions among such fragments through 'merge' and 'attachment'.",
        "Some of the fragments make use of the signature module List of Figure 11.",
        "10 In practice, an extra adjustment is required in order to restore well-typedness, but we suppress this technicality.",
        "11 Of course, other ways to break up the given signature to modules are conceivable.",
        "In particular, the Synsem module of Figure 19 may better be broken into two modules.",
        "sign",
        "mod_synsem",
        "head",
        "category",
        "con_struc",
        "local",
        "non_local",
        "O",
        "O",
        "\\ Î",
        "__",
        "object",
        "[Object",
        "word phrase con_struct",
        "o 0----0",
        "\\ i DTRS",
        "\\.siqn synsem \\ V SYNSEM y",
        "4>o------* o",
        "A\" % ^A",
        "quanti jier_list phonestring _list",
        "Sign",
        "Imp = (phonstringJList, quantifier_list) Exp = {phrase)",
        "Modular Typed Unification Grammars",
        "We begin with a module defining objects (Figure 15), where the type object is the most general type.",
        "This module defines the main fragments of the signature.",
        "Figure 16 defines the module Sign.",
        "It consists of the type sign, and its two subtypes word and phrase.",
        "The latter is exported and will be used by other modules, as we presently show.",
        "In addition, two of the appropriate features of sign are lists; note that the values of PHON and RETRIEVED are imported.",
        "Next, we consider constituent structure, and in particular headed structures, in Figure 17.",
        "Note in particular that the feature COMP-DTRS, defined at headstruc, takes as values a list of phrases; this is an imported type, which is obtained as a result of several attachment operations (Figure 11).",
        "Figure 18 describes the fragment of the signature rooted by head.",
        "This is basically a specification of the inventory of syntactic categories defined by the theory.",
        "Note how simple it is to add, remove, or revise a category by accessing this fragment only.",
        "Figure 19 provides straightforward definitions of category and synsem, respectively.",
        "As another example, Figure 20 depicts the type hierarchy of nominal objects, which is completely local (in the sense that it does not interact with other modules, except at the root).",
        "Finally, Figure 21 abstracts over the internal structure of Phonstring and",
        "ConStruc",
        "Imp = (phrase_list)",
        "Phrase structure.",
        "[Head Figure 18",
        "A signature module, Head.",
        "Signature modules.",
        "Quantifier; these are only representatives of the actual signature modules which define these fragments.",
        "The full HPSG signature consists of several more fragments that we do not depict here.",
        "With this in mind, the HPSG signature can now be constructed in a modular way from the fragments defined earlier.",
        "The construction is given in Figure 22.",
        "First, we produce two lists of phonestring and quantifier, which are merged into one module through the operation List (Phonestring) V3 List (Quantifier)",
        "Then, this module instantiates the two imported nodes phonestring-list and quantifier-list in the module Sign through the operation Sign(List(Phonestring) V3 List (Quantifier))",
        "Notice how the order of the parameters ensures the correct instantiation.",
        "Now, in the second element, List(Sign) both creates a list of phrase (since phrase is an exported",
        "1",
        "local nonlocal",
        "synsem_list head marking",
        "A o o",
        "<sy\\ < i / ^",
        "category",
        "o o",
        "none c /\\<o",
        "o",
        "mod_synsem",
        "Cat",
        "Synsem",
        "Modular Typed Unification Grammars reflrecp nom,_obj index index",
        "NomObj Figure 20",
        "A classification of nominal objects.",
        "Parametric signature modules.",
        "Sign(List(Phonestring)IMJList(Quantifier))",
        "ConStruc(List(Sign))",
        "Cat(List(Synsem)) _NomObj_",
        "HPSG signature construction.",
        "node in the module Sign) and unifies the information in the two modules.",
        "Similarly, ConStruc(List(Sign)) unifies the information in the three modules and instantiates the node phrase-list in the module ConStruc.",
        "In the same way, List(Synsem) both creates a list of synsem (since synsem is an exported node in the module Synsem) and unifies the information in the two modules.",
        "Then, Cat(List(Synsem)) unifies the information in the three modules and instantiates the node synsem Jist in the module Cat.",
        "Finally, all the information from the different modules is unified through the merge operation.",
        "Other modules can be added, either by merge or by attachment.",
        "Additionally, the internal structure of each module can be locally modified.",
        "Such changes become much easier given the smaller size and theoretical focus of each of the modules.",
        "This modular approach has significant advantages over the monolithic approach of Pollard and Sag (1994): The signature of Pollard and Sag is hard to conceptualize because all the information is presented in a single hierarchy.",
        "In contrast, looking at each small fragment (module) separately, it is easier to understand the information encoded in the module.",
        "Contemporary type signatures are in fact much larger; working with small fragments in such grammars is instrumental for avoiding or tracking errors.",
        "Moreover, grammar maintenance is significantly simplified, because changes can be done locally, at the level of specific modules.",
        "Of course, when a new grammar is developed from scratch, modularization can be utilized in such a way as to reflect independent fragments of the linguistic theory in separate modules.",
        "phonstring",
        "quantifier",
        "o",
        "o",
        "Phonstring",
        "Quantifier",
        "While the grammar of Pollard and Sag (1994) is not really large-scale, it is large enough to reflect the kind of knowledge organization exhibited by linguistically motivated grammars, but is at the same time modest enough so that its redesign in a modular way can be easily comprehended.",
        "It is therefore useful as a practical example of how type signatures can be constructed from smaller, simpler signature modules.",
        "Real-world grammars are not only much larger, they also tend to be more complex, and in particular express interactions in domains other than the type signature (specifically, as type constraints and as phrase-structure rules).",
        "Extending our solution to such interactions is feasible, but is beyond the scope of this preliminary work.",
        "5.",
        "MODALE: A Platform for Modular Development of Type Signatures",
        "Two leading implementation platforms are available for the development of typed unification grammars: The Linguistic Knowledge Building system (LKB) (Copestake 2002) and TRALE (Meurers, Penn, and Richter 2002), an extension of the Attribute Logic Engine (ALE) (Carpenter and Penn 2001).",
        "MODALE (MODular ALE) is a system that supports modular development of type signatures in both ALE and TRALE.",
        "The main features of the system are:",
        "• The system provides a description language with which signature modules can be specified.",
        "The description language is intuitive and is built upon the description language of ALE.",
        "For example, the description of S1, the signature module of Figure 2, is shown in Figure 23.",
        "• Signature modules may be combined using either one of the two combination operators, merge and attachment, or by a complex combination involving several operators.",
        "• Signature modules can be resolved to yield bona fide type signatures.",
        "• The system compiles resolved modules into output files using either ALE or TRALE syntax; these files can be directly manipulated by one of the two systems.",
        "• Signature modules can be printed using the syntax of the description language.",
        "This feature allows inspection of a signature module that was created as a result of several combination operators.",
        "ALE and TRALE share the same underlying core, and are based on data structures and algorithms that take advantage of type signature properties such as bounded completeness, upward closure, and feature introduction, none of which can be assumed when working with a signature module.",
        "As a result, our implementation is not a direct adaption of the existing ALE /TRALE code, but a new system that was developed from",
        "Modular Typed Unification Grammars",
        "module(SI){ cat sub [n,v].",
        "n sub [gerund].",
        "n approp [agr:{anon(q5) } ] .",
        "gerund sub [] .",
        "gerund approp [agr:{anon(q4) ,anon(q5) }] .",
        "v sub [gerund].",
        "v approp [agr:{anon(q4)}].",
        "agr sub [anon(q4),anon(q5)].",
        "int=<>.",
        "imp=<anon(q4),anon(q5)>.",
        "exp=<>.",
        "MODALE description of S1.",
        "scratch.",
        "Extending the algorithms of Penn (2000) from type signatures into signature modules is left as a direction for future research.",
        "The MODALE system provided us with an opportunity to experimentally evaluate the time efficiency of module combination.",
        "Indeed, the combination and resolution algorithms are computationally inefficient as they require repeated calculations of graph isomorphism, a problem which is neither known to be solvable in polynomial time nor NP-complete.",
        "However, in the signatures we have experimented with so far, we encountered no time issues.",
        "Furthermore, it is important to note that these calculations are executed only once, in compile time, and have no impact on the run time of ALE/TRALE, which is the crucial stage in which efficiency is concerned."
      ]
    },
    {
      "heading": "6.. Discussion and Conclusions",
      "text": [
        "We presented a complete definition of typed unification grammar modules and their interaction.",
        "Unlike existing approaches, our solution is formally defined, mathematically proven, can be easily and efficiently implemented, and conforms to each of the desiderata listed in Section 1.1, as we now show.",
        "Signature focus: Our solution focuses on the modularization of the signature (Section 2), and the extension to grammar modules (Section 3) is natural and conservative.",
        "We do restrict ourselves in this work to standard type signatures without type constraints.",
        "We defer the extension of type signatures to include also type constraints to future work.",
        "Partiality: Our solution provides the grammar developer with means to specify any piece of information about the signature.",
        "A signature module may specify only partial information about the subtyping and appropriateness relations.",
        "Furthermore, the appropriateness relation is not a function as in ordinary signatures, and",
        "12 Garey and Johnson (1979) provide a list of 12 major problems whose complexity status was open at the time of writing.",
        "Recognition of graph isomorphism is one of those, and one of the only two whose complexity remains unresolved today.",
        "the developer may specify several appropriate nodes for the values of a feature F at a node q.",
        "The anonymity of nodes and relaxed upward closure also provide means for partiality.",
        "Another relaxation that supports partiality is not enforcing feature introduction and the BCPO conditions.",
        "Finally, the possibility of distributing the grammar between several modules and the relaxation of well-typedness also support this desideratum.",
        "Extensibility: In Section 2.5 we show how a signature module can be deterministically extended into a bona fide signature.",
        "Consistency: When modules are combined, either by merge or by attachment, the signature modules are required to be mergeable or attachable, respectively.",
        "In this way, contradicting information in different modules is detected prior to the combination.",
        "Notice that two signature modules can be combined only if the resulting subtyping relation is indeed a partial order.",
        "Flexibility: The only restrictions we impose on modules are meant to prevent subtyping cycles.",
        "(Remote) Reference: This requirement is achieved by the parametric view of nodes.",
        "Anonymity of nodes also supports this desideratum.",
        "Parsimony: When two modules are combined, they are first unioned; thus the resulting module includes all the information encoded in each of the modules.",
        "Additional information is added in a conservative way by compaction and Ap-closure in order to guarantee that the resulting module is indeed well-defined.",
        "Associativity: We provide two combination operations, merge and attachment.Theat-tachment operation is an asymmetric operation, such as the function application, and therefore associativity is not germane.",
        "The merge operation, which is symmetric, is both commutative and associative and therefore conforms with this desideratum.",
        "Privacy: Privacy is achieved through internal nodes which encode information that other modules cannot view or refer to.",
        "Modular construction of grammars, and of type signatures in particular, is an essential requirement for the maintainability and sustainability of large-scale grammars.",
        "We believe that our definition of signature modules, along with the operations of merge and attachment, provide grammar developers with powerful and flexible tools for collaborative development of natural language grammars, as demonstrated in Section 4.",
        "Modules provide abstraction; for example, the module List of Figure 11 defines the structure of a list, abstracting over the type of its elements.",
        "In a real-life setting, the grammar designer must determine how to abstract away certain aspects of the developed theory, thereby identifying the interaction points between the defined module and the rest of the grammar.",
        "A first step in this direction was done by Bender and Flickinger (2005); we believe that we provide a more general, flexible, and powerful framework to achieve the full goal of grammar modularization.",
        "This work can be extended in various ways.",
        "First, this work focuses on the modularity of the signature.",
        "This is not accidental, and reflects the centrality of the type signature in typed unification grammars.",
        "An extension of signature modules to include also type constraints is called for and will provide a better, fuller solution to the problem of grammar modularization.",
        "In a different track, we also believe that extra modularization capabilities can still be provided by means of the grammar itself.",
        "This direction is left for future research.",
        "Although the present work is mainly theoretical, it has important practical implications.",
        "An environment that supports modular construction of large-scale grammars will",
        "Modular Typed Unification Grammars",
        "greatly contribute to grammar development and will have a significant impact on practical implementations of grammatical formalisms.",
        "The theoretical basis we presented in this work was implemented as a system, MODALE, that supports modular development of type signatures (Section 5).",
        "Once the theoretical basis is extended to include also type constraints, and they, as well as grammar modules, are fully integrated in a grammar development system, immediate applications of modularity are conceivable (see Section 1.1).",
        "Furthermore, although there is no general agreement among linguists on the exact form of modularity in grammar, a good modular interface will provide the necessary infrastructure for the implementation of different linguistic theories and will support their comparison in a common platform.",
        "Finally, our proposed mechanisms clearly only fill very few lacunae of existing grammar development environments, and various other provisions will be needed in order for grammar engineering to be as well-understood a task as software engineering now is.",
        "We believe that we make a significant step in this crucial journey.",
        "We provide a formal definition of the compactness algorithm in this section.",
        "For an example of the following two definitions see Example 3.",
        "Definition 19",
        "Let S = ((Q, T, d, Ap),Int,Imp, Exp) be a pre-signature module.",
        "(q1, q2) ed is a redundant subtyping arc if there exist p1,..., pn e Q, n > 1, such that q1 d p1 d p2 d ... d pn d q2.",
        "Definition 20",
        "Let P = ((Q, T, d, Ap),Int,Imp,Exp) be a pre-signature module.",
        "(q1,F,q2) e Ap is a redundant appropriateness arc if there exists q2 e Q such that q2 d q'2, q2 = q'2_ and (q1, F, q2) e Ap.",
        "The following definitions set the basis for determining whether two nodes are indistinguishable or not.",
        "Because signature modules are just a special case of directed, labeled graphs, we can adapt the well-defined notion of graph isomorphism to pre-signature modules.",
        "Informally, two pre-signature modules are isomorphic when their underlying PSSs have the same structure; the identities of their nodes may differ without affecting the structure.",
        "In our case, we require also that an anonymous node be mapped only to an anonymous node and that two typed nodes, mapped to each other, be marked by the same type.",
        "However, the classification of nodes as internal, imported, and/or exported has no effect on the isomorphism since it is not part of the core of the information encoded by the signature module.",
        "Definition 21",
        "Two pre-signature modules S1 = ((Q1,T1,d1,Ap1),Int1,Imp1,Exp1), S2 = ((Q2,T2,d2, Ap2),Int2, Imp2, Exp2) are isomorphic, denoted S1~S2, if there exists a total, one-to-one and onto function i (isomorphism) mapping the nodes of S1 to the nodes of S2, such that all the following hold:",
        "The environment of a node q is the set of nodes accessible from q via any sequence of arcs (subtyping or appropriateness, in any direction), up to and including the first typed node.",
        "The environment of a typed node includes itself only.",
        "Definition 22",
        "Let S = ((Q, T, d, Ap),Int,Imp,Exp) be a pre-signature module.",
        "For all q e Q let the environment of q, denoted env(q), be the smallest set such that:",
        "Definition 23",
        "Let S = ((Q,T,d,Ap),Int,Imp,Exp) be a pre-signature module and let Q' C Q.The strict restriction of S to Q', denoted S\\Q\"ct,is ((QQ', T2, d2, Ap2),Int2,Imp2, Exp2), where:",
        "The strict restriction of a pre-signature module, S,toasetofnodesQ',isthe subgraph induced by the nodes of Q' without any labeled or unlabeled arcs connecting two typed nodes in Q'.",
        "Definition 24",
        "Let S = ((Q, T, d, Ap),Int,Imp,Exp) be a pre-signature module.",
        "Two nodes q1,q2 e Q are indistinguishable, denoted q1 « q2,if S l^fq^ S \\eni'rvfq2) via an isomorphism i such that i(q1) = q2.",
        "Example 14",
        "Let S1 be the signature module of Figure A1",
        "The strict restrictions of S1 to these environments are depicted in Figure A2.",
        "q2 « q4 and q6 « q7, where in both cases the isomorphism is",
        "Modular Typed Unification Grammars",
        "A signature module with indistinguishable nodes, S1.",
        "Strict restriction subgraphs.",
        "However, q5 is distinguishable from q2 and q4 because T(q8) = T(q6)and T(q8) = T(q7).",
        "Notice also that q3 is distinguishable from q2, q4 and q5 because it has no outgoing appropriateness arcs.",
        "Proposition 3",
        "Let S = ((Q, T, d, Ap), Int,Imp, Exp) be a pre-signature module.",
        "Then is an equivalence relation over Q.",
        "Definition 25",
        "A pre-signature module S = ((Q, T, d, Ap),Int,Imp,Exp) is non-redundant if it includes no redundant subtyping and appropriateness arcs and for all qi, q2 £ Q, q\\ « q2implies qi = q2.",
        "Definition 26",
        "Let S = ((Q, T, d, Ap),Int,Imp,Exp) be a pre-signature module.",
        "The coalesced pre-signature module, denoted coalesce(S), is ((Qi, T\\, di, Ap\\),Inti,Impi, Expi) where:",
        "• Qi = {[q]» I q £ Q} (Qi is the set of equivalence classes with respect to «)",
        "C I strict _e 1strict",
        "Dl \\env(q2) – °1 \\env(qe)",
        "q I strict q {strict Jl \\env(qi) – Dl \\env(q7)",
        "Q {strict Dl \\env(qr,)",
        "q {strict Dl \\env(qi)",
        "b",
        "a",
        "©",
        "©",
        "©",
        "©",
        "t",
        "t",
        "t",
        "i F i",
        "i F i",
        "i F i",
        "©",
        "©",
        "©",
        "t",
        "t",
        "t",
        "©",
        "©",
        "©",
        "a",
        "a",
        "a",
        "• the order of Impi and Expi is induced by the order of Imp and Exp, respectively, with recurring elements removed",
        "When a pre-signature module is coalesced, indistinguishable nodes are identified.",
        "Additionally, the parameters and arities are induced from those of the input pre-signature module.",
        "All parameters may be coalesced with each other, as long as they are otherwise indistinguishable.",
        "If (at least) one of the coalesced nodes is an internal node, then the result is an internal node.",
        "Otherwise, if one of the nodes is imported then the resulting parameter is imported as well.",
        "Similarly, if one of the nodes is exported then the resulting parameter is exported.",
        "The input to the compactness algorithm is a pre-signature module and its output is a non-redundant signature module which encodes the same information.",
        "1.",
        "LetSi = ((Qi,Ti,di,Api),Inti,Impi,Expi) besuchthat:",
        "• Api = {(qi, F, q2) £ Ap I (qi, F, q2) is a non-redundant appropriateness arc in S}",
        "• Inti = Int",
        "• Impi = Imp",
        "• Expi = Exp",
        "3.",
        "If S' is non-redundant, return S', otherwise return compact(S')",
        "The compactness algorithm iterates as long as the resulting pre-signature module includes redundant arcs or nodes.",
        "In each iteration, all the redundant arcs are first removed and then all indistinguishable nodes are coalesced.",
        "However, the identification of nodes can result in redundant arcs or can trigger more nodes to be coalesced.",
        "Therefore, the process is repeated until a non-redundant signature module is obtained.",
        "Notice that the compactness algorithm coalesces pairs of nodes marked by the same type regardless of their incoming and outgoing arcs.",
        "Such pairs of nodes may exist in a pre-signature module (but not in a signature module).",
        "Example 15",
        "Consider again Si, the signature module of Figure Ai.",
        "The compacted signature module of Si is depicted in Figure A3.",
        "Notice that Si has no redundant arcs to be removed and",
        "Modular Typed Unification Grammars",
        "The compacted signature module of Si.",
        "A compactness example.",
        "that q2 and q6 were coalesced with q4 and q7, respectively.",
        "All nodes in compact(Si)are pairwise distinguishable and no arc is redundant.",
        "Example 16",
        "Consider S2, S3, S4, S5, the signature modules depicted in Figure A4.",
        "Executing the compactness algorithm on S2, first the redundant subtyping arc from qi to q6 is removed, resulting in S3 which has no redundant arcs.",
        "Then, q2 and q3 are coalesced, resulting in S4.In S4, {q2, q3}«{q4} and {q5}«{q6}, and after coalescing these two pairs, the result is S5 which is non-redundant.",
        "Proposition 4",
        "The compactness algorithm terminates.",
        "Proposition 5",
        "The compactness algorithm is deterministic: it always produces the same result.",
        "Proposition 6",
        "If S is a signature module then compact(S) is a non-redundant signature module.",
        "Proposition 7",
        "If S is a non-redundant signature module then compact(S) ~ S.",
        "Acknowledgments",
        "This research was supported by the Israel Science Foundation (grants i36/0i, i37/06).",
        "We are grateful to Nurit Melnik and Gerald Penn for extensive discussions and constructive feedback, and to the CL reviewers for detailed, useful comments.",
        "All remaining errors are, of course, our own."
      ]
    }
  ]
}
