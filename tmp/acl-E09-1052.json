{
  "info": {
    "authors": [
      "Alexander Koller",
      "Alex Lascarides"
    ],
    "book": "EACL",
    "id": "acl-E09-1052",
    "title": "A Logic of Semantic Representations for Shallow Parsing",
    "url": "https://aclweb.org/anthology/E09-1052",
    "year": 2009
  },
  "references": [
    "acl-C04-1185",
    "acl-D07-1071",
    "acl-P06-4020",
    "acl-W07-1210"
  ],
  "sections": [
    {
      "text": [
        "Saarland University Saarbrücken, Germany koller@mmci.uni-saarland.de",
        "One way to construct semantic representations in a robust manner is to enhance shallow language processors with semantic components.",
        "Here, we provide a model theory for a semantic formalism that is designed for this, namely Robust Minimal Recursion Semantics (rmrs).",
        "We show that rmrs supports a notion of entailment that allows it to form the basis for comparing the semantic output of different parses of varying depth."
      ]
    },
    {
      "heading": "1. Introduction",
      "text": [
        "Representing semantics as a logical form that supports automated inference and model construction is vital for deeper language engineering tasks, such as dialogue systems.",
        "Logical forms can be obtained from hand-crafted deep grammars (Butt et al., 1999; Copestake and Flickinger, 2000) but this lacks robustness: not all words and constructions are covered and by design ill-formed phrases fail to parse.",
        "There has thus been a trend recently towards robust wide-coverage semantic construction (e.g., (Bos et al., 2004; Zettlemoyer and Collins, 2007)).",
        "But there are certain semantic phenomena that these robust approaches don't capture reliably, including quantifier scope, optional arguments, and long-distance dependencies (for instance, Clark et al.",
        "(2004) report that the parser used by Bos et al.",
        "(2004) yields 63% accuracy on object extraction; e.g., the man that I met...).",
        "Forcing a robust parser to make a decision about these phenomena can therefore be error-prone.",
        "Depending on the application, it may be preferable to give the parser the option to leave a semantic decision open when it's not sufficiently informed – i.e., to compute a partial semantic representation and to complete it later, using information extraneous to the parser.",
        "In this paper, we focüs on an approach to semantic representation that süpports this strategy: Robüst Minimal Recürsion Semantics (rmrs, Copestake (2007a)).",
        "rmrs is designed to süpport ünderspecification of lexical information, scope, and predicate-argüment strüctüre.",
        "It is an emerging standard for representing partial semantics, and has been applied in several implemented systems.",
        "For instance, Copestake (2003) and Frank (2004) üse it to specify semantic components to shallow parsers ranging in depth from pos taggers to chünk parsers and intermediate parsers süch as rasp (Briscoe et al., 2006).",
        "mrs analyses (Copestake et al., 2005) derived from deep grammars, süch as the English Resoürce Grammar (erg, (Copestake and Flickinger, 2000)) are special cases of rmrs.",
        "Büt rmrs, ünlike mrs and related formalisms like dominance constraints (Egg et al., 2001), is able to express semantic information in the absence of füll predicate argüment strüctüre and lexical sübcategorisation.",
        "The key contribütion we make is to cast rmrs, for the first time, as a logic with a well-defined model theory.",
        "Previoüsly, no süch model theory existed, and so rmrs had to be üsed in a somewhat ad-hoc manner that left open exactly what any given rmrs representation actüally means.",
        "This has hindered practical progress, both in terms of ünderstanding the relationship of rmrs to other frameworks süch as mrs and predicate logic and in terms of the development of efficient algorithms.",
        "As one application of oür formalisation, we üse entailment to propose a novel way of characterising consistency of rmrs analyses across different parsers.",
        "Section 2 introdüces rmrs informally and illüs-trates why it is necessary and üsefül for representing semantic information across deep and shallow langüage processors.",
        "Section 3 defines the syntax and model-theory of rmrs.",
        "We finish in Section 4 by pointing oüt some avenües for fütüre research."
      ]
    },
    {
      "heading": "2. Deep and shallow semantic construction",
      "text": [
        "Consider the following (toy) sentence:",
        "(1) Every fat cat chased some dog.",
        "It exhibits several kinds of ambiguity, including a quantifier scope ambiguity and lexical ambiguities – e.g., the nouns \"cat\" and \"dog\" have 8 and 7 WordNet senses respectively.",
        "Simplifying slightly by ignoring tense information, two of its readings are shown as logical forms below; these can be represented as trees as shown in Fig. 1.",
        "Now imagine trying to extract semantic information from the output of a part-of-speech (pos) tagger by using the word lemmas as lexical predicate symbols.",
        "Such a semantic representation is highly partial.",
        "It will use predicate symbols such as _cat_n, which might resolve to the predicate symbols _cat_n_1 or _cat_n_2 in the complete semantic representation.",
        "(Notice the different fonts for the ambiguous and unambiguous predicate symbols.)",
        "But most underspecification formalisms (e.g., mrs (Copestake etal., 2005) and clls (Egg et al., 2001)) are unable to represent semantic information that is as partial as what we get from a pos tagger because they cannot underspec-ify predicate-argument structure.",
        "rmrs (Copes-take, 2007a) is designed to address this problem.",
        "In rmrs, the information we get from the pos tagger is as follows:",
        "This rmrs expresses only that certain predications are present in the semantic representation – it doesn't say anything about semantic scope, about most arguments of the predicates (e.g., _chase_v(e) doesn't say who chases whom), or about the coindexation of variables (.every_q binds the variable x1, whereas _cat_n speaks about x3), and it maintains the lexical ambiguities.",
        "Technically, it consists of six elementary predications (eps), one for each word lemma in the sentence; each of them is prefixed by a label and an anchor, which are essentially variables that refer to nodes in the trees in Fig. 1.",
        "We can say that the two trees satisfy this rmrs because it is possible to map the labels and anchors in (4) into nodes in each tree and variable names like x1 and x3 into variable names in the tree in such a way that the predications of the nodes that labels and anchors denote are consistent with those in the eps of (4) – e.g., l1and a1 can map to the root of the first tree in Fig. 1, x1 to x, and the root label .every_q_1 is consistent with the ep predicate .every_q.",
        "There are of course many other trees (and thus, fully specific semantic representations such as (2)) that are described equally well by the rmrs (4); this is not surprising, given that the semantic output from the pos tagger is so incomplete.",
        "If we have information about subjects and objects from a chunk parser like Cass (Abney, 1996), we can represent it in a more detailed rmrs:",
        "This introduces two new types of atoms.",
        "x3 = x4 means that x3 and x4 map to the same variable in any fully specific logical form; e.g., both to the variable x in Fig. 1.",
        "ARG»(a, z) (and ARG»(a, h)) express that the i-th child (counting from 0) of the node to which the anchor a refers is the variable name that z denotes (or the node that the hole h denotes).",
        "So unlike earlier underspecification formalisms, rmrs can specify the predicate of an atom separately from its arguments; this is necessary for supporting parsers where information about lexical subcategorisation is absent.",
        "If we also allow atoms of the form ARG{2 3}(a, x) to express uncertainty as to whether x is the second or third child of the anchor a, then rmrs can even specify the arguments to a predicate while under-specifying their position.",
        "This is useful for specifying arguments to _give_v when a parser doesn't handle unbounded dependencies and is faced with Which bone did you give the dog?",
        "vs. To which dog did you give the bone?",
        "Finally, the rmrs (6) is a notational variant of the mrs derived by the erg, a wide-coverage deep grammar:",
        "RSTR and BODY are conventional names for the ARG1 and ARG2 of a quantifier predicate symbol.",
        "Atoms like h2 =q l42 (\"qeq\") specify a certain kind of \"outscopes\" relationship between the hole and the label, and are used here to underspec-ify the scope of the two quantifiers.",
        "Notice that the labels of the eps for \"fat\" and \"cat\" are stipulated to be equal in (6), whereas the anchors are not.",
        "In the tree, it is the anchors that are mapped to the nodes with the labels _fat_j_1 and _cat_n_1; the label is mapped to the conjunction node just above them.",
        "In other words, the role of the anchor in an ep is to connect a predicate to its arguments, while the role of the label is to connect the ep to the surrounding formula.",
        "Representing conjunction with label sharing stems from mrs and provides compact representations.",
        "Finally, (6) uses predicate symbols like _dog_n_1 that are meant to be more specific than symbols like _dog_n which the earlier rmrss used.",
        "This reflects the fact that the deep grammar performs some lexical disambiguation that the chunker and pos tagger don't.",
        "The fact that the former symbol should be more specific than the latter can be represented using SPEC atoms like _dog_n_1 c _dog_n.",
        "Note that even a deep grammar will not fully disambiguate to semantic predicate symbols, such as WordNet senses, and so _dog_n_1 can still be consistent with multiple symbols like _dog_n_1 and _dog_n_2 in the semantic representation.",
        "However, unlike the output of a pos tagger, an rmrs symbol that's output by a deep grammar is consistent with symbols that all have the same arity, because a deep grammar fully determines lexical subcategorisation.",
        "In summary, rmrs allows us to represent in a uniform way the (partial) semantics that can be extracted from a wide range of nlp tools.",
        "This is useful for hybrid systems which exploit shallower analyses when deeper parsing fails, or which try to match deeply parsed queries against shallow parses of large corpora; and in fact, rmrs is gaining popularity as a practical interchange format for exactly these purposes (Copestake, 2003).",
        "However, rmrs is still relatively ad-hoc in that its formal semantics is not defined; we don't know, formally, what an rmrs means in terms of semantic representations like (2) and (3), and this hinders our ability to design efficient algorithms for processing rmrs.",
        "The purpose of this paper is to lay the groundwork for fixing this problem."
      ]
    },
    {
      "heading": "3. Robust Minimal Recursion Semantics",
      "text": [
        "We will now make the basic ideas from Section 2 precise.",
        "We will first define the syntax of the rmrs language; this is a notational variant of earlier definitions in the literature.",
        "We will then define a model theory for our version of rmrs, and conclude this section by carrying over the notion of solved forms from clls (Egg et al., 2001).",
        "We define rmrs syntax in the style of clls (Egg et al., 2001).",
        "We assume an infinite set of node variables NVar = {X, Y,X1,...}, used as labels, anchors, and holes; the distinction between these will come from their position in the formulas.",
        "We also assume an infinite set of base variables BVar, consisting of individual variables {x,x1,y,...} and event variables {e1, .",
        ".",
        ".",
        "}, and a vocabulary of predicate symbols Pred = {P, Q,P1,...}.",
        "rmrs formulas are defined as follows.",
        "Definition 1.",
        "An rmrs is a finite set p of atoms of one of the following forms; S C N is a set of numbers that is either finite or N itself (throughout the paper, we assume 0 £ N).",
        "A ::= X :Y:P I ARGs (X,v) I ARGs (X,Y)",
        "A node variable X is called a label iff p contains an atom of the form X:Y:P or Y <* X; it is an anchor iff p contains an atom of the form Y:X:P or ARGS(X, i); and it is a hole iff p contains an atom of the form ARGS (Y, X) or X <* Y.",
        "Def.",
        "1 combines similarities to earlier presentations of rmrs (Copestake, 2003; Copestake, 2007b) and to clls/dominance constraints (Egg et al., 2001).",
        "For the most part, our syntax generalises that of older versions of rmrs: We use ARG^} (with a singleton set S) instead of ARGi and ARGN instead of ARG„, and the ep l:a:P(v) (as in Section 2) is an abbreviation of {l:a:P, ARG{0}(a, v)}.",
        "Similarly, we don't assume that labels, anchors, and holes are syntactically different objects; they receive their function from their positions in the formula.",
        "One major difference is that we use dominance (<*) rather than qeq; see Section 3.4 for a discussion.",
        "Compared to dominance constraints, the primary difference is that we now have a mechanism for representing lexical ambiguity, and we can specify a predicate and its arguments separately.",
        "The model theory formalises the relationship between an rmrs and the fully specific, alternative logical forms that it describes, expressed in the base language.",
        "We represent such a logical form as a tree t, such as the ones in Fig. 1, and we can then define satisfaction of formulas in the usual way, by taking the tree as a model structure that interprets all predicate symbols specified above.",
        "In this paper, we assume for simplicity that the base language is as in mrs; essentially, t becomes the structure tree of a formula of predicate logic.",
        "We assume that £ is a ranked signature consisting of the symbols of predicate logic: a unary constructor – and binary constructors A, – , etc.",
        "; a set of 3-place quantifier symbols such as _every_q_1 and _some_q_1 (with the children being the bound variable, the restrictor, and the scope); and constructors of various arities for the predicate symbols; e.g., _chase_v_1 is of arity 3.",
        "Other base languages may require a different signature £ and/or a different mapping between formulas and trees; the only strict requirement we make is that the signature contains a binary constructor A to represent conjunction.",
        "We write £i and £>i for the set of all constructors in £ with arity i and at least i, respectively.",
        "We will follow the typographical convention that non-logical symbols in £ are written in sans-serif, as opposed to the rmrs predicate symbols like _cat_n and _cat_n_1.",
        "The models of rmrs are then defined to be finite constructor trees (see also (Egg et al., 2001)):",
        "Definition 2.",
        "A finite constructor tree t is a function t : D – £ such that D is a tree domain (i.e., a subset of N* which is closed under prefix and left sibling) and the number ofchildren ofeach node u £ D is equal to the arity of t(u).",
        "We write D(t) for the tree domain of a constructor tree t, and further define the following relations between nodes in a finite constructor tree:",
        "Definition 3. u <* v (dominance) iff u is a prefix ofv, i.e. the node u is equal to or above the node v in the tree.",
        "u <*A v iff u <* v, and all symbols on the path from u to v (not including v) are A.",
        "The satisfaction relation between an rmrs p and a finite constructor tree t is defined in terms of several assignment functions.",
        "First, a node variable assignment function a : NVar – D(t) maps the node variables in an rmrs to the nodes of t. Second, a base language assignment function g : BVar – £0 maps the base variables to nullary constructors representing variables in the base language.",
        "Finally, a function a from Pred to the power set of £>1 maps each rmrs predicate symbol to a set of constructors from £.",
        "As we'll see shortly, this function allows an rmrs to under-specify lexical ambiguities.",
        "Definition 4.",
        "Satisfaction of atoms is defined as follows:",
        "t(a(Y)) e a(P) and a(X) <* a(Y) t , a, g, a = ARGS (X, a) iff exists i e S s.t.",
        "a(X) • i e D(t) and t(a(X) • i)= g(a) t , a, g, a = ARGS (X, Y) iff exists i e S s.t.",
        "A 4-tuple t, a,g, a satisfies an rmrs p (written t, a, g, a = p) iff it satisfies all of its elements.",
        "Notice that one rmrs may be satisfied by multiple trees; we can take the rmrs to be a partial description of each of these trees.",
        "In particular, rmrss may represent semantic scope ambiguities and/or missing information about semantic dependencies, lexical subcategorisation and lexical senses.",
        "For j = [1,2}, suppose that Tj ,aj ,gj ,a = p. Then p exhibits a semantic scope ambiguity if there are variables Y, Y e NVar such that ai(Y) <* ai(Y') and a2(Yr) <* a2 (Y).",
        "It exhibits missing information about semantic dependencies if there are base-language variables v,v' e BVar such that gl(v)= gl(vr) and g2(v) = g2(v').",
        "It exhibits missing lexical subcategorisation information if there is a Y e NVar such that Tl(al(Y)) is a constructor of a different type from T2(a2(Y)) (i.e., the constructors are of a different arity or they differ in whether their arguments are scopal vs. non-scopal).",
        "And it exhibits missing lexical sense information if Tl(al(Y)) and t2(a2(Y)) are different base-language constructors, but of the same type.",
        "Let's look again at the rmrs (4).",
        "This is satisfied by the trees in Fig. 1 (among others) together with some particular a, g, and a.",
        "For instance, consider the left-hand side tree in Fig. 1.",
        "The rmrs (4) satisfies this tree with an assignment function a that maps the variables ll and alto the root node, l4l and l42 to its second child (labeled with \"A\"), a4l to the first child of that node (i.e. the node 21, labelled with \"fat\") and a42 to the node 22, and so forth.",
        "g will map xland x3 to x, and x6 and x7 to y, and so on.",
        "And a will map each rmrs predicate symbol (which represents a word) to the set of its fully resolved meanings, e.g. _cat_n to a set containing _cat_n_1 and possibly others.",
        "It is then easy to verify that every single atom in the rmrs is satisfied – most interestingly, the eps l4l:a4l:lat-j(e') and l42:a42:-c&t-n(x3) are satisfied because a(l4l) <]*Aa(a4l) and a(l42) <*A a(a42).",
        "Truth, validity and entailment can now be defined in terms of satisfiability in the usual way:",
        "Definition 5. truth: t = p iff 3a, g, a such that validity: = p iff Mt, t = p.",
        "entailment: p = p iff Mt, if t = p then t = p.",
        "One aspect in which our definition of rmrs is like dominance constraints and unlike mrs is that any satisfiable rmrs has an infinite number of models which only differ in the areas that the rmrs didn't \"talk about\".",
        "Reading (6) as an mrs or as an rmrs of the previous literature, this formula is an instruction to build a semantic representation out of the pieces for \"every fat cat\", \"some dog\", and \"chased\"; a semantic representation as in Fig. 2 would not be taken as described by this rmrs.",
        "However, under the semantics we proposed above, this tree is a correct model of (6) because all atoms are still satisfied; the rmrs didn't say anything about \"sleep\" or \"run\", but it couldn t enforce that the tree shouldn t contain those subformulas either.",
        "In the context of robust semantic processing, this is a desirable feature, because it means that when we enrich an rmrs obtained from a shallow processor with more semantic information – such as the relation symbols introduced by syntactic constructions such as appositives, noun-noun compounds and free adjuncts – we don't change the set of models; we only restrict the set of models further and further towards the semantic representation we are trying to reconstruct.",
        "Furthermore, it has been shown in the literature that a dominance-constraint style semantics for underspecified representations gives us more room to manoeuvre when developing efficient solvers than an mrs-style semantics (Althaus et al., 2003).",
        "However, enumerating an infinite number of models is of course infeasible.",
        "For this reason, we will now transfer the concept of solved forms from dominance constraints to rmrs.",
        "An rmrs in solved form is guaranteed to be satisfiable, and thus each solved form represents an infinite class of models.",
        "However, each satisfiable rmrs has only a finite number of solved forms which partition the space of possible models into classes such that models within a class differ only in 'irrelevant details.",
        "A solver can then enumerate the solved forms rather than all models.",
        "Intuitively, an rmrs in solved form is fully specified with respect to the predicate-argument structure, all variable equalities and inequalities and scope ambiguities have been resolved, and only lexical sense ambiguities remain.",
        "This is made precise below.",
        "Definition 6.",
        "An RMRS p is in solved form iff:",
        "1. every variable in p is either a hole, a label or an anchor (but not two of these);"
      ]
    },
    {
      "heading": "2.. p doesn't contain equality, inequality, and SPEC (C) atoms;",
      "text": [
        "4. for any label Y and index set S, there are no two atoms ARGS(Y, i) and ARGS(Y, i') in p;",
        "5. if Y is an anchor in some ep X:Y:P and k is the maximum number such that ARG{fc}(X, i) is in p for any i, then there is a constructor p e a(P) whose arity is at least k;",
        "6. no label occurs on the right-hand side of two different < * atoms.",
        "Because solved forms are so restricted, we can 'read off at least one model from each solved form:",
        "into holes is straightforward because no label is dominated by more than one hole; and spaces between the labels and anchors are filled with conjunctions.",
        "□",
        "We can now define the solved forms of an rmrs p; these finitely many rmrss in solved form partition the space of models of p into classes of models with trivial differences.",
        "Definition 7.",
        "The syntactic dominance relation D(p) in an rmrs p is the reflexive, transitive closure of the binary relation",
        "ARGs(X, Y) for some S}",
        "An RMRS p' is a solved form of the RMRS p iff p' is in solved form and there is a substitution s that maps the node and base variables of p to the node and base variables ofp' such that 3.",
        "D(p') D s(D(p)).",
        "Proposition 2.",
        "For every tuple (t, a, g, a) that satisfies some rmrs p, there is a solved form p' of p such that (t, a, g, a) also satisfies p'.",
        "Proof.",
        "We construct the substitution s from a and g. Then we add all dominance atoms that are satisfied by a and restrict the ARG atoms to those child indices that are actually used in t. The result is in solved form because t is a tree; it is a solved form of p by construction.",
        "□ Proposition 3.",
        "Every rmrs p has only a finite number of solved forms, up to renaming of variables.",
        "Proposition 1.",
        "Every rmrs in solved form is satisfiable.",
        "Proof.",
        "Up to renaming of variables, there is only a finite number of substitutions on the node and base variables of p. Let s be such a substitution.",
        "This Proof (sketch; see also (Duchier andNiehren, 2000)).",
        "fixes the set of eps of any solved form of p that is For each ep, we choose to label the anchor with based on s uniquely.",
        "There is only a finite set of the constructor p of sufficiently high arity whose choices for the subsets S' in condition 2 of Def.",
        "7, existence we assumed; we determine the edges and there is only a finite set of choices of new dom-between an anchor and its children from the inance atoms that satisfy condition 3.",
        "Therefore, uniquely determined ARG atoms; plugging labels the set of solved forms of p is finite.",
        "□",
        "Let's look at an example for all these definitions.",
        "All the rmrss presented in Section 2 (replacing =q by <*) are in solved form; this is least obvious for (6), but becomes clear once we notice that no label is on the right-hand side of two dominance atoms.",
        "However, the model constructed in the proof of Prop.",
        "1 looks a bit like Fig. 2; both models are problematic in several ways and in particular contain an unbound variable y even though they also contains a quantifier that binds y.",
        "If we restrict the class of models to those in which such variables are bound (as Copestake et al.",
        "(2005) do), we can enforce that the quantifiers outscope their bound variables without changing models of the rmrs further – i.e., we add the atoms h3 <* l5and hg <* l5.",
        "Fig.",
        "2 is no longer a model for the extended rmrs, which in turn is no longer in solved form because the label l5 is on the right-hand side of two dominance atoms.",
        "Instead, it has the following two solved forms:",
        "Notice that we have eliminated all equalities by unifying the variable names, and we have fixed the relative scope of the two quantifiers.",
        "Each of these solved forms now stands for a separate class of models; for instance, the first model in Fig. 1 is a model of (7), whereas the second is a model of (8).",
        "So far we have based the syntax and semantics of rmrs on the dominance relation from Egg et al.",
        "(2001) rather than the qeq relation from Copestake et al.",
        "(2005).",
        "This is partly because dominance is the weaker relation: If a dependency parser links a determiner to a noun and this noun to a verb, then we can use dominance but not qeq to represent that the predicate introduced by the verb is outscoped by the quantifier introduced by the determiner (see earlier discussion).",
        "However, it is very straightforward to extend the syntax and semantics of the language to include the qeq relation.",
        "This extension adds a new atom X =q Y to Def.",
        "1, and t, a, g, a will satisfy X =q Y iff a(X) <* a(Y), each node on the path is a quantifier, and each step in the path goes to the rightmost child.",
        "All the above propositions about solved forms still hold if \"dominance\" is replaced with \"qeq\".",
        "Furthermore, grammar developers such as those in the delph-in community typically adopt conventions that restrict them to a fragment of the language from Def.",
        "1 (once qeq is added to it), or they restrict attention to only a subset of the models (e.g., ones with correctly bound variables, or ones which don t contain extra material like Fig. 2).",
        "Our formalism provides a general framework into which all these various fragments fit, and it's a matter of future work to explore these fragments further.",
        "Another feature of the existing rmrs literature is that each term of an rmrs is equipped with a sort.",
        "In particular, individual variables x, event variables e and holes h are arranged together with their subsorts (e.g., epast) and supersorts (e.g., sort i abstracts over x and e) into a sort hierarchy S. For simplicity we defined rmrs without sorts, but it is straightforward to add them.",
        "For this, one assumes that the signature £ is sorted, i.e. assigns a sort sl x .. .sn – > s to each constructor, where n is the constructor's arity (possibly zero) and s,sl,... ,sn e S are atomic sorts.",
        "We restrict the models of rmrs to trees that are well-sorted in the usual sense, i.e. those in which we can infer a sort for each subtree, and require that the variable assignment functions likewise respect the sorts.",
        "If we then modify Def.",
        "6 such that the constructor p of sufficiently high arity is also consistent with the sorts of the known arguments – i.e., if p has sort sl x ... x sn – s and the rmrs contains an atom ARG{fc}(Y, i) and i is of sort s', then s' is a sub-sort of sk – all the above propositions about solved forms remain true."
      ]
    },
    {
      "heading": "4. Future work",
      "text": [
        "The above definitions serve an important theoretical purpose: they formally underpin the use of rmrs in practical systems.",
        "Next to the peace of mind that comes with the use of a well-understood formalism, we hope that the work reported here will serve as a starting point for future research.",
        "One direction to pursue from this paper is the development of efficient solvers for rmrs.",
        "As a first step, it would be interesting to define a practically useful fragment of rmrs with polynomial-time satisfiability.",
        "Our definition is sufficiently close to that of dominance constraints that we expect that it should be feasible to carry over the definition of normal dominance constraints (Althaus et al., 2003) to rmrs; neither the lexical ambiguity of the node labels nor the separate specification of predicates and arguments should make satisfiability harder.",
        "Furthermore, the above definition of rmrs provides new concepts which can help us phrase questions of practical grammar engineering in well-defined formal terms.",
        "For instance, one crucial issue in developing a hybrid system that combines or compares the outputs of deep and shallow processors is to determine whether the rmrss produced by the two systems are compatible.",
        "In the new formal terms, we can characterise compatibility of a more detailed rmrs p (perhaps from a deep grammar) and a less detailed rmrs p' simply as entailment p = p'.",
        "If entailment holds, this tells us that all claims that p' makes about the semantic content of a sentence are consistent with the claims that p makes.",
        "At this point, we cannot provide an efficient algorithm for testing entailment of rmrs.",
        "However, we propose the following novel syntactic characterisation as a starting point for research along those lines.",
        "We call an rmrs p' an extension of the rmrs p if p' contains all the eps of p and D(p') D D(p).",
        "Proposition 4.",
        "Let p, p' be two rmrss.",
        "Then p = p' ifffor every solved form S ofp, there is a solved form S' ofp' such that S is an extension of S'.",
        "Proof (sketch).",
        "\"<*=\" follows from Props.",
        "1 and 2.",
        "\"=>\": We construct a solved form for p' by choosing a solved form for p and appropriate substitutions for mapping the variables of p and p'onto each other, and removing all atoms using variables that don't occur in p' .",
        "The hard part is the proof that the result is a solved form of p'; this step involves proving that if p = p' with the same variable assignments, then all eps in p' also occur in p. □"
      ]
    },
    {
      "heading": "5. Conclusion",
      "text": [
        "In this paper, we motivated and defined rmrs – a semantic framework that has been used to represent, compare, and combine semantic information computed from deep and shallow parsers.",
        "rmrs is designed to be maximally flexible on the type of semantic information that can be left under-specified, so that the semantic output of a shallow parser needn't over-determine or under-determine the semantics that can be extracted from the shallow syntactic analysis.",
        "Our key contribution was to lay the formal foundations for a formalism that is emerging as a standard in robust semantic processing.",
        "Although we have not directly provided new tools for modelling or processing language, we believe that a cleanly defined model theory for rmrs is a crucial prerequisite for the future development of such tools; this strategy was highly successful for dominance constraints (Althaus et al., 2003).",
        "We hope that future research will build upon this paper to develop efficient algorithms and implementations for solving rmrss, performing inferences that enrich rmrss from shallow analyses with deeper information, and checking consistency of rmrss that were obtained from different parsers.",
        "Acknowledgments.",
        "We thank Ann Copestake, Dan Flickinger, and Stefan Thater for extremely fruitful discussions and the reviewers for their comments.",
        "The work of Alexander Koller was funded by a DFG Research Fellowship and the Cluster of Excellence \"Multimodal Computing and Interaction\"."
      ]
    }
  ]
}
