{
  "info": {
    "authors": [
      "Marco Kuhlmann",
      "Mathias Mohl"
    ],
    "book": "45th Annual Meeting of the Association of Computational Linguistics",
    "id": "acl-P07-1021",
    "title": "Mildly Context-Sensitive Dependency Languages",
    "url": "https://aclweb.org/anthology/P07-1021",
    "year": 2007
  },
  "references": [
    "acl-C04-1042",
    "acl-E06-1010",
    "acl-E06-1011",
    "acl-H05-1066",
    "acl-P04-1054",
    "acl-P05-1034",
    "acl-P06-2066",
    "acl-P87-1015",
    "acl-P92-1012",
    "acl-P97-1043",
    "acl-P99-1059"
  ],
  "sections": [
    {
      "text": [
        "Marco Kuhlmann Mathias Möhl",
        "Programming Systems Lab Programming Systems Lab",
        "Saarland University Saarland University",
        "Saarbrücken, Germany Saarbrücken, Germany",
        "kuhlmann@ps.uni-sb.de mmohl@ps.uni-sb.de",
        "Dependency-based representations of natural language syntax require a fine balance between structural flexibility and computational complexity.",
        "In previous work, several constraints have been proposed to identify classes of dependency structures that are well-balanced in this sense; the best-known but also most restrictive of these is projectivity.",
        "Most constraints are formulated on fully specified structures, which makes them hard to integrate into models where structures are composed from lexical information.",
        "In this paper, we show how two empirically relevant relaxations of projectivity can be lexicalized, and how combining the resulting lexicons with a regular means of syntactic composition gives rise to a hierarchy of mildly context-sensitive dependency languages."
      ]
    },
    {
      "heading": "1. Introduction",
      "text": [
        "Syntactic representations based on word-to-word dependencies have a long tradition in descriptive linguistics.",
        "Lately, they have also been used in many computational tasks, such as relation extraction (Culotta and Sorensen, 2004), parsing (McDonald et al., 2005), and machine translation (Quirk et al., 2005).",
        "Especially in recent work on parsing, there is a particular interest in non-projective dependency structures, in which a word and its dependents may be spread out over a discontinuous region of the sentence.",
        "These structures naturally arise in the syntactic analysis of languages with flexible word order, such as Czech (Vesela et al., 2004).",
        "Unfortunately, most formal results on non-projectivity are discouraging: While grammar-driven dependency parsers that are restricted to projective structures can be as efficient as parsers for lexicalized context-free grammar (Eisner and Satta, 1999), parsing is prohibitively expensive when unrestricted forms of non-projectivity are permitted (Neuhaus and Broker, 1997).",
        "Data-driven dependency parsing with non-projective structures is quadratic when all attachment decisions are assumed to be independent of one another (McDonald et al., 2005), but becomes intractable when this assumption is abandoned (McDonald and Pereira, 2006).",
        "In search of a balance between structural flexibility and computational complexity, several authors have proposed constraints to identify classes of non-projec-tive dependency structures that are computationally well-behaved (Bodirsky et al., 2005; Nivre, 2006).",
        "In this paper, we focus on two of these proposals: the gap-degree restriction, which puts a bound on the number of discontinuities in the region of a sentence covered by a word and its dependents, and the well-nestedness condition, which constrains the arrangement of dependency subtrees.",
        "Both constraints have been shown to be in very good fit with data from dependency treebanks (Kuhlmann and Nivre, 2006).",
        "However, like all other such proposals, they are formulated on fully specified structures, which makes it hard to integrate them into a generative model, where dependency structures are composed from elementary units of lexicalized information.",
        "Consequently, little is known about the generative capacity and computational complexity of languages over restricted non-projective dependency structures.",
        "Contents of the paper In this paper, we show how the gap-degree restriction and the well-nestedness condition can be captured in dependency lexicons, and how combining such lexicons with a regular means of syntactic composition gives rise to an infinite hierarchy of mildly context-sensitive languages.",
        "The technical key to these results is a procedure to encode arbitrary, even non-projective dependency structures into trees (terms) over a signature of local order-annotations.",
        "The constructors of these trees can be read as lexical entries, and both the gap-degree restriction and the well-nestedness condition can be couched as syntactic properties of these entries.",
        "Sets of gap-restricted dependency structures can be described using regular tree grammars.",
        "This gives rise to a notion of regular dependency languages, and allows us to establish a formal relation between the structural constraints and mildly context-sensitive grammar formalisms (Joshi, 1985): We show that regular dependency languages correspond to the sets of derivations of lexicalized Linear Context-Free Rewriting Systems (lcfrs) (Vijay-Shanker et al., 1987), and that the gap-degree measure is the structural correspondent of the concept of 'fan-out' in this formalism (Satta, 1992).",
        "We also show that adding the well-nestedness condition corresponds to the restriction of lcfrs to Coupled Context-Free Grammars (Hotz and Pitsch, 1996), and that regular sets of well-nested structures with a gap-degree of at most 1 are exactly the class of sets of derivations of Lexicalized Tree Adjoining Grammar (ltag).",
        "This result generalizes previous work on the relation between ltag and dependency representations (Ram-bow and Joshi, 1997; Bodirsky et al., 2005).",
        "Structure of the paper The remainder of this paper is structured as follows.",
        "Section 2 contains some basic notions related to trees and dependency structures.",
        "In Section 3 we present the encoding of dependency structures as order-annotated trees, and show how this encoding allows us to give a lexicalized reformulation of both the gap-degree restriction and the well-nestedness condition.",
        "Section 4 introduces the notion of regular dependency languages.",
        "In Section 5 we show how different combinations of restrictions on non-projectivity in these languages correspond to different mildly context-sensitive grammar formalisms.",
        "Section 6 concludes the paper."
      ]
    },
    {
      "heading": "2. Preliminaries",
      "text": [
        "Throughout the paper, we write [n] for the set of all positive natural numbers up to and including n. The set of all strings over a set A is denoted by A*, the empty string is denoted by e, and the concatenation of two strings x and y is denoted either by xy, or, where this is ambiguous, by x • y.",
        "In this paper, we regard trees as terms.",
        "We expect the reader to be familiar with the basic concepts related to this framework, and only introduce our particular notation.",
        "Let U be a set of labels.",
        "The set of (finite, unranked) trees over U is defined recursively by the equation Ts '= { cr(x) | a 2 U, x 2 T* }.",
        "The set of nodes of a tree t 2 Ts is defined as",
        "N(a(ti • • • t„)) ■= {\"} U {iu | i 2 [n], u 2 N(t;) } .",
        "For two nodes u, v 2 N(t), we say that u governs v, and write u E v, if v can be written as v = ux, for some sequence x 2 N *.",
        "Note that the governance relation is both reflexive and transitive.",
        "The converse of government is called dependency, so u E v can also be read as 'v depends on u'.",
        "The yield of a node u 2 N(t), |_uj, is the set of all dependents of u in t: |_uj '= {v 2 N(t) | u E v }.",
        "We also use the notations t(u) for the label at the node u of t, and t/u for the subtree of t rooted at u.",
        "A tree language over U is a subset of Ts.",
        "For the purposes of this paper, a dependency structure over U is a pair d = (t, x), where t 2 Ts is a tree, and x is a list of the nodes in t. We write Ds to refer to the set of all dependency structures over U.",
        "Independently of the governance relation in d, the list x defines a total order on the nodes in t; we write u < v to denote that u precedes v in this order.",
        "Note that, like governance, the precedence relation is both reflexive and transitive.",
        "A dependency language over U is a subset of Ds.",
        "Example.",
        "The left half of Figure 1 shows how we visualize dependency structures: circles represent nodes, arrows represent the relation of (immediate) governance, the left-to-right order of the nodes represents their order in the precedence relation, and the dotted lines indicate the labelling.",
        "□"
      ]
    },
    {
      "heading": "3. Lexicalizing the precedence relation",
      "text": [
        "In this section, we show how the precedence relation of dependency structures can be encoded as, and decoded from, a collection of node-specific order annotations.",
        "Under the assumption that the nodes of a dependency structure correspond to lexemic units, this result demonstrates how word-order information can be captured in a dependency lexicon.",
        "Lexicalizing the precedence relation of a dependency structure is particularly easy if the structure under consideration meets the condition of projectivity.",
        "A dependency structure is projective, if each of its yields forms an interval with respect to the precedence order (Kuhlmann and Nivre, 2006).",
        "In a projective structure, the interval that corresponds to a yield [u\\ decomposes into the singleton interval [u,u], and the collection of the intervals that correspond to the yields of the immediate dependents of u.",
        "To reconstruct the global precedence relation, it suffices to annotate each node u with the relative precedences among the constituent parts of its yield.",
        "We represent this 'local' order as a string over the alphabet No, where the symbol 0 represents the singleton interval [u,u], and a symbol / ^ 0 represents the interval that corresponds to the yield of the / th direct dependent of u.",
        "An order-annotated tree is a tree labelled with pairs (a, co), where a is the label proper, and co is a local order annotation.",
        "In what follows, we will use the functional notations cr(u) and co(u) to refer to the label and order annotation of u, respectively.",
        "Example.",
        "Figure 1 shows a projective dependency structure together with its representation as an order-annotated tree.",
        "□",
        "We now present procedures for encoding projective dependency structures into order-annotated trees, and for reversing this encoding.",
        "Encoding The representation of a projective dependency structure (t, x) as an order-annotated tree can be computed in a single left-to-right sweep over x.",
        "Starting with a copy of the tree t in which every node is annotated with the empty string, for each new node u in x, we update the order annotation of u through the assignment co(u) := co(u) • 0.",
        "If u = vi for some / e N (that is, if u is an inner node), we also update the order annotation of the parent v of u through the assignment co(v) := co(v) • i.",
        "Decoding To decode an order-annotated tree t, we first linearize the nodes of t into a sequence x, and then remove all order annotations.",
        "Linearization proceeds in a way that is very close to a pre-order traversal of the tree, except that the relative position of the root node of a subtree is explicitiy specified in the order annotation.",
        "Specifically, to linearize an order-annotated tree, we look into the local order co(u) annotated at the root node of the tree, and concatenate the linearizations of its constituent parts.",
        "A symbol i in co(u) represents either the singleton interval [u, u] (i = 0), or the interval corresponding to some direct dependent ui of u (i ^ 0), in which case we proceed recursively.",
        "Formally, the linearization of u is captured by the following three equations:",
        "Both encoding and decoding can be done in time linear in the number of nodes of the dependency structure or order-annotated tree.",
        "It is straightforward to see that our representation of dependency structures is insufficient if the structures under consideration are non-projective.",
        "To witness, consider the structure shown in Figure 2.",
        "Encoding this structure using the procedure presented above yields the same order-annotated tree as the one shown in Figure 1, which demonstrates that the encoding is not reversible.",
        "Blocks In a non-projective dependency structure, the yield of a node may be spread out over more than one interval; we will refer to these intervals as blocks.",
        "Two nodes v, w belong to the same block of a node u, if all nodes between v and w are governed by u.",
        "Example.",
        "Consider the nodes b,c,d in the structures depicted in Figures 1 and 2.",
        "In Figure 1, these nodes belong to the same block of b.",
        "In Figure 2, the three nodes are spread out over two blocks of b (marked by the boxes): c and d are separated by a node (e) not governed by b.",
        "□",
        "Blocks have a recursive structure that is closely related to the recursive structure of yields: the blocks of anode u can be decomposed into the singleton [u,u], and the blocks of the direct dependents of u.",
        "Just as a projective dependency structure can be represented by annotating each yield with an order on its constituents, an unrestricted structure can be represented by annotating each block.",
        "Extended order annotations To represent orders on blocks, we extend our annotation scheme as follows.",
        "First, instead of a single string, an annotation co(u) now is a tuple of strings, where the kih component specifies the order among the constituents of the kih block of u.",
        "Second, instead of one, the annotation may now contain multiple occurrences of the same dependent; the kth occurrence of / in co(u) represents the kth block of the node ui.",
        "We write co(u)k to refer to the kih component of the order annotation of u.",
        "We also use the notation (i#k)u to refer to the kth occurrence of / in co(u), and omit the subscript when the node u is implicit.",
        "Encoding To encode a dependency structure (t, x) as an extended order-annotated tree, we do a post-order traversal of t as follows.",
        "For a given node u, let us represent a constituent of a block of u as a triple / : [vi,vr], where / denotes the node that contributes the constituent, and vj and vr denote the constituent's leftmost and rightmost elements.",
        "At each node u, we have access to the singleton block 0 : [u,u], and the constituent blocks of the immediate dependents of u.",
        "We say that two blocks / : [vj, vr], j : [wj, wr] can be merged, if the node vr immediately precedes the node wi.",
        "The result of the merger is a new block ij : [vj, wr] that represents the information that the two merged constituents belong to the same block of u.",
        "By exhaustive merging, we obtain the constituent structure of all blocks of u.",
        "From this structure, we can read off the order annotation to(u).",
        "Example.",
        "The yield of the node b in Figure 2 decomposes into 0 : [b,b], 1 : [c,c], and 1 : [d, d].",
        "Since b and c are adjacent, the first two of these constituents can be merged into a new block 01 : [b,c]; the third constituent remains unchanged.",
        "This gives rise to the order annotation (01,1) for b.",
        "□",
        "When using a global data-structure to keep track of the constituent blocks, the encoding procedure can be implemented to run in time linear in the number of blocks in the dependency structure.",
        "In particular, for projective dependency structures, it still runs in time linear in the number of nodes.",
        "Decoding To linearize the kth block of a node u, we look into the kth component of the order annotated at u, and concatenate the linearizations of its constituent parts.",
        "Each occurrence (i#k) in a component of to(u) represents either the node u itself (i = 0), or the kth block of some direct dependent ui of u (i ^ 0), in which case we proceed recursively:",
        "The root node of a dependency structure has only one block.",
        "Therefore, to linearize a tree t, we only need to linearize the first block of the tree's root node: lin(f) = lin(e, 1).",
        "Consistent order annotations Every dependency structure over U can be encoded as a tree over the set U x Q, where Q is the set of all order annotations.",
        "The converse of this statement does not hold: to be interpretable as a dependency structure, tree structure and order annotation in an order-annotated tree must be consistent, in the following sense.",
        "Property C1: Every annotation to(u) in a tree t contains all and only the symbols in the collection {0} U { i j ui 2 N(t) }, i.e., one symbol for u, and one symbol for every direct dependent of u.",
        "Property C2: The number of occurrences of a symbol i ^ 0 in o)(u) is identical to the number of components in the annotation of the node ui.",
        "Furthermore, the number of components in the annotation of the root node is 1.",
        "With this notion of consistency, we can prove the following technical result about the relation between dependency structures and annotated trees.",
        "We write its (s) for the tree obtained from a tree s 2 Ts xq by relabelling every node u with a(u).",
        "Proposition 1.",
        "For every dependency structure (t, x) over U, there exists a tree s over U x Q such that its (s) = t and lin(s) = x. Conversely, for every consistently order-annotated tree s 2 Tsxq , there exists a uniquely determined dependency structure (t, x) with these properties.",
        "□",
        "The encoding of dependency structures as order-annotated trees allows us to reformulate two constraints on non-projectivity originally defined on fully specified dependency structures (Bodirsky et al., 2005) in terms of syntactic properties of the order annotations that they induce:",
        "Gap-degree The gap-degree of a dependency structure is the maximum over the number of discontinuities in any yield of that structure.",
        "Example.",
        "The structure depicted in Figure 2 has gap-degree 1: the yield of b has one discontinuity, marked by the node e, and this is the maximal number of discontinuities in any yield of the structure.",
        "□",
        "Since a discontinuity in a yield is delimited by two blocks, and since the number of blocks of a node u equals the number of components in the order annotation of u, the following result is obvious:",
        "Proposition 2.",
        "A dependency structure has gap-degree k if and only if the maximal number of components among the annotations (o(u) is k C 1.",
        "□",
        "In particular, a dependency structure is projective iff all of its annotations consist of just one component.",
        "Well-nestedness The well-nestedness condition constrains the arrangement of subtrees in a dependency structure.",
        "Two subtrees t/u\\,t/u2 interleave, if there are nodes v, v 2 t/u\\ and v, v 2 t/u2such that v -< v -< v -< v. A dependency structure is well-nested, if no two of its disjoint subtrees interleave.",
        "We can prove the following result:",
        "Proposition 3.",
        "A dependency structure is well-nested if and only if no annotation o)(u) contains a substring i • • • j ••• i ••• j, for i,j 2 N. □",
        "Example.",
        "The dependency structure in Figure 1 is well-nested, the structure depicted in Figure 2 is not: the subtrees rooted at the nodes b and e interleave.",
        "To see this, notice that b -< e -< d -< f. Also notice that o)(a) contains the substring 1212.",
        "□"
      ]
    },
    {
      "heading": "4. Regular dependency languages",
      "text": [
        "The encoding of dependency structures as order-annotated trees gives rise to an encoding of dependency languages as tree languages.",
        "More specifically, dependency languages over a set U can be encoded as tree languages over the set U x Q, where Q is the set of all order annotations.",
        "Via this encoding, we can study dependency languages using the tools and results of the well-developed formal theory of tree languages.",
        "In this section, we discuss dependency languages that can be encoded as regular tree languages.",
        "The class of regular tree languages, REGT for short, is a very natural class with many characterizations (Gecseg and Steinby, 1997): it is generated by regular tree grammars, recognized by finite tree automata, and expressible in monadic second-order logic.",
        "Here we use the characterization in terms of grammars.",
        "Regular tree grammars are natural candidates for the formalization of dependency lexicons, as each rule in such a grammar can be seen as the specification of a word and the syntactic categories or grammatical functions of its immediate dependents.",
        "Formally, a (normalized) regular tree grammar is a construct G = (Ng, Ug, Sg , Pg), in which Ng and Ug are finite sets of non-terminal and terminal symbols, respectively, Sg 2 Ng is a dedicated start symbol, and Pg is a finite set of productions of the form A !",
        "a(A1 ••• An), where a 2 Ug, A 2 NG, and A, 2 NG, for every i 2 [n].",
        "The (direct) derivation relation associated to G is the binary relation )g on the set TsGung defined as follows:",
        "Informally, each step in a derivation replaces a nonterminal-labelled leaf by the right-hand side of a matching production.",
        "The tree language generated by G is the set of all terminal trees that can eventually be derived from the trivial tree formed by its start symbol: L(G) = {t 2 I Sg )G t}.",
        "We call a dependency language regular, if its encoding as a set of trees over U x Q forms a regular tree language, and write REGD for the class of all regular dependency languages.",
        "For every regular dependency language L, there is a regular tree grammar with terminal alphabet U x Q that generates the encoding of L. Similar to the situation with individual structures, the converse of this statement does not hold: the consistency properties mentioned above impose corresponding syntactic restrictions on the rules of grammars G that generate the encoding of L.",
        "Property C1: The !-component of every production A !",
        "(a,!)",
        "(A1 • • • An) in G contains all and only symbols in the set {0} U {i j i 2 [n] }.",
        "Property C2: For every non-terminal X 2 Ng , there is a uniquely determined integer dx such that for every production A !",
        "(a,!)",
        "(A1 • • • An) in G, dA, gives the number of occurrences of i in !, dA gives the number of components in !, and dsG = 1.",
        "It turns out that these properties are in fact sufficient to characterize the class of regular tree grammars that generate encodings of dependency languages.",
        "In but slight abuse of terminology, we will refer to such grammars as regular dependency grammars.",
        "Example.",
        "Figure 3 shows a regular tree grammar that generates a set of non-projective dependency structures with string language {anbn j n > 1}.",
        "□"
      ]
    },
    {
      "heading": "5. Structural constraints and formal power",
      "text": [
        "In this section, we present our results on the generative capacity of regular dependency languages, linking them to a large class of mildly context-sensitive grammar formalisms.",
        "A dependency language L is called gap-restricted, if there is a constant cl > 0 such that no structure in L has a gap-degree higher than cl .",
        "It is plain to see that every regular dependency language is gap-restricted: the gap-degree of a structure is directly reflected in the number of components of its order annotations, and every regular dependency grammar makes use of only a finite number of these annotations.",
        "We write REGD(k) to refer to the class of regular dependency languages with a gap-degree bounded by k.",
        "Linear Context-Free Rewriting Systems Gap-restricted dependency languages are closely related to Linear Context-Free Rewriting Systems (lcfrs) (Vijay-Shanker et al., 1987), a class of formal systems that generalizes several mildly context-sensitive grammar formalisms.",
        "An lcfrs consists of a regular tree grammar G and an interpretation of the terminal symbols of this grammar as linear, non-erasing functions into tuples of strings.",
        "By these functions, each tree in L(G) can be evaluated to a string.",
        "This function states that in order to compute the pair of strings that corresponds to a tree whose root node is labelled with the symbol f, one first has to compute the pair of strings corresponding to the first child of the root node ((xJ, x)) and the single string corresponding to the second child ({x2)), and then concatenate the individual components in the specified order, preceded by the terminal symbol a.",
        "□",
        "We call a function lexicalized, if it contributes exactly one terminal symbol.",
        "In an lcfrs in which all functions are lexicalized, there is a one-to-one correspondence between the nodes in an evaluated tree and the positions in the string that the tree evaluates to.",
        "Therefore, tree and string implicitly form a dependency structure, and we can speak of the dependency language generated by a lexicalized lcfrs.",
        "Equivalence We can prove that every regular dependency grammar can be transformed into a lexi-calized lcfrs that generates the same dependency language, and vice versa.",
        "The basic insight in this proof is that every order annotation in a regular dependency grammar can be interpreted as a compact description of a function in the corresponding lcfrs.",
        "The number of components in the order-annotation, and hence, the gap-degree of the resulting dependency language, corresponds to the fanout of the function: the highest number of components among the arguments of the function (Satta, 1992).",
        "A technical difficulty is caused by the fact that lcfrs can swap components: f((xJ, x)) = {ax,xJ).",
        "This commutativity needs to be compiled out during the translation into a regular dependency grammar.",
        "We write LLCFRL(k) for the class of all dependency languages generated by lexicalized lcfrs with a fanout of at most k.",
        "In particular, the class REGD(0) of regular dependency languages over projective structures is exactly the class of dependency languages generated by lexi-calized context-free grammars.",
        "Example.",
        "The gap-degree of the language generated by the grammar in Figure 3 is bounded by 1.",
        "The rules for the non-terminal A can be translated into the following functions of an equivalent lcfrs:",
        "The absence of the substring i ••• j ••• i ••• j in the order annotations of well-nested dependency structures corresponds to a restriction to 'well-bracketed' compositions of sub-structures.",
        "This restriction is central to the formalism of Coupled-Context-Free Grammar (ccfg) (Hotz and Pitsch, 1996).",
        "It is straightforward to see that every ccfg can be translated into an equivalent lcfrs.",
        "We can also prove that every lcfrs obtained from a regular dependency grammar with well-nested order annotations can be translated back into an equivalent ccfg.",
        "We write REGDwn(k) for the well-nested subclass of REGD(k), and LCCFL(k) for the class of all dependency languages generated by lexicalized ccfgs with a fanout of at most k.",
        "As a special case, Coupled-Context-Free Grammars with fanout 2 are equivalent to Tree Adjoining Grammars (tags) (Hotz and Pitsch, 1996).",
        "This enables us to generalize a previous result on the class of dependency structures generated by lexicalized tags (Bodirsky et al., 2005) to the class of generated dependency languages, LTAL.",
        "Proposition 6.",
        "REGDwn(1) = LTAL 6 Conclusion",
        "In this paper, we have presented a lexicalized reformulation of two structural constraints on non-pro-jective dependency representations, and shown that combining dependency lexicons that satisfy these constraints with a regular means of syntactic composition yields classes of mildly context-sensitive dependency languages.",
        "Our results make a significant contribution to a better understanding of the relation between the phenomenon of non-projectivity and notions of formal power.",
        "The close link between restricted forms of non-projective dependency languages and mildly context-sensitive grammar formalisms provides a promising starting point for future work.",
        "On the practical side, it should allow us to benefit from the experience in building parsers for mildly context-sensitive formalisms when addressing the task of efficient non-projective dependency parsing, at least in the framework of grammar-driven parsing.",
        "This may eventually lead to a better trade-off between structural flexibility and computational efficiency than that obtained with current systems.",
        "On a more theoretical level, our results provide a basis for comparing a variety of formally rather distinct grammar formalisms with respect to the sets of dependency structures that they can generate.",
        "Such a comparison may be empirically more adequate than one based on traditional notions of generative capacity (Kallmeyer, 2006).",
        "Acknowledgements We thank Guido Tack, Stefan Thater, and the anonymous reviewers of this paper for their detailed comments.",
        "The work of the authors is funded by the German Research Foundation."
      ]
    }
  ]
}
