{
  "info": {
    "authors": [
      "Guillaume Bonfante",
      "Bruno Guillaume",
      "Mathieu Morey",
      "Guy Perrier"
    ],
    "book": "Proceedings of the Ninth International Conference on Computational Semantics (IWCS 2011)",
    "id": "acl-W11-0108",
    "title": "Modular Graph Rewriting to Compute Semantics",
    "url": "https://aclweb.org/anthology/W11-0108",
    "year": 2011
  },
  "references": [
    "acl-E09-1001",
    "acl-P84-1110",
    "acl-W01-0807",
    "acl-W07-0208",
    "acl-W07-1210",
    "acl-W09-3744"
  ],
  "sections": [
    {
      "text": [
        "Guillaume Bonfante Nancy-Universite - LORIA",
        "bonfante@loria.fr",
        "INRIA - LORIA",
        "guillaum@loria.fr",
        "Mathieu Morey Nancy-Universite - LORIA",
        "moreymat@loria.fr",
        "Nancy-Universite - LORIA",
        "perrier@loria.fr",
        "Taking an asynchronous perspective on the syntax-semantics interface, we propose to use modular graph rewriting systems as the model of computation.",
        "We formally define them and demonstrate their use with a set of modules which produce underspecified semantic representations from a syntactic dependency graph.",
        "We experimentally validate this approach on a set of sentences.",
        "The results open the way for the production of underspecified semantic dependency structures from corpora annotated with syntactic dependencies and, more generally, for a broader use of modular rewriting systems for computational linguistics."
      ]
    },
    {
      "heading": "Introduction",
      "text": [
        "The aim of our work is to produce a semantic representation of sentences on a large scale using a formal and exact approach based on linguistic knowledge.",
        "In this perspective, the design of the syntax-semantics interface is crucial.",
        "Based on the compositionality principle, most models of the syntax-semantics interface use a synchronous approach: the semantic representation of a sentence is built step by step in parallel with its syntactic structure.",
        "According to the choice of the syntactic formalism, this approach is implemented in different ways: in a Context-Free Grammars (CFG) style framework, every syntactic rule of a grammar is associated with a semantic composition rule, as in the classical textbook by Heim and Kratzer (1998); following the principles introduced by Montague, Categorial Grammars use an homomorphism from the syntax to the semantics (Carpenter (1992)).",
        "HPSG integrates the semantic and syntactic representations in feature structures which combine by unification (Copestake et al.",
        "(2005)).",
        "LFG follows a similar principle (Dalrymple (2001)).",
        "In a synchronous approach, the syntax-semantics interface closely depends on the grammatical formalism.",
        "Building such an interface can be very costly, especially if we aim at a large coverage for the grammar.",
        "In our work, we have chosen an asynchronous approach in the sense that we start from a given syntactic analysis of a sentence to produce a semantic representation.",
        "With respect to the synchronous approach, a drawback is that the reaction of the semantics on the syntax is delayed.",
        "On the other hand, the computation of the semantics is made relatively independent from the syntactic formalism.",
        "The only constraint is the shape of the output of the syntactic analysis.",
        "In the formalisms mentioned above, the syntactic structure most often takes the form of a phrase structure, but the choice of constituency for the syntax makes the relationship with the semantics more complicated.",
        "We have chosen dependency graphs, because syntactic dependencies are closely related to predicate-argument relations.",
        "Moreover, they can be enriched with relations derived from the syntax, which are usually ignored, such as the arguments of infinitives or the anaphora determined by the syntax.",
        "One may observe that our syntactic representation of sentences involves plain graphs and not trees.",
        "Indeed, these relations can give rise to multiple governors and dependency cycles.",
        "On the semantic side, we have also chosen graphs, which are widely used in different formalisms and theories, such as DMRS (Copestake (2009)) or MTT (Mel'cuk (1988)).",
        "The principles being fixed, our problem was then to choose a model of computation well suited to transforming syntactic graphs into semantic graphs.",
        "The A-calculus, which is widely used in formal semantics, is not a good candidate because it is appropriate for computing on trees but not on graphs.",
        "Our choice naturally went to graph rewriting.",
        "Graph rewriting is barely used in computational linguistics; it could be due to the difficulty to manage large sets of rules.",
        "Among the pioneers in the use of graph rewriting, we mention Hyvonen (1984); Bohnet and Wanner (2001); Crouch (2005); Jijkoun and de Rijke (2007); Bédaride and Gardent (2009); Chaumartin and Kahane (2010).",
        "A graph rewriting system is defined as a set of graph rewrite rules and a computation is a sequence of rewrite rule applications to a given graph.",
        "The application of a rule is triggered via a mechanism of pattern matching, hence a sub-graph is isolated from its context and the result is a local modification of the input.",
        "This allows a linguistic phenomenon to be easily isolated for applying a transformation.",
        "Since each step of computation is fired by some local conditions in the whole graph, it is well known that one has no grip on the sequence of rewriting steps.",
        "The more rules, the more interaction between rules, and the consistency of the whole rule system becomes difficult to maintain.",
        "This bothers our ambition of a large coverage for the grammar.",
        "To solve this problem, we propose to organize rules in modules.",
        "A module is a set of rules that is linguistically consistent and represents a particular step of the transformation.",
        "For instance, in our proposal, there is a module transforming the syntactic arguments of verbs, predicative nouns and adjectives into their semantic arguments.",
        "Another module resolves the anaphoric links which are internal to the sentence and determined by the syntax.",
        "From a computational point of view, the grouping of a small number of rules inside a module allows some optimizations in their application, thus leading to efficiency.",
        "For instance, the confluence of rewriting is a critical feature – one computes only one normal form, not all of them – for the performance of the program.",
        "Since the underlying relation from syntax to semantics is not functional but relational, the system cannot be globally confluent.",
        "Then, it is particularly interesting to isolate subsets of confluent rules.",
        "Second point, with a small number of rules, one gets much more control on their output.",
        "In particular, it is possible to automatically infer some invariant properties of graphs along the computation within a particular module.",
        "Thus, it simplifies the writing of the rules for the next modules.",
        "It is also possible to plan a strategy in the global evaluation process.",
        "It is well known that syntactic parsers produce outputs in various formats.",
        "As a by-product of our approach, we show that the choice of the input format (that is the syntax) seems to be of low importance overall.",
        "Indeed, as far as two formats contain the same linguistic information with different representations, a system of rewrite rules can be designed to transform any graph from one format to another as a preliminary step.",
        "The same remark holds for the output formats.",
        "To illustrate our proposal, we have chosen the Paris!",
        "TreeBank (hereafter P7TB) dependency format defined by Candito et al.",
        "(2010) as the syntactic input format and the Dependency MRS format (hereafter DMRS) defined by Copestake (2009) as the semantic output format.",
        "We chose those two formats because the information they represent, if it is not complete, is relatively consensual and because both draw on large scale experiments: statistical dependency parsing for French on the one hand and the DELPH-IN project on the other hand.",
        "Actually, in our experiments, since we do not have an appropriate corpus annotated according to the P7TB standard, we used our syntactic parser Leopar whose outputs differ from this standard and we designed a rewriting system to go from one format to the other.",
        "The paper is organized as follows.",
        "In section 1, we define our graph rewriting calculus, the /5-calculus.",
        "In Section 2, we describe the particular rewriting system that is used to transform graphs from the syntactic P7TB format into the DMRS semantic format.",
        "In Section 3, we present experimental results on a test suite of sentences.",
        "!http://alpage.inria.fr/statgram/frdep/fr_stat_dep_parsing.html http://www.delph-in.net/ http://leopar.loria.fr"
      ]
    },
    {
      "heading": "1. The /3-calculus, a graph rewriting calculus",
      "text": [
        "Term rewriting and tree rewriting can be defined in a straightforward and canonical way.",
        "Graph rewriting is much more problematic and there is unfortunately no canonical definition of a graph rewriting system.",
        "Graph rewriting can be defined through a categorical approach like SPO or DPO (Rozenberg (1997)).",
        "But, in practice, it is much easier to use a more operational view of rewriting where modification of the graph (the \"right-hand side\" of a rule) is defined by means of a set of commands; the control of the way rules are applied (the \"left hand-side\") still uses pattern matching as this is done in traditional graph rewriting.",
        "In this context, a rule is a pair of a pattern and a sequence of commands.",
        "We give below the formal materials about graphs, patterns, matchings and commands.",
        "We illustrate the section with examples of rules and of rewriting.",
        "In the following, we suppose given a finite set C of edge labels corresponding to the kind of dependencies used to describe sentences.",
        "They may correspond to syntax or to semantics.",
        "For instance, we use C = {SUJ, OBJ, ARGl, ANT, .",
        ".",
        ".",
        "}.",
        "To decorate vertices, we use the standard notion of feature structures.",
        "Let W be a finite set of feature names and A be a finite set of atomic feature values.",
        "In our example, N = {cat, mood,...} and A = {passive, v, n,...}.",
        "A feature is a pair made of a feature name and a set of atomic values.",
        "The feature (cat, {v, aux}) means that the feature name cat is associated to either the value v or aux.",
        "In the sequel, we use the notation cat = v\\aux for this feature.",
        "Two features f = v and /' = v' are compatible whenever f = f and v n v' / 0.",
        "A feature structure is a finite set of features such that each feature name occurs at most once.",
        "F denotes the set of feature structures.",
        "Two feature structures are compatible if their respective features with the same name are pairwise compatible.",
        "• a finite set V of vertices;",
        "• a labelling function fs from V to F;",
        "• a labelling function lab from £ to C;",
        "• two functions a and r from £ to V which give the source and the target of each edge.",
        "Moreover, we require that two edges between the same couple of nodes cannot have the same label.",
        "Formally, a pattern is a graph and a matching <fi of a pattern V = (V', fs', £', lab', a', r') into a graph Q = (V, fs, £, lab, a, r) is an injective graph morphism from V to Q.",
        "More precisely, <fi is a couple of injective functions: (f)y from V\" to V and <fis from £' to £ which:",
        "• respects vertex labelling: fs(0y(t>)) and fs'(v) are compatible;",
        "• respects edge targets: T(<pe(e)) = (/>y(r'(e)).",
        "Commands are low-level operations on graphs that are used to describe the rewriting of the graph within a rule application.",
        "In the description below, we suppose to be given a pattern matching <fi :V – >• Q.",
        "We describe here the set of commands which we used in our experiment so far.",
        "Naturally, this set could be extended.",
        "• del_edge(a:, ß, £) removes the edge labelled £ between a and ß.",
        "More formally, we suppose that a € V-p, ß € V-p and V contains an edge e from a to ß with label I € C. Then, del_edge(a:, ß,£)(G) is the graph Q without the edge 0(e).",
        "In the following, we give only the intuitive definition of the command: thanks to injectivity of the matching <fi, we implicitly forget the distinction between x",
        "and (f)(x).",
        "• add_edge(a, ß, £) adds an edge labelled £ between a and ß.",
        "Such an edge is supposed not to exist in a",
        "• shift_edge(a;, ß) modifies all edges that are incident to a: each edge starting from a is moved to start from ß; similarly each edge ending on a is moved to end on ß;",
        "• del_node(a;) removes the a node in Q.",
        "If Q contains edges starting from a or ending on a, they are silently removed.",
        "• add_node(/5) adds a new node with identifier ß (a fresh name).",
        "• add_feat(a, f = v) adds the feature / = v to the node a.",
        "If a already contains a feature name /, it is replaced by the new one.",
        "• copy_feat(a, ß, /) copies the value of the feature named / from the node a to the node ß.",
        "If a does not contain a feature named /, nothing is done.",
        "If ß already contains a feature named /, it is replaced by the new value.",
        "Note that commands define a partial function on graphs: the action add_edge(a, ß,£) is undefined on a graph which already contains an edge labelled £ from a to ß.",
        "The action of a sequence of commands is the composition of actions of each command.",
        "Sequences of commands are supposed to be consistent with the pattern:",
        "• deLedge always refers to an edge described in the pattern and not previously modified by a deLedge or a shift_edge command;",
        "• each command refers only to identifiers defined either in the pattern or in a previous add_node;",
        "• no command refers to a node previously deleted by a deLnode command.",
        "Finally, we define a rewrite rule to be a pair of a pattern and a consistent sequence of commands.",
        "A first example of a rule is given below with the pattern on the left and the sequence of commands on the right.",
        "This rule called INIT_PASSIVE is used to remove the node corresponding to the auxiliary of the passive construction and to modify the features accordingly.",
        "INIT_PASSIVE del_edge(/3, a, AUX_PASS) shift_edge(a, ß) del_node(a)",
        "Our second example (PASSIVE_ATS) illustrates the add_node command.",
        "It is used in a passive construction where the semantic subject of the verb is not realized syntactically.",
        "\\",
        "a",
        "ß",
        "cat = v",
        "cat",
        "= V",
        "voice = active",
        "voice",
        "= unk",
        "We consider a graph Q and a rewrite rule r = (V, [c\\,..., Ck\\).",
        "We say that Q' is obtained from Q by a rewrite step with the r rule (written Q – >r Q') if there is a matching morphism <fi : V – > Q and Q' is obtained from Q by applying the composition of commands Ck o ... o c\\.",
        "Let us now illustrate two rewrite steps with the rules above.",
        "Consider the first graph below which is a syntactic dependency structure for the French sentence \"Marie est considérée comme brillante \" [Mary is considered as bright].",
        "The second graph is obtained by application of the INIT_PASSIVE rewrite rule and the last one with the PASSIVE_ATS rewrite rule.",
        "SUJ ATS OBJ",
        "Marie est .considérée comme brillante lemma = marie lemma = considérer lemma = comme lemma = brillant voice = passive tense = present",
        "A module contains a set of rewrite rules but, in order to have a finer control on the output of these modules, it is useful to declare some forbidden patterns.",
        "Hence a module is defined by a set 1Z of rules and a set V of forbidden patterns.",
        "For a given module M = (TZ, V), we say that Q' is an M-normalform of the graph Q if there is a sequence of rewriting steps with rules of 7Z from Q to Q'\\ Q – >ri Q\\ – >r2 G2 ■ ■ ■ – >rk Q', if no rule of 7Z can be applied to Q' and no pattern of V matches in Q'.",
        "In our experiment, forbidden patterns are often used to control the subset of edges allowed in normal forms.",
        "For instance, the NORMAL module contains the forbidden pattern: D AUXJASS> Q Hence, we can then safely suppose that no graph contains any AUX_PASS edge afterward."
      ]
    },
    {
      "heading": "2. From syntactic dependency graphs to semantic graphs",
      "text": [
        "Linguistic theories diverge on many issues including the exact definition of the linguistic levels and the relationships between them.",
        "Our aim here is not to commit to any linguistic theory but rather to demonstrate that graph rewriting is an adequate and realistic computational framework for the syntax-semantics interface.",
        "Consequently, our approach is bound to neither the (syntactic and semantic) formats we have chosen nor the transformation modules we have designed; both are mainly meant to exemplify our proposal.",
        "PASSIVE_ATS",
        "\\",
        "SUJ ATS II",
        "\\",
        "ci = del_edge(a, ß, suj) es = add_feat(a, voice = active)",
        "c2 = add_edge(a, ß, obj) c6 = add_node((5)",
        "c3 = del_edge(a, 7, ats) c7 = add_edge(a, suj, S)",
        "c4 = add_edge(a, 7, ato)",
        "ß",
        "a",
        "7",
        "cat = v voice = passive",
        "AUX_PASS",
        "ATS",
        "OBJ",
        "1",
        "1",
        "II",
        "Marie",
        "est",
        "considérée",
        "comme",
        "brillante",
        "cat -",
        "= np",
        "cat",
        "=",
        "V",
        "cat =",
        "V",
        "cat = prep",
        "cat = adj",
        "lemma -",
        "= Marie",
        "lemma",
        "=",
        "être",
        "lemma =",
        "considérer",
        "lemma = comme",
        "lemma = brillant",
        "voice",
        "=",
        "active",
        "voice =",
        "unk",
        "tense",
        "=",
        "present",
        "OBJ",
        "ATO",
        "OBJ",
        "\\",
        "1",
        "1",
        "II",
        "1",
        "e",
        "Marie",
        "est .considérée",
        "comme",
        "brillante",
        "cat = np",
        "cat =",
        "V",
        "cat = prep",
        "cat = adj",
        "lemma = marie",
        "lemma = voice = tense =",
        "considérer",
        "active present",
        "lemma = comme",
        "lemma = brillant",
        "Our syntactic and semantic formats both rely on the notion of linguistic dependency.",
        "The syntactic format is an enrichment of the one which was designed to annotate the French Treebank (Abeillé and Barrier (2004)) with surface syntactic dependencies (Candito et al.",
        "(2010)).",
        "The enrichment is twofold:",
        "• if they are present in the sentence, the deep arguments of infinitives and participles (from participial subordinate clauses) are marked with the usual labels of syntactic functions,",
        "• the anaphora relations that are predictable from the syntax (i.e. the antecedents of relative, reflexive and repeated pronouns) are marked with a special label ant.",
        "This additional information can already be provided by many syntactic parsers and is particularly interesting to compute semantics.",
        "The semantic format is Dependency Minimal Recursion Semantics (DMRS) which was introduced by Copestake (2009) as a compact and easily readable equivalent to Robust Minimal Recursion Semantics (RMRS), which was defined by Copestake (2007).",
        "This underspecified semantic formalism was designed for large scale experiments without committing to fine-grained semantic choices.",
        "DMRS graphs contain the predicate-argument relations, the restriction of generalized quantifiers and the mode of combination between predicates.",
        "Predicate-argument relations are labelled arg«, where i is an integer following a fixed order of obliqueness suj, obj, ats, ato, a-obj, de-obj____Naturally, the lexicon must be consistent with this ordering.",
        "The restrictions of generalized quantifiers are labelled rstr ; their bodies are not overtly expressed but can be retrieved from the graph.",
        "There are three ways of combining predicates:",
        "• eq when two predicates are elements of a same conjunction;",
        "• h when a predicate is in the scope of another predicate; it is not necessarily one of its arguments because quantifiers may occur between them;",
        "• neq for all other cases.",
        "Graph rewriting allows to proceed step by step to the transformation of a syntactic graph into a semantic one, by associating a rewrite rule to each linguistic rule.",
        "While the effect of every rule is local, grouping rules in modules allows a better control on the global effect of all rules.",
        "We do not have the space here to propose a system of rules that covers the whole French grammar.",
        "We however propose six modules which cover a significative part of this grammar (cleft clauses, coordination, enumeration, comparatives and ellipses are left aside but they can be handled by other rewrite modules):",
        "• NORMAL handles the regular syntactic transformations involving predicates: it computes tense and transforms all redistributions of arguments (passive and middle voices, impersonal constructions and the combination of them) to the active canonical form.",
        "This reduces the number of rules required to produce the predicate-argument relations in the ARG module below.",
        "• PREP removes affixes, prepositions and complementizers.",
        "• ARG transforms the verbal, nominal and adjectival predicative phrases into predicate-argument relations.",
        "voice = active",
        "• DET translates the determiner dependencies (denoted det) to generalized quantifiers.",
        "• MOD interprets the various modifier dependencies (denoted mod), according to their specificity: adjectives, adverbs, adjunct prepositional phrases, participial clauses, relative clauses, adjunct clauses.",
        "• ANA interprets all anaphoric relations that are determined by the syntax (denoted ant).",
        "Modules provide an easy way to control the order in which rules are fired.",
        "In order to properly set up the rules in modules, we first have to fix the global ordering of the modules.",
        "Some ordering constraints are evident: for instance, NORMAL must precede PREP, which must precede ARG.",
        "The rules we present in the following are based on the order NORMAL, PREP, ARG, DET, MOD, ANA.",
        "The NORMAL module has two effects: it merges tense and voice auxiliaries with their past participle and brings all the argument redistributions back to the canonical active form.",
        "This module accounts for the passive and middle voices and the impersonal construction for verbs that are not essentially impersonal.",
        "The combination of the two voices with the impersonal construction is naturally expressed by the composition of the corresponding rewrite rules.",
        "The two rules given in section 1.4 are part of this module.",
        "The first rule (INIT_PASSIVE) merges the past participle of the verb with its passive auxiliary.",
        "The auxiliary brings its mood and tense to the verb, which is marked as being passive.",
        "The second rule (PASSIVE_ATS) transforms a passive verb with a subject and an attribute of the subject into its active equivalent with a semantically undetermined subject, an object (which corresponds to the subject of the passive form) and an attribute of the object (which corresponds to the attribute of the subject of the passive form).",
        "The PREP module removes affixes, prepositions and complementizers.",
        "For example, the rule given here merges prepositions with the attribute of the object that they introduce.",
        "The value of the preposition is kept to compute the semantics.",
        "PREP_ATO",
        "The ARG module transforms the syntactic arguments of a predicative word (a verb, a common noun or an adjective) into its semantic arguments.",
        "Following DMRS, the predicate-argument relations are not labelled with thematic roles but only numbered.",
        "The numbering reflects the syntactic obliqueness.",
        "DET reverts the determiner dependencies (labelled det) from common nouns to determiners into dependencies of type rstr from the corresponding generalized quantifier to the nominal predicate which is the core of their restriction.",
        "I",
        "a",
        "ß",
        "cat = n\\np\\pro",
        "MOD deals with the modifier dependencies (labelled mod, mod_rel and mod_loc), providing rules for the different kinds of modifiers.",
        "Adjectives and adverbs are translated as predicates whose first argument is the modified entity.",
        "The modifier and modified entities are in a conjunction (eq), except for scopal adverbs which take scope (h) over the modified predicate.",
        "Because only lexical information enables to differentiate scopal from non-scopal adverbs, we consider all adverbs to be systematically ambiguous at the moment.",
        "Adjunct prepositional phrases (resp.",
        "clauses) have a similar rule except that their corresponding predicate is the translation of the preposition (resp.",
        "complementizer), which has two arguments: the modified entity and the noun (resp.",
        "verb) which heads the phrase (resp.",
        "clause).",
        "Participial and relative clauses exhibit a relation labelled eq or neq between the head of the clause and the antecedent, depending on the restrictive or appositive type of the clause.",
        "ANA deals with dependencies of type ant and merges their source and their target.",
        "We apply them to reflexive, relative and repeated pronouns."
      ]
    },
    {
      "heading": "3. Experiments",
      "text": [
        "For the experimentation, we are interested in a test suite which is at the same time small enough to be manually validated and large enough to cover a rich variety of linguistic phenomena.",
        "As said earlier, we use the P7 surface dependency format as input, so the first attempt at building a test suite is to consider examples in the guide which describes the format.",
        "By nature, an annotation guide tries to cover a large range of phenomena with a small set of examples.",
        "The latest version of this guide (Candito et al.",
        "(2010)) contains 186 linguistic examples.",
        "In our current implementation of the semantic constructions, we leave out clefts, coordinations and comparatives.",
        "We also leave out a small set of exotic sentences for which we are not able to give a sensible syntactic structure.",
        "Finally, our experiment runs on 116 French sentences.",
        "Syntactic structures following P7 specifications are obtained with some graph rewriting on the output of our parser.",
        "Each syntactic structure was manually checked and corrected when needed.",
        "Then, graph rewriting with the modules described in the previous section is performed.",
        "For all of these sentences, we produce at least one normal form.",
        "Even if DMRS is underspecified, our system can output several semantic representations for one syntactic structure (for instance, for appositive and restrictive relative clauses).",
        "We sometimes overgenerate because we do not use lexical information like the difference between scopal and non-scopal adverbs.",
        "The result for three sentences is given below and the full set is available on a web page .",
        "[012] \"Le français se parle de moins en moins dans les conférences.\"",
        "[The French language is less and less spoken in conferences.]",
        "le français",
        "cat=det cat=n",
        "parle de moins en moins dans les conférences",
        "cat=prep cat=det prep=loc",
        "[057] \"J'encourage Marie a venir.\"",
        "[I invite Mary to come.]",
        "encourage",
        "cat=prep prep=à",
        "cat=v mood=inf voice=unk",
        "[106] \"La serie dont Pierre connaît la fin\" [The story Peter knows the end of]",
        "/connaît/",
        "cat=v mood=ind tense=pres voice=active /série/ cat=n",
        "Conclusion",
        "In this paper, we have shown the relevance of modular graph rewriting to compute semantic representations from graph-shaped syntactic structures.",
        "The positive results of our experiments on a test suite of varied sentences make us confident that the method can apply to large corpora.",
        "The particular modular graph rewriting system presented in the paper was merely here to illustrate the method, which can be used for other input and output formats.",
        "There is another aspect to the flexibility of the method: we may start from the same system of rules and enrich it with new rules to get a finer semantic analysis – if DMRS is considered as providing a minimal analysis – or integrate lexical information.",
        "The method allows the semantic ambiguity to remain unsolved within underspecified representations or to be solved with a rule system aiming at computing models of underspecified representations.",
        "Moreover, we believe that its flexibility makes graph rewriting a convenient framework to deal with idiomatic expressions."
      ]
    }
  ]
}
