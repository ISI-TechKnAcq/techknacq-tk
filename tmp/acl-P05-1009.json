{
  "info": {
    "authors": [
      "Radu Soricut",
      "Daniel Marcu"
    ],
    "book": "Annual Meeting of the Association for Computational Linguistics",
    "id": "acl-P05-1009",
    "title": "Towards Developing Generation Algorithms for Text-To-Text Applications",
    "url": "https://aclweb.org/anthology/P05-1009",
    "year": 2005
  },
  "references": [
    "acl-J93-2003",
    "acl-J98-4003",
    "acl-J99-4005",
    "acl-P02-1040",
    "acl-P95-1034"
  ],
  "sections": [
    {
      "heading": "Abstract",
      "text": [
        "We describe a new sentence realization framework for text-to-text applications.",
        "This framework uses IDL-expressions as a representation formalism, and a generation mechanism based on algorithms for intersecting IDL-expressions with probabilistic language models.",
        "We present both theoretical and empirical results concerning the correctness and efficiency of these algorithms."
      ]
    },
    {
      "heading": "1 Introduction",
      "text": [
        "Many of today’s most popular natural language applications – Machine Translation, Summarization, Question Answering – are text-to-text applications.",
        "That is, they produce textual outputs from inputs that are also textual.",
        "Because these applications need to produce well-formed text, it would appear natural that they are the favorite testbed for generic generation components developed within the Natural Language Generation (NLG) community.",
        "Over the years, several proposals of generic NLG systems have been made: Penman (Matthiessen and Bateman, 1991), FUF (Elhadad, 1991), Nitrogen (Knight and Hatzivassiloglou, 1995), Fergus (Bangalore and Rambow, 2000), HALogen (Langkilde-Geary, 2002), Amalgam (Corston-Oliver et al., 2002), etc.",
        "Instead of relying on such generic NLG systems, however, most of the current text-to-text applications use other means to address the generation need.",
        "In Machine Translation, for example, sentences are produced using application-specific “decoders”, inspired by work on speech recognition (Brown et al., 1993), whereas in Summarization, summaries are produced as either extracts or using task-specific strategies (Barzilay, 2003).",
        "The main reason for which text-to-text applications do not usually involve generic NLG systems is that such applications do not have access to the kind of information that the input representation formalisms of current NLG systems require.",
        "A machine translation or summarization system does not usually have access to deep subject-verb or verb-object relations (such as ACTOR, AGENT, PATIENT, POSSESSOR, etc.)",
        "as needed by Penman or FUF, or even shallower syntactic relations (such as subject, object, premod, etc.)",
        "as needed by HALogen.",
        "In this paper, following the recent proposal made by Nederhof and Satta (2004), we argue for the use of IDL-expressions as an application-independent, information-slim representation language for text-to-text natural language generation.",
        "IDL-expressions are created from strings using four operators: concatenation (•), interleave (11), disjunction (V), and lock (x).",
        "We claim that the IDL formalism is appropriate for text-to-text generation, as it encodes meaning only via words and phrases, combined using a set of formally defined operators.",
        "Appropriate words and phrases can be, and usually are, produced by the applications mentioned above.",
        "The IDL operators have been specifically designed to handle natural constraints such as word choice and precedence, constructions such as phrasal combination, and underspecifications such as free word order.",
        "In Table 1, we present a summary of the representation and generation characteristics of current NLG systems.",
        "We mark by G characteristics that are needed/desirable in a generation component for text-to-text applications, and by a characteristics that make the proposal inapplicable or problematic.",
        "For instance, as already argued, the representation formalism of all previous proposals except for IDL is problematic (e) for text-to-text applications.",
        "The IDL formalism, while applicable to text-to-text applications, has the additional desirable property that it is a compact representation, while formalisms such as word-lattices and non-recursive CFGs can have exponential size in the number of words available for generation (Nederhof and Satta, 2004).",
        "While the IDL representational properties are all desirable, the generation mechanism proposed for IDL by Nederhof and Satta (2004) is problematic (e), because it does not allow for scoring and ranking of candidate realizations.",
        "Their generation mechanism, while computationally efficient, involves intersection with context free grammars, and therefore works by excluding all realizations that are not accepted by a CFG and including (without ranking) all realizations that are accepted.",
        "The approach to generation taken in this paper is presented in the last row in Table 1, and can be summarized as a G tiling of generation characteristics of previous proposals (see the shaded area in Table 1).",
        "Our goal is to provide an optimal generation framework for text-to-text applications, in which the representation formalism, the generation mechanism, and the computational properties are all needed and desirable (®).",
        "Toward this goal, we present a new generation mechanism that intersects IDL-expressions with probabilistic language models.",
        "The generation mechanism implements new algorithms, which cover a wide spectrum of runtime behaviors (from linear to exponential), depending on the complexity of the input.",
        "We also present theoretical results concerning the correctness and the efficiency input IDL-expression) of our algorithms.",
        "We evaluate these algorithms by performing experiments on a challenging word-ordering task.",
        "These experiments are carried out under a high-complexity generation scenario: find the most probable sentence realization under an n-gram language model for IDL-expressions encoding bags-of-words of size up to 25 (up to 1025 possible realizations!).",
        "Our evaluation shows that the proposed algorithms are able to cope well with such orders of complexity, while maintaining high levels of accuracy."
      ]
    },
    {
      "heading": "2 The IDL Language for NLG",
      "text": []
    },
    {
      "heading": "2.1 IDL-expressions",
      "text": [
        "IDL-expressions have been proposed by Nederhof & Satta (2004) (henceforth N&S) as a representation for finite languages, and are created from strings using four operators: concatenation (•), interleave (11), disjunction (V), and lock (x).",
        "The semantics of IDL-expressions is given in terms of sets of strings.",
        "The concatenation (•) operator takes two arguments, and uses the strings encoded by its argument expressions to obtain concatenated strings that respect the order of the arguments; e.g., a • b encodes the singleton set {ab}.",
        "The Interleave (11) operator interleaves the strings encoded by its argument expressions; e.g., II (a • b, c) encodes the set {cab, acb, abc}.",
        "The Disjunction (V) operator allows a choice among the strings encoded by its argument expressions; e.g., V (a, b) encodes the set {a, b}.",
        "The Lock (x) operator takes only one argument, and “locks-in” the strings encoded by its argument expression, such that no additional material can be interleaved; e.g., x (a • b), c) encodes the set {cab, abc}.",
        "Consider the following IDL-expression: II (finally, V(x (the • prisoners), x (the • captives)) were • released) (1) The concatenation (•) operator captures precedence constraints, such as the fact that a determiner like",
        "the appears before the noun it determines.",
        "The lock (x) operator enforces phrase-encoding constraints, such as the fact that the captives is a phrase which should be used as a whole.",
        "The disjunction (V) operator allows for multiple word/phrase choice (e.g., the prisoners versus the captives), and the interleave (11) operator allows for word-order freedom, i.e., word order underspecification at meaning representation level.",
        "Among the strings encoded by IDL-expression 1 are the following: finally the prisoners were released the captives finally were released the prisoners were finally released The following strings, however, are not part of the language defined by IDL-expression 1: the finally captives were released the prisoners were released finally the captives released were The first string is disallowed because the x operator locks the phrase the captives.",
        "The second string is not allowed because the I I operator requires all its arguments to be represented.",
        "The last string violates the order imposed by the precedence operator between were and released."
      ]
    },
    {
      "heading": "2.2 IDL-graphs",
      "text": [
        "IDL-expressions are a convenient way to compactly represent finite languages.",
        "However, IDL-expressions do not directly allow formulations of algorithms to process them.",
        "For this purpose, an equivalent representation is introduced by N&S, called IDL-graphs.",
        "We refer the interested reader to the formal definition provided by N&S, and provide here only an intuitive description of IDL-graphs.",
        "We illustrate in Figure 1 the IDL-graph corresponding to IDL-expression 1.",
        "In this graph, vertices vs and ve are called initial and final, respectively.",
        "Vertices V0, v2 with ingoing �--labeled edges, and v1, V20 with outgoing -]-labeled edges, for example, result from the expansion of the 11 operator, while vertices V3, V4 with ingoing E-labeled edges, and v9, V14 with outgoing E-labeled edges result from the expansion of the V operator.",
        "Vertices V5 to v8 and vlo to V13 result from the expansion of the two x operators, respectively.",
        "These latter vertices are also shown to have rank 1, as opposed to rank 0 (not shown) assigned to all other vertices.",
        "The ranking of vertices in an IDL-graph is needed to enforce a higher priority on the processing of the higher-ranked vertices, such that the desired semantics for the lock operator is preserved.",
        "With each IDL-graph G(7r) we can associate a finite language: the set of strings that can be generated by an IDL-specific traversal of G(7r), starting from Vs and ending in v. An IDL-expression 7r and its corresponding IDL-graph G (7r) are said to be equivalent because they generate the same finite language, denoted L (7r) ."
      ]
    },
    {
      "heading": "2.3 IDL-graphs and Finite-State Acceptors",
      "text": [
        "To make the connection with the formulation of our algorithms, in this section we link the IDL formalism with the more classical formalism of finite-state acceptors (FSA) (Hopcroft and Ullman, 1979).",
        "The FSA representation can naturally encode precedence and multiple choice, but it lacks primitives corresponding to the interleave (11) and lock (x) operators.",
        "As such, an FSA representation must explicitly enumerate all possible interleavings, which are implicitly captured in an IDL representation.",
        "This correspondence between implicit and explicit inter-leavings is naturally handled by the notion of a cut of an IDL-graph G(7r).",
        "Intuitively, a cut through G(7r) is a set of vertices that can be reached simultaneously when traversing G(7r) from the initial node to the final node, following the branches as prescribed by the encoded Z, D, and L operators, in an attempt to produce a string in L(7r).",
        "More precisely, the initial vertex vs is considered a cut (Figure 2 (a)).",
        "For each vertex in a given cut, we create a new cut by replacing the start vertex of some edge with the end vertex of that edge, observing the following rules:",
        "• the vertex that is the start of several edges labeled using the special symbol �- is replaced by a sequence of all the end vertices of these edges (for example, VOV2 is a cut derived from Vs (Figure 2 (b))); a mirror rule handles the special symbol -1; • the vertex that is the start of an edge labeled using vocabulary items or E is replaced by the end vertex of that edge (for example, V l V2, VOV3, VOV5, VOV6 are cuts derived from VOV2, VOV2,",
        "vov3, and vov5, respectively, see Figure 2 (c-d)), only if the end vertex is not lower ranked than any of the vertices already present in the cut (for example, vlv6 is not a cut that can be derived from vov6, see Figure 2 (e)).",
        "Note the last part of the second rule, which restricts the set of cuts by using the ranking mechanism.",
        "If one would allow vlv6 to be a cut, one would imply that finally may appear inserted between the words of the locked phrase the prisoners.",
        "We now link the IDL formalism with the FSA formalism by providing a mapping from an IDL-graph G(7) to an acyclic finite-state acceptor A(7).",
        "Because both formalisms are used for representing finite languages, they have equivalent representational power.",
        "The IDL representation is much more compact, however, as one can observe by comparing the IDL-graph in Figure 1 with the equivalent finite-state acceptor A(7r) in Figure 3.",
        "The set of states of A(7r) is the set of cuts of G(7r).",
        "The initial state of the finite-state acceptor is the state corresponding to cut vs, and the final states of the finite-state acceptor are the state corresponding to cuts that contain ve.",
        "In what follows, we denote a state of A(7r) by the name of the cut to which it corresponds.",
        "A transition labeled a in A (7) between state [v?",
        "... v' ... vj ] and state IN � ... vj ... v''] occurs if there is an edge (vj , a vj') in G(7).",
        "For the example in Figure 3, the transition labeled were between states [vov16] and [vov17] occurs because of the edge labeled were between nodes V16 and V17 (Figure 1), whereas the transition labeled finally between states [vov16] and [V IV 161 occurs because of the edge labeledfinally between nodes vo and vl (Figure 1).",
        "The two representations G(7r) and A(7r) are equivalent in the sense that the language generated by IDL-graph G(7) is the same as the language accepted by FSA A(7).",
        "It is not hard to see that the conversion from the IDL representation to the FSA representation destroys the compactness property of the IDL formalism, because of the explicit enumeration of all possible interleavings, which causes certain labels to appear repeatedly in transitions.",
        "For example, a transition labeled finally appears 11 times in the finite-state acceptor in Figure 3, whereas an edge labeled finally appears only once in the IDL-graph in Figure 1."
      ]
    },
    {
      "heading": "3 Computational Properties of IDL-expressions",
      "text": []
    },
    {
      "heading": "3.1 IDL-graphs and Weighted Finite-State Acceptors",
      "text": [
        "As mentioned in Section 1, the generation mechanism we propose performs an intersection of IDL-expressions with n-gram language models.",
        "Following (Mohri et al., 2002; Knight and Graehl, 1998), we implement language models using weighted finite-state acceptors (wFSA).",
        "In Section 2.3, we presented a mapping from an IDL-graph G(7) to a finite-state acceptor A (7).",
        "From such a finite-state acceptor A(7), we arrive at a weighted finite-state acceptor W(7), by splitting the states of A(7) ac",
        "cording to the information needed by the language model to assign weights to transitions.",
        "For example, under a bigram language model LM, state [V I V 16 ] in Figure 3 must be split into three different states, [Prisoners, v1v161, [captives, v1v161, and [finally, v1v161, according to which (non-epsilon) transition was last used to reach this state.",
        "The transitions leaving these states have the same labels as those leaving state [v1v16], and are now weighted using the language model probability distributions PLM(•jPrisoners), PLM(•Icaptives), and PLM(•Ifinally), respectively.",
        "Note that, at this point, we already have a na¨ıve algorithm for intersecting IDL-expressions with n-gram language models.",
        "From an IDL-expression 7, following the mapping 7 – � G(7C) – � A(7C) _� W(7), we arrive at a weighted finite-state acceptor, on which we can use a single-source shortest-path algorithm for directed acyclic graphs (Cormen et al., 2001) to extract the realization corresponding to the most probable path.",
        "The problem with this algorithm, however, is that the premature unfolding of the IDL-graph into a finite-state acceptor destroys the representation compactness of the IDL representation.",
        "For this reason, we devise algorithms that, although similar in spirit with the single-source shortest-path algorithm for directed acyclic graphs, perform on-the-fly unfolding of the IDL-graph, with a mechanism to control the unfolding based on the scores of the paths already unfolded.",
        "Such an approach has the advantage that prefixes that are extremely unlikely under the language model may be regarded as not so promising, and parts of the IDL-expression that contain them may not be unfolded, leading to significant savings."
      ]
    },
    {
      "heading": "3.2 Generation via Intersection of IDL-expressions with Language Models",
      "text": [
        "Algorithm IDL-NGLM-BFS The first algorithm that we propose is algorithm IDL-NGLM-BFS in Figure 4.",
        "The algorithm builds a weighted finite-state acceptor W corresponding to an IDL-graph G incrementally, by keeping track of a set of active states, called active.",
        "The incrementality comes from creating new transitions and states in W originating in these active states, by unfolding the IDL-graph G; the set of newly unfolded states is called unfold.",
        "The new transitions in W are weighted ac",
        "cording to the language model.",
        "If a final state of W is not yet reached, the while loop is closed by making the unfold set of states to be the next set of active states.",
        "Note that this is actually a breadth-first search (BFS) with incremental unfolding.",
        "This algorithm still unfolds the IDL-graph completely, and therefore suffers from the same drawback as the na¨ıve algorithm.",
        "The interesting contribution of algorithm IDL-NGLM-BFS, however, is the incremental unfolding.",
        "If, instead of line 8 in Figure 4, we introduce mechanisms to control which unfold states become part of the active state set for the next unfolding iteration, we obtain a series of more effective algorithms.",
        "Algorithm IDL-NGLM-A* We arrive at algorithm IDL-NGLM-A* by modifying line 8 in Figure 4, thus obtaining the algorithm in Figure 5.",
        "We use as control mechanism a priority queue, astarQ, in which the states from unfold are PUSH-ed, sorted according to an admissible heuristic function (Russell and Norvig, 1995).",
        "In the next iteration, active is a singleton set containing the state POP-ed out from the top of the priority queue.",
        "Algorithm IDL-NGLM-BEAM We arrive at algorithm IDL-NGLM-BEAM by again modifying line 8 in Figure 4, thus obtaining the algorithm in Figure 6.",
        "We control the unfolding using a probabilistic beam beam, which, via the BEAMSTATES function, selects as active states only the states in",
        "unfold reachable with a probability higher or equal to the current maximum probability times the probability beam beam."
      ]
    },
    {
      "heading": "3.3 Computing Admissible Heuristics for IDL-expressions",
      "text": [
        "The IDL representation is ideally suited for computing accurate admissible heuristics under language models.",
        "These heuristics are needed by the IDL-NGLM-A* algorithm, and are also employed for pruning by the IDL-NGLM-BEAM algorithm.",
        "For each state S in a weighted finite-state acceptor W corresponding to an IDL-graph G, one can efficiently extract from G – without further unfolding – the set1 of all edge labels that can be used to reach the final states of W. This set of labels, denoted FESII, is an overestimation of the set of future events reachable from S, because the labels under the V operators are all considered.",
        "From FES\" and the n-1 labels (when using an n-gram language model) recorded in state S we obtain the set of label sequences of length n-1.",
        "This set, denoted FCE S, is an (over)estimated set of possible future conditioning events for state S, guaranteed to contain the most cost-efficient future conditioning events for state S. Using FCES, one needs to extract from FE all the set of most cost-efficient future events from under each V operator.",
        "We use this set, denoted FES, to arrive at an admissible heuristic for state S under a language model LM, using Equation 2:",
        "If h* (S) is the true future cost for state S, we guarantee that h(S) < h*(S) from the way FES and FCES are constructed.",
        "Note that, as it usually happens with admissible heuristics, we can make h(S) come arbitrarily close to h* (S), by computing increasingly better approximations FCES of FCES.",
        "Such approximations, however, require increasingly advanced unfoldings of the IDL-graph G (a complete unfolding of G for state S gives FCES – FCES, and consequently h(S) = h* (S)).",
        "It follows that arbitrarily accurate admissible heuristics exist for IDL-expressions, but computing them on-the-fly requires finding a balance between the time and space requirements for computing better heuristics and the speed-up obtained by using them in the search algorithms."
      ]
    },
    {
      "heading": "3.4 Formal Properties of IDL-NGLM algorithms",
      "text": [
        "The following theorem states the correctness of our algorithms, in the sense that they find the maximum probability path encoded by an IDL-graph under an n-gram language model.",
        "Theorem 1 Let 7r be an IDL-expression, G((r) its IDL-graph, and W((r) its wFSA under an n-gram language model LM.",
        "Algorithms IDL-NGLM-BFS and IDL-NGLM-A* find the 1Actually, these are multisets, as we treat multiply-occurring labels as separate items.",
        "path of maximum probability under LM.",
        "Algorithm IDL-NGLM-BEAM finds the path of maximum probability under LM, if all states in W(7) along this path are selected by its BEAMS TATES function.",
        "The proof of the theorem follows directly from the correctness of the BFS and A* search, and from the condition imposed on the beam search.",
        "The next theorem characterizes the runtime complexity of these algorithms, in terms of an input IDL-expression 7r and its corresponding IDL-graph G(7r) complexity.",
        "There are three factors that linearly influence the runtime complexity of our algorithms: a is the maximum number of nodes in G(7r) needed to represent a state in A(7r) – a depends solely on 7r; w is the maximum number of nodes in G(7r) needed to represent a state in W (7r) – w depends on 7r and n, the length of the context used by the n-gram language model; and K is the number of states of W (7r) – K also depends on 7r and n. Of these three factors, K is by far the predominant one, and we simply call K the complexity of an IDL-expression.",
        "Theorem 2 Let 7r be an IDL-expression, G(7r) its IDL-graph, A(7r) its FSA, and W (7r) its wFSA under an n-gram language model.",
        "Let V[A(7r)] be the set of states of A(7), and V [W (7r)] the set of states of W(7).",
        "Let also a = maxCCV[A(,)]ICI, w = maxCCV[W(_,)]jcj, and",
        "and IDL-NGLM-BEAM have runtime complexity O (awK).",
        "Algorithm IDL-NGLM-A* has runtime complexity O (awK log K).",
        "We omit the proof here due to space constraints.",
        "The fact that the runtime behavior of our algorithms is linear in the complexity of the input IDL-expression (with an additional log factor in the case of A* search due to priority queue management) allows us to say that our algorithms are efficient with respect to the task they accomplish.",
        "We note here, however, that depending on the input IDL-expression, the task addressed can vary in complexity from linear to exponential.",
        "That is, for the intersection of an IDL-expression 7 _ ✄ (wl, ... , wn) (bag of n words) with a trigram language model, we have a(7) = n, w(7) = n + 2, K = cn, c > 1, and therefore a 0(n2cn) complexity.",
        "This exponential complexity comes as no surprise given that the problem of intersecting an n-gram language model with a bag of words is known to be NP-complete (Knight, 1999).",
        "On the other hand, for intersecting an IDL-expression 7r = wl ✂ ... ✂ wn (sequence of n words) with a trigram language model, we have a(7) = 1, w(7r) = 3, and K = n, and therefore an O (n) generation algorithm.",
        "In general, for IDL-expressions for which a is bounded, which we expect to be the case for most practical problems, our algorithms perform in polynomial time in the number of words available for generation."
      ]
    },
    {
      "heading": "4 Evaluation of IDL-NGLM Algorithms",
      "text": [
        "In this section, we present results concerning the performance of our algorithms on a word-ordering task.",
        "This task can be easily defined as follows: from a bag of words originating from some sentence, reconstruct the original sentence as faithfully as possible.",
        "In our case, from an original sentence such as “the gifts are donated by amer-ican companies”, we create the IDL-expression (s) ✂ ✄ (the, gifts, donated, companies, by, are, american) ✂ (/s), from which some algorithm realizes a sentence such as “donated by the american companies are gifts”.",
        "Note the natural way we represent in an IDL-expression beginning and end of sentence constraints, using the ✂ operator.",
        "Since this is generation from bag-of-words, the task is known to be at the high-complexity extreme of the runtime behavior of our algorithms.",
        "As such, we consider it a good test for the ability of our algorithms to scale up to increasingly complex inputs.",
        "We use a state-of-the-art, publicly available toolkit2 to train a trigram language model using Kneser-Ney smoothing, on 10 million sentences (170 million words) from the Wall Street Journal (WSJ), lower case and no final punctuation.",
        "The test data is also lower case (such that upper-case words cannot be hypothesized as first words), with final punctuation removed (such that periods cannot be hypothesized as final words), and consists of 2000 unseen WSJ sentences of length 3-7, and 2000 unseen WSJ sentences of length 10-25.",
        "The algorithms we tested in this experiments were the ones presented in Section 3.2, plus two baseline algorithms.",
        "The first baseline algorithm, L, uses an",
        "inverse-lexicographic order for the bag items as its output, in order to get the word the on sentence initial position.",
        "The second baseline algorithm, G, is a greedy algorithm that realizes sentences by maximizing the probability of joining any two word sequences until only one sequence is left.",
        "For the A✣ algorithm, an admissible cost is computed for each state S in a weighted finite-state automaton, as the sum (over all unused words) of the minimum language model cost (i.e., maximum probability) of each unused word when conditioning over all sequences of two words available at that particular state for future conditioning (see Equation 2, with FES = FE\").These estimates are also used by the beam algorithm for deciding which IDL-graph nodes are not unfolded.",
        "We also test a greedy version of the A✣ algorithm, denoted A✣✡, which considers for unfolding only the nodes extracted from the priority queue which already unfolded a path of length greater than or equal to the maximum length already unfolded minus k (in this notation, the A✣ algorithm would be denoted A✣ ✁ ).",
        "For the beam algorithms, we use the notation B✂ to specify a probabilistic beam of size ✂, i.e., an algorithm that beams out the states reachable with probability less than the current maximum probability times ✂.",
        "Our first batch of experiments concerns bags-of-words of size 3-7, for which exhaustive search is possible.",
        "In Table 2, we present the results on the word-ordering task achieved by various algorithms.",
        "We evaluate accuracy performance using two automatic metrics: an identity metric, ID, which measures the percent of sentences recreated exactly, and BLEU (Papineni et al., 2002), which gives the geometric average of the number of uni-, bi-, tri-, and four-grams recreated exactly.",
        "We evaluate the search performance by the percent of Search Errors made by our algorithms, as well as a percent figure of Estimated Search Errors, computed as the percent of searches that result in a string with a lower probability than the probability of the original sentence.",
        "To measure the impact of using IDL-expressions for this task, we also measure the percent of unfolding of an IDL graph with respect to a full unfolding.",
        "We report speed results as the average number of seconds per bag-of-words, when using a 3.0GHz CPU machine under a Linux OS.",
        "The first notable result in Table 2 is the savings",
        "BLEU), Search Errors (and Estimated Search Errors), space savings (Unfold), and speed results.",
        "achieved by the A✣ algorithm under the IDL representation.",
        "At no cost in accuracy, it unfolds only 12% of the edges, and achieves a 7 times speed-up, compared to the BFS algorithm.",
        "The savings achieved by not unfolding are especially important, since the exponential complexity of the problem is hidden by the IDL representation via the folding mechanism of the 11 operator.",
        "The algorithms that find suboptimal solutions also perform well.",
        "While maintaining high accuracy, the A✣2 and B0✄2 algorithms unfold only about 5-7% of the edges, at 12-14 times speed-up.",
        "Our second batch of experiments concerns bag-of-words of size 10-25, for which exhaustive search is no longer possible (Table 3).",
        "Not only exhaustive search, but also full A✣ search is too expensive in terms of memory (we were limited to 2GiB of RAM for our experiments) and speed.",
        "Only the greedy versions A✣i and A✣2, and the beam search using tight probability beams (0.2-0.1) scale up to these bag sizes.",
        "Because we no longer have access to the string of maximum probability, we report only the percent of Estimated Search Errors.",
        "Note that, in terms of accuracy, we get around 20% Estimated Search Errors for the best performing algorithms (A✣2 and B0✄1), which means that 80% of the time the algorithms are able to find sentences of equal or better probability than the original sentences."
      ]
    },
    {
      "heading": "5 Conclusions",
      "text": [
        "In this paper, we advocate that IDL expressions can provide an adequate framework for develop",
        "ing text-to-text generation capabilities.",
        "Our contribution concerns a new generation mechanism that implements intersection between an IDL expression and a probabilistic language model.",
        "The IDL formalism is ideally suited for our approach, due to its efficient representation and, as we show in this paper, efficient algorithms for intersecting, scoring, and ranking sentence realizations using probabilistic language models.",
        "We present theoretical results concerning the correctness and efficiency of the proposed algorithms, and also present empirical results that show that our algorithms scale up to handling IDL-expressions of high complexity.",
        "Real-world text-to-text generation tasks, such as headline generation and machine translation, are likely to be handled graciously in this framework, as the complexity of IDL-expressions for these tasks tends to be lower than the complexity of the IDL-expressions we worked with in our experiments."
      ]
    },
    {
      "heading": "Acknowledgment",
      "text": [
        "This work was supported by DARPA-ITO grant NN66001-00-1-9814."
      ]
    }
  ]
}
