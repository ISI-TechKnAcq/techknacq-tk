{
  "info": {
    "authors": [
      "Bill Keller"
    ],
    "book": "Annual Meeting of the Association for Computational Linguistics",
    "id": "acl-P95-1008",
    "title": "DATR Theories and DATR Models",
    "url": "https://aclweb.org/anthology/P95-1008",
    "year": 1995
  },
  "references": [
    "acl-A94-1045",
    "acl-C94-2177",
    "acl-E89-1009",
    "acl-E93-1012",
    "acl-E93-1026",
    "acl-J92-2003",
    "acl-J92-3001",
    "acl-J92-3003",
    "acl-P93-1028",
    "acl-P95-1011"
  ],
  "sections": [
    {
      "heading": "Abstract",
      "text": [
        "Evans and Gazdar (Evans and Gazdar, 1989a; Evans and Gazdar, 1989b) introduced DATR as a simple, non-monotonic language for representing natural language lexicons.",
        "Although a number of implementations of DATR exist, the full language has until now lacked an explicit, declarative semantics.",
        "This paper rectifies the situation by providing a mathematical semantics for DATR.",
        "We present a view of DATR as a language for defining certain kinds of partial functions by cases.",
        "The formal model provides a transparent treatment of DATR's notion of global context.",
        "It is shown that DATR's default mechanism can be accounted for by interpreting value descriptors as families of values indexed by paths."
      ]
    },
    {
      "heading": "1 Introduction",
      "text": [
        "DATR was introduced by Evans and Gazdar (1989a; 1989b) as a simple, declarative language for representing lexical knowledge in terms of path/value equations.",
        "The language lacks many of the constructs found in general purpose, knowledge representation formalisms, yet it has sufficient expressive power to capture concisely the structure of lexical information at a variety of levels of linguistic description.",
        "At the present time, DATR is probably the most widely-used formalism for representing natural language lexicons in the natural language processing (NLP) community.",
        "There are around a dozen different implementations of the language and large DATR lexicons have been constructed for use in a variety of applications (Cahill and Evans, 1990; Andry et al., 1992; Cahill, 1994).",
        "DATR has been applied to problems in inflectional and derivational morphology (Gazdar, 1992; Kilbury, 1992; Corbett and Fraser, 1993), lexical semantics (Kilgariff, 1993), morphonology (Cahill, 1993), prosody (Gibbon and Bleiching, 1991) and speech (Andry et al., 1992).",
        "In more recent work, the language has been used to provide a concise encoding of Lexicalised Tree Adjoining Grammar (Evans et al., 1994; Evans et al., 1995).",
        "A primary objective in the development of DATR has been the provision of an explicit, mathematically rigorous semantics.",
        "This goal was addressed in one of the first publications on the language (Evans and Gazdar, 1989b).",
        "The definitions given there deal with a subset of DATR that includes core features of the language such as the notions of local and global inheritance and DATR's default mechanism.",
        "However, they exclude some important and widely-used constructs, most notably string (or 'list') values and evaluable paths.",
        "Moreover, it is by no means clear that the approach can be generalized appropriately to cover these features.",
        "In particular, the formal apparatus introduced by Evans and Gazdar in (1989b) provides no explicit model of DATR 's notion of global context.",
        "Rather, local and global inheritance are represented by distinct semantic functions ,C and g. This approach is possible only on the (overly restrictive) assumption that DATR statements involve either local or global inheritance relations, but never both.",
        "The purpose of the present paper is to remedy the deficiencies of the work described in (Evans and Gazdar, 1989b) by furnishing DATR with a transparent, mathematical semantics.",
        "There is a standard view of DATR as a language for representing a certain class of non-monotonic inheritance networks ('semantic nets').",
        "While this perspective provides an intuitive and appealing way of thinking about the structure and representation of lexical knowledge, it is less clear that it provides an accurate or particularly helpful picture of the DATR language itself.",
        "In fact, there are a number of constructs available in DATR that are impossible to visualize in terms of simple inheritance hierarchies.",
        "For this reason, the work described in this paper reflects a rather different perspective on DATR, as a language for defining certain kinds of partial functions by cases.",
        "In the following sections this viewpoint is made more precise.",
        "Section 2 presents the syntax of the DATR language and introduces the notion of a DATR theory.",
        "An",
        "informal introduction to the DATR language is provided, by example, in section 3.",
        "The semantics of DATR is then covered in two stages.",
        "Section 4.1 introduces DATR interepretations and describes the semantics of a restricted version of the language without defaults.",
        "The treatment of implicit information is covered in section 4.2, which provides a definition of a default model for a DATR theory."
      ]
    },
    {
      "heading": "2 DATR Theories",
      "text": [
        "Let NODE and ATOM be disjoint sets of symbols (the nodes and atoms respectively).",
        "Nodes are denoted by N and atoms by a.",
        "The set DESC of DATR value descriptors (or simply descriptors) is built up from the atoms and nodes as shown below.",
        "Descriptors are denoted by d.",
        "• a E DESC for any a E ATOM • For any N E NODE and d1 ...dn E DESC:",
        "Value descriptors are either atoms or inheritance descriptors, where an inheritance descriptor is further distinguished as either local (unquoted) or global (quoted).",
        "There is just one kind of local descriptor (node/path), but three kinds of global descriptor (node/path, path and node) 1.",
        "A path (al an) is a (possibly empty) sequence of atoms enclosed in angle brackets.",
        "Paths are denoted by P. For N a node, P a path and a E ATOM* a (possibly empty) sequence of atoms, an equation of the form N : P = a is called an extensional sentence.",
        "Intuitively, an extensional sentence N : P = a states that the value associated with the path P at node N is a.",
        "For a (possibly empty) sequence of value descriptors, an equation of the form N : P == is called a definitional sentence.",
        "A definitional sentence N : P == 4) specifies a property of the node N, namely that the path P is associated with the value defined by the sequence of value descriptors 0.",
        "A collection of equations can be used to specify the properties of different nodes in terms of one another, and a finite set of DATR sentences T is called a DATR theory.",
        "In principle, a DATR theory T may consist of any combination of DATR sentences, either definitional or extensional, but in practice, DATR theories are more restricted than this.",
        "The theory T is said to be definitional if it consists solely of definitional sentences and it is said to be functional if it meets the following condition: 'The syntax presented in (Evans and Gazdar, 1989a; Evans and Gazdar, 1989b) permits nodes and paths to stand as local descriptors.",
        "However, these additional forms can be viewed as conventional abbreviations, in the appropriate syntactic context, for node/path pairs",
        "There is a pragmatic distinction between definitional and extensional sentences akin to that drawn between the language used to define a database and that used to query it.",
        "DATR interpreters conventionally treat all extensional sentences as 'goal' statements, and evaluate them as soon as they are encountered.",
        "Thus, it is not possible, in practice, to combine definitional and extensional sentences within a theory2.",
        "Functionality for DATR theories, as defined above, is really a syntactic notion.",
        "However, it approximates a deeper, semantic requirement that the nodes should correspond to (partial) functions from paths to values.",
        "In the remainder of this paper we will use the term (DATR) theory always in the sense functional, definitional (DATR) theory.",
        "For a given DATR theory T and node N of T, we write TIN to denote that subset of the sentences in T that relate to the node N. That is:",
        "The set TIN is referred to as the definition of N (in T)."
      ]
    },
    {
      "heading": "3 An Overview of DATR",
      "text": [
        "An example of (a fragment of) a DATR theory is shown in figure 1.",
        "The theory makes use of some standard abbreviatory devices that enable nodes and/or paths to be omitted in certain cases.",
        "For example, sets of sentences relating to the same node are written with the node name implicit in all but the first-given sentence in the set.",
        "Also, we write See : == Verb to abbreviate the definitional sentence See : == Verb : (), and similarly elsewhere.",
        "The theory defines the properties of seven nodes: an abstract Verb node, nodes EnVerb, Aux and Modal, and three abstract lexemes Walk, Mow and Can.",
        "Each node is associated with a collection of definitional sentences that specify values associated with different paths.",
        "This specification is achieved either explicitly, or implicitly.",
        "Values given explicitly are specified either directly, by exhibiting a particular value, or indirectly, in terms of local and/or global inheritance.",
        "Implicit specification is achieved via DATR 's default mechanism.",
        "For example, the definition of the Verb node gives the values of the paths (syn cat) and (syn type) directly, as verb and main, respectively.",
        "Similarly, the definition of Walk gives the value of (mor root) directly as walk.",
        "On the other hand, the value of",
        "Verb : (syn cat) == verb (syn type) == main (mor form) == \"(mor \"(syn form)\")\" (mor pres) == \"(mor root)\" (mor past) == \"(mor root)\" ed (mor pres part) == \"(mor root)\" ing (mor pressing three) == \"(mor root)\" s",
        "the empty path at Walk is given indirectly, by local inheritance, as the value of the empty path at Verb.",
        "Note that in itself, this might not appear to be particularly useful, since the theory does not provide an explicit value for the empty path in the definition of Verb.",
        "However, DATR's default mechanism permits any definitional sentence to be applicable not only to the path specified in its left-hand-side, but also for any rightward extension of that path for which no more specific definitional sentences exist.",
        "This means that the statement Walk : 0 == Verb : 0 actually corresponds to a class of implicit definitional sentences, each obtained by extending paths on the left and the right-hand-sides of the equation in the same manner.",
        "Examples include the following:",
        "Thus, the value associated with (syn cat) at Walk is given (implicitly) as the value of (syn cat) at Verb, which is given (explicitly) as verb.",
        "Also, the values of (mor) and (mor form), amongst many others, are inherited from Verb.",
        "In the same way, the value of (syn cat) at Mow is inherited locally from EnVerb (which in turn inherits locally from Verb) and the value of (syn cat) at Can is inherited locally from Modal (which ultimately gets its value from Verb via Aux).",
        "Note however, that the following sentences do not follow by default from the specifications given at the relevant nodes: Walk : (mor root) == Verb : (mor root) Can : (mor past) == Modal : (mor past) Aux : (syn type) == Verb : (syn type) In each of the above cases, the theory provides an explicit statement about the value associated with the indicated path at the given node.",
        "As a result the default mechanism is effectively overridden.",
        "In order to understand the use of global (i.e. quoted) inheritance descriptors it is necessary to introduce DATR's notion of a global context.",
        "Suppose then that we wish to determine the value associated with the path (mor pres) at the node Walk.",
        "In this case, the global context will initially consist of the node/path pair Walk/(mor pres).",
        "Now, by default the value associated with (mor pres) at Walk is inherited locally from (mor pres) at Verb.",
        "This, in turn, inherits globally from the path (mor root).",
        "That is: Verb : (mor pres) == \"(mor root)\" Consequently, the required value is that associated with (mor root) at the 'global node' Walk (i.e. the node provided by the current global context), which is just walk.",
        "In a similar fashion, the value",
        "associated with (mor past) at Walk is obtained as walked (i.e. the string of atoms formed by evaluating the specification \"(mor root)\" ed in the global context Walk/(mor past)).",
        "More generally, the global context is used to fill in the missing node (path) when a global path (node) is encountered.",
        "In addition however, the evaluation of a global descriptor results in the global context being set to the new node/path pair.",
        "Thus in the preceding example, after the quoted descriptor \"(mor root)\" is encountered, the global context effectively becomes Walk / (mor root) (i.e. the path component of the global context is altered).",
        "Note that there is a real distinction between a local inheritance descriptor of the form N : P and it's global counterpart \"N : P\".",
        "The former has no effect on the global context, while the latter effectively overwrites it.",
        "Finally, the definition of Verb in the theory of figure 1 illustrates a use of the `evaluable path' construct: Verb : (mor form) == \"(mor \"(syn form)\")\" This states that the value of (mor form) at Verb is inherited globally from the path (mor • • .",
        "), where the dots represent the result of evaluating the global path \"(syn form)\" (i.e. the value associated with (syn form) in the prevailing global context).",
        "Evaluable paths provide a powerful means of capturing generalizations about the structure of lexical information."
      ]
    },
    {
      "heading": "4 DATR Models",
      "text": [
        "To a first level of approximation, the DATR theory of figure 1 can be understood as a representation of an inheritance hierarchy (a 'semantic network') as shown in figure 2.",
        "In the diagram, nodes are written as labelled boxes, and arcs correspond to (local) inheritance, or isa links.",
        "Thus, the node Can inherits from Modal which inherits from Aux which in turn is a Verb.",
        "The hierarchy provides a useful means of visualising the overall structure of the lexical knowledge encoded by the DATR theory.",
        "However, the semantic network metaphor is of far less value as a way of thinking about the DATR language itself.",
        "Note that there is nothing inherent in DATR to ensure that theories correspond to simple isa hierarchies of the kind shown in the figure.",
        "What is more, the DATR language includes constructs that cannot be visualized in terms of simple networks of nodes connected by (local) inheritance links.",
        "Global inheritance, for example, has a dynamic aspect which is difficult to represent in terms of static links.",
        "Similar problems are presented by both string values and evaluable paths.",
        "Our conclusion is that the network metaphor is of primary value to the DATR user.",
        "In order to provide a satisfactory, formal model of how the language 'works' it is necessary to adopt a different perspective.",
        "DATR theories can be viewed semantically as collections of definitions of partial functions ('nodes' in DATR parlance) that map paths onto values.",
        "A model of a DATR theory is then an assignment of func",
        "tions to node symbols that is consistent with the definitions of those nodes within the theory.",
        "This picture of DATR as a formalism for defining partial functions is complicated by two features of the language however.",
        "First, the meaning of a given node depends, in general, on the global context of interpretation, so that nodes do not correspond directly to mappings from paths to values, but rather to functions from contexts to such mappings.",
        "Second, it is necessary to provide an account of DATR's default mechanism.",
        "It will be convenient to present our account of the semantics of DATR in two stages."
      ]
    },
    {
      "heading": "4.1 DATR Interpretations",
      "text": [
        "This section considers a restricted version of DATR without the default mechanism.",
        "Section 4.2 then shows how implicit information can be modelled by treating value descriptors as families of values indexed by paths.",
        "Elements of the set U are denoted by u and elements of U* are denoted by v. Intuitively, U* is the domain of (semantic) values/paths.",
        "Elements of the set C = (U x U*) are called contexts and denoted by c. The function K can be thought of as mapping global contexts onto (partial) functions from local contexts to values.",
        "The function F is extended to paths, so that for P = (al • • an) (n > 0) we write F(P) to denote u1 • • • un E U*, where ui = F(a1) for each i (1 < i < n).",
        "Intuitively, value descriptors denote elements of U* (as we shall see, this will need to be revised later in order to account for DATR's default mechanism).",
        "We associate with the interpretation I = (U, ic, F) a partial denotation function ni : DESC (C – + U*) and write [lc to denote the meaning (value) of descriptor d in the global context c. The denotation function is defined as shown in figure 3.",
        "Note that an atom always denotes the same element of U, regardless of the context.",
        "By contrast, the denotation of an inheritance descriptor is, in general, sensitive to the global context c in which it appears.",
        "Note also that in the case of a global inheritance descriptor, the global context is effectively altered to reflect the new local context c'.",
        "The denotation function is extended to sequences of value descriptors in the obvious way.",
        "Thus, for 0 = di.",
        "• • (n > 0), we write [0])c to denote v1 • • vn E U* if vi = (1 <i < n) is defined (and Plc is undefined otherwise).",
        "Now, let I = (U, tc, F) be an interpretation and T a theory.",
        "We will write [7- INje to denote that partial function from U* to U* given by",
        "It is easy to verify that IT INic does indeed denote a partial function (it follows from the functionality of the theory T).",
        "Let us also write [NIL to denote that partial function from U\" to U* given by EAric(v) = ,c(c)(F(N),v), for all v E U*.",
        "Then, I models T just in case the following containment holds for each node N and context c:",
        "That is, an interpretation is a model of a DATR theory just in case (for each global context) the function it associates with each node respects the definition of that node within the theory."
      ]
    },
    {
      "heading": "4.2 Implicit Information and Default Models",
      "text": [
        "The notion of a model presented in the preceding section is too liberal in that it takes no account of information implicit in a theory.",
        "For example, consider again the definition of the node Walk from the theory of figure 1, and repeated below.",
        "Walk : Ø== Verb (mor root) == walk According to the definition of a model given previously, any model of the theory of figure 1 will associate with the node Walk a function from paths to values which respects the above definition.",
        "This means that for every global context c, the following containment must hold3: [Walkic 3 {((), [Verb : OM, ((mor root), walk)} On the other hand, there is no guarantee that a given model will also respect the following containment: [Walk], 3 {((mor), [Verb : (mor)[,), ((mor root root), walk)} In fact, this containment (amongst other things) should hold.",
        "It follows 'by default' from the statements made about Walk that the path (mor) inherits locally from Verb and that the value associated with any extension of (mor root) is walk.",
        "if vi = [di], is defined for each i (1 <i < n), then tc(c)(F(N), vi • • vn) undefined otherwise if vi = [di], is defined for each i(1 <i < n), then tc(d)(&) where c' = (F (N), v1 •• • vn) undefined otherwise if vi = IdIc is defined for each i(1 <i n), then ic(e)(e) where c = (u, v) and c' = (u, v1 • • vn) undefined otherwise ,c(ci)„) where c = (u, v) and c' = (F (N), v) Denotation function for DATR Descriptors There have been a number of formal treatments of defaults in the setting of attribute-value formalisms (Carpenter, 1993; Bouma, 1992; Russell et al., 1992; Young and Rounds, 1993).",
        "Each of these approaches formalizes a notion of default inheritance by defining appropriate operations (e.g. default unification) for combining strict and default information.",
        "Strict information is allowed to override default information where the combination would otherwise lead to inconsistency (i.e. unification failure).",
        "In the case of DATR however, the formalism does not draw an explicit distinction between strict and default values for paths.",
        "In fact, all of the information given explicitly in a DATR theory is strict.",
        "The non-monotonic nature of DATR theories arises from a general, default mechanism which 'fills in the gaps' by supplying values for paths not explicitly specified in a theory.",
        "More specifically, DATR's default mechanism ensures that any path that is not explicitly specified for a given node will take its definition from the longest prefix of that path that is specified.",
        "Thus, the default mechanism defines a class of implicit, definitional sentences with paths on the left that extend paths found on the left of explicit sentences.",
        "Furthermore, this extension of paths is also carried over to paths occurring on the right.",
        "In effect, each (explicit) path is associated not just with a single value specification, but with a whole family of specifications indexed by extensions of those paths.",
        "This suggests the following approach to the semantics of defaults in DATR.",
        "Rather than interpreting node definitions (in a given global context) as partial functions from paths to values (i.e. of type U5 U*) we choose instead to interpret them as partial functions from (explicit) paths, to functions from extensions of those paths to values (i.e. of type U* (U* U*)).",
        "Now suppose that f : U* (U* U*) is the function associated with the node definition TIN in a given DATR interpretation.",
        "We can define a partial function A(f) : U* U* (the default interpretation of TIN) as follows.",
        "For each V E U* set",
        "where v = vi v2 and vi is the longest prefix of v such that f(vi) is defined.",
        "In effect, the function (f) makes explicit that information about paths and values that is only implicit in f, but just in so far as it does not conflict with explicit information provided by f. In order to reinterpret node definitions in the manner suggested above, it is necessary to modify the interpretation of value descriptors.",
        "In a given global context c, a value descriptor d now corresponds to a total function [dic : U* U* (intuitively, a function from path extensions to values).",
        "For example, atoms now denote constant functions: Iale(v) = F(a) for all v E U.",
        "More generally, value descriptors will denote different values for different paths.",
        "Figure 4 shows the revised clause for global node/path pairs, the other definitions being very similar.",
        "Note the way in which the 'path' argument v is used to extend v1 • • • vn in order to define the new local (and in this case also, global) context c'.",
        "On the other hand, the meaning of each of the di is obtained with respect to the 'empty path' e (i.e. path extension does not apply to subterms of inheritance descriptors).",
        "As before, the interpretation function is extended to sequences of path descriptors, so that for 0 = d1 • • • dn (n > o) we have 1.41c(v) = vi • • • vn E U\", if = [dilly) is defined, for each i (1 < i < n) (and [01,(v) is undefined otherwise).",
        "The definition of the interpretation of node definitions can be taken over unchanged from the previous section.",
        "However, for a theory T and node N, the function IT/N11, is now of type U* 4 (U* – + U5).",
        "An interpretation I = (U, rc, F) is a default model for theory T just in case for every context c and node N we have: [N]l, 2 Aar / As an example, consider the default interpretation of the definition of the node Walk given above.",
        "By",
        "definition, any default model of the theory of figure 1 must respect the following containment: [Walkjc 2 A({((), Av.",
        "[Verb : 01,(v)), ((mor root), Av.walk)} From the definition of A, it follows that for any path v, if v extends (mor root), then it is mapped onto the value walk, and otherwise it is mapped to the value given by [Verb : 01,(v).",
        "We have the following picture: [Walk], 2 1(0, [Verb : 01c(())), ((mor), [Verb : 01,((mor))),",
        "• - -",
        "((mor root), walk), ((mor root root), walk), - • -} The default models of a theory T constitute a proper subset of the models of T: just those that respect the default interpretations of each of the nodes defined within the theory."
      ]
    },
    {
      "heading": "5 Conclusions",
      "text": [
        "The work described in this paper fulfils one of the objectives of the DATR programme: to provide the language with an explicit, declarative semantics.",
        "We have presented a formal model of DATR as a language for defining partial functions and this model has been contrasted with an informal view of DATR as a language for representing inheritance hierarchies.",
        "The approach provides a transparent treatment of DATR's notion of (local and global) context and accounts for DATR's default mechanism by regarding value descriptors (semantically) as families of values indexed by paths.",
        "The provision of a formal semantics for DATR is important for several reasons.",
        "First, it provides the DATR user with a concise, implementation-independent account of the meaning of DATR theories.",
        "Second, it serves as a standard against which other, operational definitions of the formalism can be judged.",
        "Indeed, in the absence of such a standard, it is impossible to demonstrate formally the correctness of novel implementation strategies (for an example of such a strategy, see (Langer, 1994)).",
        "Third, the process of formalisation itself aids our understanding of the language and its relationship to other non-monotonic, attribute-value formalisms.",
        "Finally, the semantics presented in this paper provides a sound basis for subsequent investigations into the mathematical and computational properties of DATR."
      ]
    },
    {
      "heading": "6 Acknowledgements",
      "text": [
        "The author would like to thank Roger Evans, Gerald Gazdar, Bill Rounds and David Weir for helpful discussions on the work described in this paper."
      ]
    }
  ]
}
