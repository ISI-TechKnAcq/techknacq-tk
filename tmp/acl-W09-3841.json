{
  "info": {
    "authors": [
      "Pierre Boullier",
      "Benoît Sagot"
    ],
    "book": "Proceedings of the 11th International Conference on Parsing Technologies (IWPT’09)",
    "id": "acl-W09-3841",
    "title": "Parsing Directed Acyclic Graphs with Range Concatenation Grammars",
    "url": "https://aclweb.org/anthology/W09-3841",
    "year": 2009
  },
  "references": [],
  "sections": [
    {
      "text": [
        "Pierre Boullier and Benoît Sagot",
        "Alpage, INRIA Paris-Rocquencourt & Université Paris 7 Domaine de Voluceau – Rocquencourt, BP 105 – 78153 Le Chesnay Cedex, France",
        "{Pierre.Boullier,Benoit.Sagot}@inria.fr",
        "Range Concatenation Grammars (RCGs) are a syntactic formalism which possesses many attractive properties.",
        "It is more powerful than Linear Context-Free Rewriting Systems, though this power is not reached to the detriment of efficiency since its sentences can always be parsed in polynomial time.",
        "If the input, instead of a string, is a Directed Acyclic Graph (DAG), only simple RCGs can still be parsed in polynomial time.",
        "For non-linear RCGs, this polynomial parsing time cannot be guaranteed anymore.",
        "In this paper, we show how the standard parsing algorithm can be adapted for parsing DAGs with RCGs, both in the linear (simple) and in the non-linear case."
      ]
    },
    {
      "heading": "1. Introduction",
      "text": [
        "The Range Concatenation Grammar (RCG) formalism has been introduced by Boullier ten years ago.",
        "A complete definition can be found in (Boullier, 2004), together with some of its formal properties and a parsing algorithm (qualified here of standard) which runs in polynomial time.",
        "In this paper we shall only consider the positive version of RCGs which will be abbreviated as PRCG.",
        "PRCGs are very attractive since they are more powerful than the Linear Context-Free Rewriting Systems (LCFRSs) by (Vijay-Shanker et al., 1987).",
        "In fact LCFRSs are equivalent to simple PRCGs which are a subclass of PRCGs.",
        "Many Mildly Context-Sensitive (MCS) formalisms, including Tree Adjoining Grammars (TAGs) and various kinds of Multi-Component TAGs, have already been translated into their simple PRCG counterpart in order to get an efficient parser for free (see for example (Barthelemy et al., 2001)).",
        "However, in many Natural Language Processing applications, the most suitable input for a parser is not a sequence of words (forms, terminal symbols), but a more complex representation, usually defined as a Direct Acyclic Graph (DAG), which correspond to finite regular languages, for taking into account various kinds of ambiguities.",
        "Such ambiguities may come, among others, from the output of speech recognition systems, from lexical ambiguities (and in particular from tokenization ambiguities), or from a non-deterministic spelling correction module.",
        "Yet, it has been shown by (Bertsch and Nederhof, 2001) that parsing of regular languages (and therefore of DAGs) using simple PRCGs is polynomial.",
        "In the same paper, it is also proven that parsing of finite regular languages (the DAG case) using arbitrary RCGs is NP-complete.",
        "This papers aims at showing how these complexity results can be made concrete in a parser, by extending a standard RCG parsing algorithm so as to handle input DAGs.",
        "We will first recall both some basic definitions and their notations.",
        "Afterwards we will see, with a slight modification of the notion of ranges, how it is possible to use the standard PRCG parsing algorithm to get in polynomial time a parse forest with a DAG as input.",
        "However, the resulting parse forest is valid only for simple PRCGs.",
        "In the non-linear case, and consistently with the complexity results mentioned above, we show that the resulting parse forest needs further processing for filtering out inconsistent parses, which may need an exponential time.",
        "The proposed filtering algorithm allows for parsing DAGs in practice with any PRCG, including non-linear ones."
      ]
    },
    {
      "heading": "2. Basic notions and notations",
      "text": [
        "A positive range concatenation grammar (PRCG) G = (N, T, V, P, S) is a 5-tuple in which:",
        "• T and V are disjoint alphabets of terminal symbols and variable symbols respectively.",
        "• N is a non-empty finite set of predicates of fixed arity (also called fan-out).",
        "We write k = arity (A) if the arity of the predicate A is k. A predicate A with its arguments is noted A (a ) with a vector notation such that \\a | = k and a [j] is its jth argument.",
        "An argument is a string in (V U T)*.",
        "• S is a distinguished predicate called the start predicate (or axiom) of arity 1.",
        "• P is a finite set of clauses.",
        "A clause c is a rewriting rule of the form A0(a0) – Ai(Oi)... Ar(a) where r, r > 0 is its rank, A0 (a0) is its left-hand side or LHS, and Ai(a1)... Ar (a) its right-hand side or /HS.",
        "By definition c[i] = Ai(ai), 0 < i < r where Ai is a predicate and aj its arguments; we note c[i] [j] its jth argument; c[i] [j] is of the form X1... Xnij (the Xk's are terminal or variable symbols), while c[i][j][k], 0 < k < riij is a position within c[i][j].",
        "For a given clause c, and one of its predicates c[i] a subargument is defined as a substring of an argument c[i][j] of the predicate c[i].",
        "It is denoted by a pair of positions (c[i][j][k], c[i][j][k']), with k < k'.",
        "Let w = a1... an be an input string in T*, each occurrence of a substring a1+1... au is a pair of positions (w[1],w[u]) s.t.",
        "0 < l < u < n called a range and noted (1..u)w or (1..u) when w is implicit.",
        "In the range (1..u), l is its lower bound while u is its upper bound.",
        "If l = u, the range (1..u) is an empty range, it spans an empty substring.",
        "If p1 = (Z1 ..u1 ), ... and pm = (1m..um) are ranges, the concatenation of P1,..., pm noted p1... pm is the range p = (Lu) if and only if we have ui = 1 < i < m, l = 11 and u = um.",
        "by p. However, the instantiation of a subargument is subjected to the following constraints.",
        "• If the subargument is the empty string (i.e., k = k'), p is an empty range.",
        "• If the subargument is a terminal symbol (i.e., k + 1 = k' and Xk e T), p is such that l + 1 = u and au = Xy.",
        "Note that several occurrences of the same terminal symbol may be instantiated by different ranges.",
        "• If the subargument is a variable symbol (i.e., k + 1 = k' and Xy e V), any occurrence (c[i'][j'][m],c[i'][j'][m']) of Xk' is instantiated by p. Thus, each occurrence of the same variable symbol must be instantiated by the same range.",
        "• If the subargument is the string Xk+1... Xy, p is its instantiation if and only if we have p = pfc+i... py in which pfc+i, ..., py are respectively the instantiations of Xy+1, ..., Xy'.",
        "If in c we replace each argument by its instantiation, we get an instantiated clause noted Ao(po) – >■ A1(/o1)... Ar(p>T) in which each Ai(pi) is an instantiated predicate.",
        "A binary relation called derive and noted => is defined on strings of instantiated predicates.",
        "If r1and r2 are strings of instantiated predicates, we have if and only if Ao(p0) – A1(pl)... Am(pm) is an instantiated clause.",
        "other words, an input string w e T*, |w| = n is a sentence of G if and only there exists a complete derivation which starts from S((0..n)) (the instantiation of the start predicate on the whole input text) and leads to the empty string (of instantiated predicates).",
        "The parse forest of w is the CFG whose axiom is S((0..n)) and whose productions are the instantiated clauses used in all complete derivations.",
        "We say that the arity of a PRCG is k, and we call it a k-PRCG, if and only if k is the maximum arity of its predicates (k = max^ew arity(A)).",
        "We say that a k-PRCG is simple, we have a simple k-PRCG, if and only if each of its clause is",
        "• non-combinatorial: the arguments of its RHS predicates are single variables;",
        "• non-erasing: each variable which occur in its LHS (resp.",
        "RHS) also occurs in its RHS (resp.",
        "LHS);",
        "• linear: there are no variables which occur more than once in its LHS and in its RHS.",
        "The subclass ofsimple PRCGs is ofimportance since it is MCS and is the one equivalent to",
        "LCFRSs.",
        "A non-deterministic finite automaton (NFA) is the 5-tuple A = (Q, £,5, q0, F) where Q is a non empty finite set of states, £ is a finite set of terminal symbols, 5 is the ternary transition relation 5 = t, qj)qj e Q A t e £ U {e}}, q0 is a distinguished element of Q called the initial state and F is a subset of Q whose elements are called final states.",
        "The size of A, noted |A|, is its number of states (| A| = | Q| ).",
        "We define the ternary relation 5* on Q x £* x Q as the smallest set s.t.",
        "5* = {(q, e, q) | q e Q} U {(q1, xt, q3) | (q1, x, q2) e 5* A (q2, t, q3) e 5}.",
        "If (q, x, q') e 5*, we say that x is a path between q and q'.",
        "If q = q0 and q' e F, x is a complete path.",
        "The language L(A) defined (generated, recognized, accepted) by the NFA A is the set of all its complete paths.",
        "We say that a NFA is empty if and only if its language is empty.",
        "Two NFAs are equivalent if and only if they define the same language.",
        "A NFA is e-free if and only if its transition relation does not contain a transition of the form (q1, e, q2).",
        "Every NFA can be transformed into an equivalent e-free NFA (this classical result and those recalled below can be found, e.g., in (Hopcroft and Ullman, 1979)).",
        "As usual, a NFA is drawn with the following conventions: a transition (q1;t, q2) is an arrow labelled t from state q1 to state q2 which are printed with a surrounded circle.",
        "Final states are doubly circled while the initial state has a single unconnected, unlabelled input arrow.",
        "A deterministic finite automaton (DFA) is a NFA in which the transition relation 5 is a transition function, 5 : Q x £ – Q.",
        "In other words, there are no e-transitions and if (q1,t, q2) e 5, t = e and ^(q^t,q2) e 5 with q2 = q2.",
        "Each NFA can be transformed by the subset construction into an equivalent DFA.",
        "Moreover, each DFA can be transformed by a minimization algorithm into an equivalent DFA which is minimal (i.e., there is no other equivalent DFA with fewer states).",
        "Formally, a directed acyclic graph (DAG) D = (Q, £, 5, q0, F) is an NFA for which there exists a strict order relation < on Q such that (p, t, q) e 5 => p < q.",
        "Without loss of generality we may assume that < is a total order.",
        "Of course, as NFAs, DAGs can be transformed into equivalent deterministic or minimal DAGs."
      ]
    },
    {
      "heading": "3. DAGs and PRCGs",
      "text": [
        "A DAG D is recognized (accepted) by a PRCG G if and only if L(D) n L(G) = 0.",
        "A trivial way to solve this recognition (or parsing) problem is to extract the complete paths of L(D) (which are in finite number) one by one and to parse each such string with a standard PRCG parser, the (complete) parse forest for D being the union of each individual forest.",
        "However since DAGs may define an exponential number of strings w.r.t.",
        "its own size, the previous operation would take an exponential time in the size of D, and the parse forest would also have an exponential size.",
        "The purpose of this paper is to show that it is possible to directly parse a DAG (without any unfolding) by sharing identical computations.",
        "This sharing may lead to a polynomial parse time for an exponential number of sentences, but, in some cases, the parse time remains exponential.",
        "In many NLP applications the source text cannot be considered as a sequence of terminal symbols, but rather as a finite set of finite strings.",
        "As mentioned in th introduction, this non-unique string could be used to encode not-yet-solved ambiguities in the input.",
        "DAGs are a convenient way to represent these finite sets of strings by factorizing their common parts (thanks to the minimization algorithm).",
        "In order to use DAGs as inputs for PRCG parsing we will perform two generalizations.",
        "The first one follows.",
        "Let w = t1... tn be a string in some alphabet £ and let Q = {q^ | 0 < i < n} be a set of n + 1 bounds with a total order relation <, we have q0 < q1 < ... < qn.",
        "The sequence n = q0t1 q^q2 ... t„q„ e Q x (£ x Q)nis called a bounded string which spells w. A range is a pair of bounds (qj, qj) with qj < qj noted (Pi-Pj)n and any triple of the form (qj_1tjqj) is called a transition.",
        "All the notions around PRCGs defined in Section 2.1 easily generalize from strings to bounded strings.",
        "It is also the case for the standard parsing algorithm of (Boullier, 2004).",
        "Now the next step is to move from bounded strings to DAGs.",
        "Let D = (Q, £, 5, q0, F) be a DAG.",
        "A string x e £* s.t.",
        "we have (q1, x, q2) e 5* is called a path between q1 and q2 and a string n = qt1q1.. .",
        "tpqp e Q x (£ U {e} x Q)* is a bounded path and we say that n spells t1t2 ... tp.",
        "A path x from q0 to f e F is a complete path and a bounded path of the form q0t1... tnf with f e F is a complete bounded path.",
        "In the context of a DAG D, a range is a pair of states (q»,qj) with q» < qj noted (q»..qj)d. A range (qi..qj)d is valid if and only if there exists a path from qj to qj in D. Of course, any range (p..q)D defines its associated sub-DAG = (Q<p..q>, £<p..«>,5<p..,),p, {q}) as follows.",
        "Its transition relation is 5(p^q> = {(r, t, s) | (r, t, s) e 5 A (p,x',r), (s,x'',q) e 5*}.",
        "If 5(p..g> = 0 (i.e., there is no path between p and q), D(p q> is the empty DAG, otherwise Q(p„q> (resp.",
        "£(j>„q>) are the states (resp.",
        "terminal symbols) of the transitions of 5(p^q>.",
        "With this new definition of ranges, the notions of instantiation and derivation easily generalize from bounded strings to DAGs.",
        "The language of a PRCG G for a DAG may not be in L(G).",
        "To put it differently, if we use the standard RCG parser, with the ranges of a DAG, we produce the shared parse-forest for the language L (G, D) which is a superset of",
        "L(D) n L(G).",
        "However, if G is a simple PRCG, we have the equality L(G) = UD is a DAG L (G,D).",
        "Note that the subclass of simple PRCGs is of importance since it is MCS and it is the one equivalent to LCFRSs.",
        "The informal reason of the equality is the following.",
        "If an instantiated predicate Aj (pj) succeeds in some RHS, this means that each of its ranges pj [j] = (k..1)D has been recognized as being a component ofAj, more precisely their exists a path from k to l in D which is a component of Aj.",
        "The range (k..1)D selects in D a set 5(k j>D of transitions (the transitions used in the bounded paths from k to l).",
        "Because of the linearity of G, there is no other range in that RHS which selects a transition in 5(k j>D. Thus the bounded paths selected by all the ranges ofthat RHS are disjoints.",
        "In other words, any occurrence of a valid instantiated range )D selects a set of paths which is a subset of L(D(j..j>).",
        "Now, if we consider a non-linear PRCG, in some of its clauses, there is a variable, say X, which has several occurrences in its RHS (if we consider a top-down non-linearity).",
        "Now assume that for some input DAG D, an instantiation of that clause is a component of some complete derivation.",
        "Let (p..q)D be the instantiation of X in that instantiated clause.",
        "The fact that a predicate in which X occurs succeeds means that there exist paths from p to q in D(p q>.",
        "The same thing stands for all the other occurrences of X but nothing force these paths to be identical or not.",
        "Example 1.",
        "Let us take an example which will be used throughout the paper.",
        "It is a non-linear 1-PRCG which defines the language ara6racra, n > 0 as the intersection of the two languages a* bncn and anbnc*.",
        "Each of these languages is respectively defined by the predicates a*bncn and anbnc*; the start predicate is ara6racra.",
        "anbncn(x )",
        "If we use this PRCG to parse the DAG of Figure 1 which defines the language {ab, bc}, we (erroneously) get the non-empty parse forest of Figure 2 though neither ab nor bc is in anbncn.",
        "It is not difficult to see that the problem comes from the non-linear instantiated variable X(L 4> in the start node, and more precisely from the actual (wrong) meaning of the three different occurrences of X(L 4> in arabracra(X(1^4>) – a*bracra(X(1„4>) arabrac*(X(1„4>).",
        "The first occurrence in its RHS says that there exists a path in the input DAG from state 1 to state 4 which is an a*bncn.",
        "The second occurrence says that there exists a path from state 1 to state 4 which is an anbnc*.",
        "While the LHS occurrence (wrongly) says that there exists a path from state 1 to state 4 which is an anbncn.",
        "However, if the two X(L4>'s in the RHS had selected common paths (this is not possible here) between 1 and 4, a valid interpretation could have been proposed.",
        "With this example, we see that the difficulty of DAG parsing only arises with non-linear PRCGs.",
        "If we consider linear PRCGs, the subclass of the PRCGs which is equivalent to LCFRSs, the standard algorithm works perfectly well with input DAGs, since a valid instantiation of an argument of a predicate in a clause by some range (p..q) means that there exists (at least) one path between p and q which is recognized.",
        "The paper will now concentrate on non-linear PRCGs, and will present a new valid parsing algorithm and study its complexities (in space and time).",
        "In order to simplify the presentation we introduce this algorithm as a post-processing pass which will work on the shared parse-forest output by the (slightly modified) standard algorithm which accepts DAGs as input.",
        "The standard parsing algorithm of (Boullier, 2004) working on a string w can be sketched as follows.",
        "It uses a single memoized boolean function predicate(A, p) where A is a predicate and p is a vector ofranges whose dimension is arity(A).",
        "The initial call to that function has the form predicate (S, (0..\\w\\)).",
        "Its purpose is, for each A0-clause, to instantiate each of its symbols in a consistant way.",
        "For example if we assume that the ith argument of the LHS of the current A0-clause is ajXaYaj' and that the ith component of p0 is the range (pi..qi) an instantiation of X, a an Y by the ranges (pX..qX), (p«..q«) and (pY..qY) is such that we have pi < px < qx = p« < q« = p« + 1 = py < qY < qi and w = w'aw'' with \\w'\\ = pa.",
        "Since the PRCG is non bottom-up erasing, the instantiation of all the LHS symbols implies that all the arguments of the RHS predicates Ai are also instantiated and gathered into the vector of ranges pi.",
        "Now, for each i (1 < i < \\RHS\\), we can call predicate (Ai; pi).",
        "If all these calls succeed, the instantiated clause can be stored as a component of the shared parse forest.",
        "In the case of a DAG D = (Q, E, 5, q0, F) as input, there are two slight modifications, the initial call is changed by the conjunctive call pred-icate(S, (q0)) v ... vpredicate (S, (q0../|F|)) with /i g F and the terminal symbol a can be instantiated by the range (pa..qa)D only if (p",
        "i-^~^r-~^-.",
        "is a transition in 5.",
        "The variable symbol X can be instantiated by the range (px..qx)D only if (px ..qx )d is valid.",
        "We assume here that for a given PRCG G we have built the parse forest of an input DAG D as explained above and that each instantiated clause of that forest contains the range (px..qx)D of each of its instantiated symbols X.",
        "We have seen in Example 1 that this parse forest is valid if G is linear but may well be unvalid if G is non-linear.",
        "In that latter case, this happens because the range (px..qx)d of each instantiation of the non-linear variable X selects the whole sub-DAG D(px qx > while each instantiation should only select a sublanguage of L(D(px qx>).",
        "For each occurrence of X in the LHS or RHS of a non-linear clause, its sub-languages could of course be different from the others.",
        "In fact, we are interested in their intersections: If their intersections are non empty, this is the language which will be associated with (px..qx)d, otherwise, if their intersections are empty, then the instantiation of the considered clause fails and must thus be removed from the forest.",
        "Of course, we will consider that the language (a finite number of strings) associated with each occurrence of each instantiated symbol is represented by a DAG.",
        "The idea of the forest filtering algorithm is to first compute the DAGs associated with each argument of each instantiated predicate during a bottom-up walk.",
        "These DAGs are called decorations.",
        "This processing will perform DAG compositions (including intersections, as suggested above), and will erase clauses in which empty intersections occur.",
        "If the DAG associated with the single argument of the super-root is empty, then parsing failed.",
        "Otherwise, a top-down walk is launched (see below), which may also erase non-valid instantiated clauses.",
        "If necessary, the algorithm is completed by a classical CFG algorithm which erase non productive and unreachable symbols leaving a reduced grammar/forest.",
        "In order to simplify our presentation we will assume that the PRCGs are non-combinatorial and bottom-up non-erasing.",
        "However, we can note that the following algorithm can be generalized in order to handle combinatorial PRCGs and in particular with overlapping arguments.",
        "Moreover, we will assume that the forest is non cyclic (or equivalently that all cycles have previously been removed).",
        "For this principle algorithm, we assume that for each instantiated clause in the forest, a DAG will be associated with each occurrence of each instantiated symbol.",
        "More precisely, for a given instantiated A0-clause, the DAGs associated with the RHS symbol occurrences are composed (see below) to build up DAGs which will be associated with each argument of its LHS predicate.",
        "For each LHS argument, this composition is directed by the sequence of symbols in the argument itself.",
        "The forest is walked bottom-up starting from its leaves.",
        "The constraint being that an instantiated clause is visited if and only if all its RHS instantiated predicates have already all been visited (computed).",
        "This constraint can be satisfied for any non-cyclic forest.",
        "1.",
        "If the clause is not top-down linear (i.e., there exist multiple occurrences of the same variables in its RHS arguments), for such variable X let the range (px..qx) be its instantiation (by definition, all occurrences are instantiated by the same range), we perform the intersection of the DAGs associated with each instantiated predicate argument X.",
        "If one intersection results in an empty DAG, the instantiated clause is removed from the forest.",
        "Otherwise, we perform the following steps.",
        "2.",
        "If a RHS variable Y is linear, it occurs once in the jth argument of predicate Aj.",
        "We perform a brand new copy ofthe DAG associated with the jth argument of the instantiation of Aj.",
        "3.",
        "At that moment, all instantiated variables which occur in cp are associated with a DAG.",
        "For each occurrence of a terminal symbol t in the LHS arguments we associate a (new) DAG whose only transition is (p, t, q) where p and q are brand new states with, of course, p < q.",
        "4.",
        "Here, all symbols (terminals or variables) are associated with disjoints DAGs.",
        "For each concatenation of the DAGs associated with the symbols Xi,..., Xj,... and Xppi.",
        "5.",
        "Here each LHS argument of cp is associated with a non empty DAG, we then report the individual contribution of cp into the (already computed) DAGs associated with the arguments of its LHS A0(p0).",
        "The DAG associated with the ith argument of A0(p0) is the union (or a copy if it is the first time) of its previous DAG value with the DAG associated with the ith argument of the LHS of cp.",
        "This bottom-up walk ends on the super-root with a final decoration say R. In fact, during this bottom-up walk, we have computed the intersection of the languages defined by the input DAG and by the PRCG (i.e., we have L(R) = L(D) n L(G)).",
        "Example 2.",
        "With the PRCG of Example 1 and the input DAG of Figure 3, we get the parse forest of Figure 4 whose transitions are decorated by the DAGs computed by the bottom-up algorithm.The crucial point to note here is the intersection which is performed between {abc, bc} and {abc, ab} on non-empty set {abc} is the final result assigned to the instantiated start symbol.",
        "Since this result is non empty, it shows that the input DAG D is recognized by G. More precisely, this shows that the sub-language ofD which is recognized by G is {abc}.",
        "However, as shown in the previous example, the (undecorated) parse forest is not the forest built for the DAG L(D) n L(G) since it may contain non-valid parts (e.g., the transitions labelled {bc} or { ab} in our example).",
        "In order to get the right forest (i.e., to get a PRCG parser – not a recognizer – which accepts a DAG as input) we need to perform another walk on the previous decorated forest.",
        "The idea of the top-down walk on the parse forest decorated by the bottom-up walk is to (re)compute all the previous decorations starting from the bottom-up decoration associated with the instantiated start predicate.",
        "It is to be noted that (the language defined by) each top-down decoration is a subset ofits bottom-up counterpart.",
        "However, when a top-down decoration becomes empty, the corresponding subtree must be erased from the forest.",
        "If the bottom-up walk succeeds, we are sure that the top-down walk will not result in an empty forest.",
        "Moreover, if we perform a new bottom-up walk on this reduced forest, the new bottom-up decorations will denote the same language as their top-down decorations counterpart.",
        "The forest is walked top-down starting from the super-root.",
        "The constraint being that an instantiated A(p) clause is visited if and only if all the occurrences of A(p) occurring in the RHS of instantiated clauses have all already been visited.",
        "This constraint can be satisfied for any non-cyclic forest.",
        "Initially, we assume that each argument of each instantiated predicate has an empty decoration, except for the argument of the super-root which is decorated by the DAG R computed by the bottom-up pass.",
        "Now, assume that a top-down decoration has been (fully) computed for each argument of the instantiated predicate Ao(p0).",
        "For each instantiated clause of the form cp = Ao(p0) – Ai(p1) ...Ai(pi) ...Am(pm), we perform the following sequence:",
        "1.",
        "We perform the intersection of the top-down decoration of each argument of A0(p0) with the decoration computed by the bottom-up pass for the same argument of the LHS predicate of cp.",
        "If the result is empty, cp is erased from the forest.",
        "2.",
        "For each LHS argument, the previous results are dispatched over the symbols of this argument.",
        "Thus, each instantiated LHS symbol occurrence is decorated by its own DAG.",
        "If the considered clause has several occurrences of the same variable in the LHS arguments (i.e., is bottom-up non-linear), we perform the intersection of these DAGs in order to leave a single decoration per instantiated variable.",
        "If an intersection results in an empty DAG, the current clause is erased from the forest.",
        "3.",
        "The LHS instantiated variable decorations are propagated to the RHS arguments.",
        "This propagation may result in DAG concatenations when a RHS argument is made up of several variables (i.e., is combinatorial).",
        "4.",
        "At last, we associate to each argument of Ai(pi) a new decoration which is computed as the union of its previous top-down decoration with the decoration just computed.",
        "Example 3.",
        "When we apply the previous algorithm to the bottom-up parse forest of Example 2, we get the top-down parse forest of Figure 5.",
        "In this parse forest, erased parts are laid out in light gray.",
        "The more noticable points w.r.t.",
        "the bottom-up forest are the decorations between I anbncn(X{hA)) – a*bncn1lA) anbnc*{l 4 and its RHS predicates ^ahb^c^''^^ and instead of {abc, bc} and {abc, ab}.",
        "These two changes induce the indicated erasings.",
        "L(D'p..q))) and that ao[k] = a^Xa^ and that (i..j)o is the instantiation of the symbol X in cp.",
        "Our goal is to extract from D'p q) the decoration DAG D't j) associated with that instantiated occurrence of X.",
        "This computation can be helped if we maintain, associated with each decoration DAG a function, say d, which maps each state of the decoration DAG to a set of states (bounds) of the input DAG D. If, as we have assumed, D is minimal, each set of states is a singleton, we can write d(p') = p, d(f') = q for all /' e F'p q) and more generally d(i') e Q if i' e Q'.",
        "Let I' = {i' | i' e Q'p..q) A d(i') = i} and J' = {j | j' e Q\\v..q) A d(j') = j}.",
        "The decoration DAG D't j) is such that",
        "Of course, together with the construction of D't..j), its associated function d must also be built.",
        "In this Section we study the time and size complexities of the forest filtering algorithm.",
        "Let us consider the sub-DAG D^pq) of the minimal input DAG D and consider any (finite) regular language L C L(D^ q)), and let DL be the minimal DAG s.t.",
        "L(DL) = L. We show, on an example, that |DL | may be an exponential w.r.t.",
        "\\D(p..q)\\.",
        "Consider, for a given h > 0, the language (a|b)h. We know that this language can be represented by the minimal DAG with h +1 states of Figure 6.",
        "Assume that h = 2k and consider the sub-language L2k of (a|b)2k (nested well-parenthesized strings) which is defined by",
        "It is not difficult to see that the DAG in Figure 7 defines L2k and is minimal, but its size 2k+ – 2 is an exponential in the size 2k + 1 of the minimal DAG for the language (a|b)2k.",
        "This results shows that, there exist cases in which some minimal DAGs D that define sublanguages of minimal DAGs D may have a exponential size (i.e., |D'| = O(2lDl).",
        "In other words, when, during the bottom-up or top-down walk, we compute union of DAGs, we may fall on these pathologic DAGs that will induce a combinatorial explosion in both time and space.",
        "Of course, many improvements may be brought to the previous principle algorithms in practical implementations.",
        "Let us cite two of them.",
        "First it is possible to restrict the number of DAG copies: a DAG copy is not useful if it is the last reference to that DAG.",
        "We shall here devel the second point on a little more: if an argument of a predicate is never used in ant non-linearity, it is only a waste of time to compute its decoration.",
        "We say that Ak, the kth argument of the predicate A is a nonlinear predicate argument if there exists a clause c in which A occurs in the RHS and whose kth argument has at least one common variable another argument Bh of some predicate B of the RHS (if B = A, then of course k and h must be different).",
        "It is clear that Bh is then non-linear as well.",
        "It is not difficult to see that decorations needs only to be computed if they are associated with a non-linear predicate argument.",
        "It is possible to compute those non-linear predicate arguments statically (when building the parser) when the PRCG is defined within a single module.",
        "However, if the PRCG is given in several modules, this full static computation is no longer possible.",
        "The non-linear predicate arguments must thus be identified at parse time, when the whole grammar is available.",
        "This rather trivial algorithm will not be described here, but it should be noted that it is worth doing since in practice it prevents decoration computations which can take an exponential time."
      ]
    },
    {
      "heading": "4. Conclusion",
      "text": [
        "In this paper we have shown how PRCGs can handle DAGs as an input.",
        "Ifwe consider the linear PRCG, the one equivalent to LCFRS, the parsing time remains polynomial.",
        "Moreover, input DAGs necessitate only rather cosmetic modifications in the standard parser.",
        "In the non-linear case, the standard parser may produce illegal parses in its output shared parse forest.",
        "It may even produce a (non-empty) shared parse forest though no sentences of the input DAG are in the language defined by our non-linear PRCG.",
        "We have proposed a method which uses the (slightly modified) standard parser but prunes, within extra passes, its output forest and leaves all and only valid parses.",
        "During these extra bottom-up and top-down walks, this pruning involves the computation of finite languages by means of concatenation, union and intersection operations.",
        "The sentences of these finite languages are always substrings of the words of the input DAG D. We choose to represent these intermediate finite languages by DAGs instead of sets of strings because the size of a DAG is, at worst, of the same order as the size of a set of strings but it could, in some cases, be exponentially smaller.",
        "However, the time taken by this extra pruning pass cannot be guaranteed to be polynomial, as expected from previously known complexity results (Bertsch and Nederhof, 2001).",
        "We have shown an example in which pruning takes an exponential time and space in the size of D. The deep reason comes from the fact that if L is a finite (regular) language defined by some minimal DAG D, there are cases where a sub-language of",
        "L may require to be defined by a DAG whose size is an exponential in the size of D. Of course this combinatorial explosion is not a fatality, and we may wonder whether, in the particular case ofNLP it will practically occur?"
      ]
    }
  ]
}
