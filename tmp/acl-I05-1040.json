{
  "info": {
    "authors": [
      "Jong-Hoon Oh",
      "Key-Sun Choi"
    ],
    "book": "Second International Joint Conference on Natural Language Processing: Full Papers",
    "id": "acl-I05-1040",
    "title": "An Ensemble of Grapheme and Phoneme for Machine Transliteration",
    "url": "https://aclweb.org/anthology/I05-1040",
    "year": 2005
  },
  "references": [
    "acl-C00-1061",
    "acl-J96-1002",
    "acl-P02-1051",
    "acl-P04-1021",
    "acl-P97-1017"
  ],
  "sections": [
    {
      "text": [
        "Jong-Hoon Oh and Key-Sun Choi",
        "Abstract.",
        "Machine transliteration is an automatic method to generate characters or words in one alphabetical system for the corresponding characters in another alphabetical system.",
        "There has been increasing concern on machine transliteration as an assistant of machine translation and information retrieval.",
        "Three machine transliteration models, including \"grapheme-based model\", \"phoneme-based model\", and \"hybrid model\", have been proposed.",
        "However, there are few works trying to make use of correspondence between source grapheme and phoneme, although the correspondence plays an important role in machine transliteration.",
        "Furthermore there are few works, which dynamically handle source grapheme and phoneme.",
        "In this paper, we propose a new transliteration model based on an ensemble of grapheme and phoneme.",
        "Our model makes use of the correspondence and dynamically uses source grapheme and phoneme.",
        "Our method shows better performance than the previous works about 15~23% in English-to-Korean transliteration and about 15~43% in English-to-Japanese transliteration."
      ]
    },
    {
      "heading": "1. Introduction",
      "text": [
        "Machine transliteration is an automatic method to generate characters or words in one alphabetical system for the corresponding characters in another alphabetical system.",
        "For example, English word data is transliterated into Korean 'deita' and Japanese 'deeta'.",
        "Transliteration is used to phonetically translate proper names and technical terms especially from languages in Roman alphabets to languages in non-Roman alphabets such as from English to Korean, Japanese, and Chinese and so on.",
        "There has been increasing concern on machine transliteration as an assistant of Machine Translation (MT) [2], [10], monolingual information retrieval (MLIR) [8], [11] and cross-lingual information retrieval (CLIR) [6].",
        "In the area of MLIR and CLIR, machine transliteration bridges the gap between a transliterated localized form and its original form by generating all possible transliterated forms from each original form.",
        "Especially for CLIR, machine transliteration gives a help to query translation where proper names and technical terms frequently appear in source language queries.",
        "In the area of MT, machine transliteration prevents translation failure when translations of",
        "An Ensemble of Grapheme and Phoneme for Machine Transliteration 451 proper names and technical terms are not registered in a translation dictionary.",
        "A machine transliteration system, therefore, may affect the performance of MT, MLIR, and CLIR system.",
        "Three machine transliteration models have been studied: called \"grapheme-based transliteration model (yG)\" [7], [8], [9], [11], [12], [13], \"phoneme-based transliteration model (y/p)\" [10], [12], and \"hybrid transliteration model (yH)\" [2], [4], [12].",
        "i//G and i//P are classified in terms of units to be transliterated.",
        "i//G is referred to the direct model because it directly transforms source language graphemes to target language graphemes without any phonetic knowledge of source language words.",
        "i//P is called the pivot model because it makes use of phonemes as a pivot during a transliteration process.",
        "Therefore i//P usually needs two steps; the first step is to produce phonemes from source language graphemes, and the second step is to produce target language graphemes from phonemes.",
        "i//Hcombines i//G and i//P with the linear interpolation style.",
        "Hereafter, we will use a source grapheme for a source language grapheme and a target grapheme for a target language grapheme.",
        "Though transliteration is the phonetic process (i//P) rather than the orthographic one (tyo) [10], we should consider both source grapheme and phoneme to achieve high performance in machine transliteration because the standard transliterations are not restricted to phoneme-based transliterations.",
        "However, many previous works make use of either source grapheme or phoneme.",
        "They simplify a machine transliteration problem into either yG or yP assuming that one of i(fG and yP is able to cover all transliteration behaviors.",
        "However, transliteration is a complex process, which does not rely on either source grapheme or phoneme.",
        "For example, the standard Korean transliterations of amylase and data are grapheme-based transliteration 'amillaaje' and phoneme-based transliteration 'deiteo', respectively.",
        "A machine transliteration model, therefore, should reflect the dynamic transliteration behaviors in order to produce the correct transliterations.",
        "yH has the limited power for producing the correct transliterations because it just combines i(fG and yP with the linear interpolation style.",
        "i(fH does not consider correspondence between source grapheme and phoneme during the transliteration process.",
        "However the correspondence plays important roles in machine transliteration.",
        "For example, phoneme /AH/ produces high ambiguities since it can be mapped to almost every single vowels in source language and target language (the underlined grapheme corresponds to /AH/: cinema, hostel, holocaust in English, 'sinema', 'hostel', 'hol-lokoseuteu' in their Korean counterparts, and 'sinema', 'hoseuteru', 'horokoosuto' in their Japanese counterparts).",
        "If we know the correspondence between source grapheme and phoneme in this context, then we can more easily infer the correct transliteration of /AH/, since a target grapheme of /AH/ usually depends on a source grapheme corresponding to /AH/.",
        "Korean transliterations of source grapheme a is various such as 'a', 'ei', 'o', 'eo' and so on.",
        "Like the previous example, correspondence makes it possible to reduce transliteration ambiguities like Table 1.",
        "In Table 1, the underlined source grapheme a in the example column is pronounced as the phoneme in the phoneme column.",
        "The correct Korean transliterations of source grapheme a can be more easily found, like in the Korean grapheme column, by means of phonemes in the phoneme column.",
        "Table 1.",
        "Examples of Korean graphemes derived from source grapheme a and its corresponding phoneme: the underline indicates source graphemes corresponding to each phoneme in the phoneme column",
        "In this paper, we propose a new machine transliteration model based on an ensemble of source grapheme and phoneme, symbolized as yC (\"correspondence-based transliteration model\").",
        "yC has two strong points over yG, yP, and yH.",
        "First, yC can produce transliterations by considering correspondence between source grapheme and phoneme.",
        "As described above, correspondence is very useful for reducing transliteration ambiguities.",
        "From the viewpoint of reducing the ambiguities, yC has an advantage over yG, yP, and yH because yC can more easily reduce the ambiguities by considering the correspondence.",
        "Second, yC can dynamically handle source grapheme and phoneme according to their contexts.",
        "Because of this property, yC can produce grapheme-based transliterations as well as phoneme-based transliterations.",
        "It can also produce a transliteration, where one part is a grapheme-based transliteration and the other part is a phoneme-based transliteration.",
        "For example, the Korean transliteration of neomycin, 'neomaisin', where 'neo' is a grapheme-based transliteration and 'maisin' is a phoneme-based transliteration."
      ]
    },
    {
      "heading": "2. Correspondence-Based Machine Transliteration Model",
      "text": [
        "Correspondence-based transliteration model (ifrC) is composed of two component functions (^C: ôpxôt).",
        "In this paper, we refer to ôp as a function for \"producing pronunciation\" and öt as a function for \"producing target grapheme\".",
        "First, öp produces pronunciation and then ôt produces target graphemes with correspondence between source grapheme and phoneme produced by e>p. The goal of the ôp is to produce the most probable sequence of phonemes corresponding to source graphemes.",
        "For example, ôp produces /B/, /AO/, /~/, /R/, and /D/ for each source grapheme, b, o, a, r, and d in board (see \"The result of ôp\" in the right side of Fig 1).",
        "In this step, pronunciation is generated through two ways; pronunciation dictionary search and pronunciation estimation.",
        "A pronunciation dictionary contains the correct pronunciation corresponding to English words.",
        "Therefore, English words are first investigated whether they are registered in the dictionary otherwise their pronunciation is estimated by pronunciation estimation.",
        "The goal of ôt is to produce the most probable sequence of target graphemes with correspondence between source grapheme and phoneme, which is the result of 3p.",
        "For example, ôt produces 'b', 'o', and 'deu' using the result of ôp, b-/B/, o-/AO/, a-/~/, r-/R/, and d-/D/ (see \"The result of ôt\" in the right side of Fig 1).",
        "Finally, the target language transliteration, such as the Korean transliteration 'bodeu' for board, can be acquired by concatenating the sequence of target graphemes in the result of ôt.",
        "Korean grapheme",
        "Phoneme",
        "Example",
        "'a'",
        "/AA/",
        "adagio, safari, vivace",
        "'ae'",
        "/AE/",
        "advantage, alabaster, travertine",
        "'ei'",
        "/EY/",
        "chamber, champagne, chaos",
        "'i'",
        "/IH/",
        "advantage, average, silage",
        "'o'",
        "/AO/",
        "allspice, ball, chalk",
        "p: Producing Pronunciation Ç: Producing Target Graphem",
        "Fig.",
        "1.",
        "The overall system architecture Table 2.",
        "Feature types used for correspondence-based transliteration model: where S is a set of source graphemes (e.g. English alphabets), P is a set of phonemes defined in ARPABET, T is a set of target graphemes.",
        "Note thatfS:GSis a symbol for indicating both fS and fGS.",
        "fP:GP is a symbol for indicating both fP andfGP.",
        "Feature Type Description_Possible feature values",
        "Pronunciation estimation in ôp and ô, are trained by machine learning algorithms.",
        "To train each component function, we need features that represent training instance and data.",
        "Table 2 shows five feature types, fs, fP, fGS, fGP and fT that our model uses.",
        "Depending on component functions, different feature types are used.",
        "For example, ôp(Si) uses (fs, fGs, fp) and ô,(sb ôp(s)) does (fs, fp, fGs, fGP, fT).",
        "fS,GS",
        "fs",
        "Source graphemes",
        "Source grapheme in S; 26 alphabets for English",
        "fGS",
        "Source grapheme type",
        "Consonant (C), and Vowel (V)",
        "fP,GP",
        "fP",
        "Phonemes",
        "Phonemes in P (/AA/, /AE/, etc.)",
        "fGP",
        "Phoneme type",
        "Consonant (C), Vowel (V), Semivowel (SV) and silence (/~/)",
        "fT",
        "Target graphemes",
        "Target graphemes in T",
        "Producing pronunciation (Sp:S – P) is a function that finds phonemes in a set P for each source grapheme, where P is a set of phonemes defined in ARPABET, and S is a set of source graphemes (e.g. English alphabets).",
        "The results of this step can be represented as a sequence of correspondences between source grapheme and phoneme.",
        "We will denote it as GP=[gp1,gp2,...,gp„; gpi=(Si,Sp(Si))} where si is the ith source grapheme of SW=s1,s2,...,s„.",
        "Producing pronunciation is composed of two steps.",
        "The first step involves a search in the pronunciation dictionary, which contains English words and their pronunciation.",
        "This paper uses The CMU Pronouncing Dictionary, which contains 120,000 English words and their pronunciation.",
        "The second step involves pronunciation estimation.",
        "If an English word is not registered in the pronunciation dictionary, we must estimate its pronunciation.",
        "Table 3.",
        "An example of pronunciation estimation for b in board",
        "Let SW=s1,s2,...,sn be an English word, and PSW= p1,p2,...,pn be SWs pronunciation, where si represents the ith grapheme and pi=Sp(si).",
        "Pronunciation estimation is a task to find the most relevant phoneme among a set of all possible phonemes, which can be derived from source grapheme si.",
        "Table 3 shows an example of pronunciation estimation for b in board.",
        "In Table 3, L1~L3 and R1~R3 represent the left contexts and right contexts, respectively.",
        "C0 means the current context (or focus).",
        "S(C0) means the estimated phoneme of C0.",
        "$ is a symbol for representing the start of words.",
        "The result can be interpreted as follows.",
        "The most relevant phoneme of b, /B/, can be produced with the context, fs, fGS, and fP in contexts of L1~L3, C0, and R1~R3.",
        "Other phonemes for o, a, r, and d in board are produced in the same manner.",
        "Thus, we can get the pronunciation of board as /B AO R D/ by concatenating the phoneme sequence.",
        "Producing target graphemes (St:SxP – T) is a function that finds the target grapheme in T for each gpi that is a result of SSp.",
        "A result of this step, GT, is represented by a sequence of gpi and its corresponding target graphemes generated by St, like GT={gt1, gt2 gtn; gti=(gpi,St(gpi))}.",
        "Feature type",
        "L3",
        "L2",
        "L1",
        "C0",
        "R1",
        "R2",
        "R3",
        "Sp(co)",
        "fs",
        "$",
        "$",
        "$",
        "b",
        "o",
        "a",
        "r",
        "/B/",
        "fGS",
        "$",
        "$",
        "$",
        "C",
        "V",
        "V",
        "C",
        "fP",
        "$",
        "$",
        "$",
        "An Ensemble of Grapheme and Phoneme for Machine Transliteration 455 Table 4.",
        "An example of S for b in board",
        "Let SW=sbs2,...,sn be a source language word, PSW= Pi,P2, – ,pn be SWs pronunciation and TSW= t1, t2,...,tn be a target language word of SW, where si, Sp(si)=pi and St(gpi) = ti represent the i source grapheme, phoneme corresponding to si, and target grapheme corresponding to gpi, respectively.",
        "S finds the most probable target grapheme among a set of all possible target graphemes, which can be derived from gpi.",
        "St produces target graphemes with source grapheme (fS), phoneme (fP), source grapheme type fGS), phoneme type fGP) and S's previous output (fT) in the context window.",
        "Table 4 shows an example of St for b in board.",
        "St produces the most probable sequence of target graphemes (e.g. Korean), like S(gpi)= 'b', S(gp2)= 'o', S(gp3)=~\\ S(gp4)=~\\ and S(gp5)='deu' for board.",
        "Finally, the target language transliteration of board as 'bodeu' can be acquired by concatenating the sequence of produced target graphemes."
      ]
    },
    {
      "heading": "3. Machine Learning Algorithms for Each Component Function",
      "text": [
        "In this section we will describe a way of modeling component functions using three machine learning algorithms (maximum entropy model, decision tree, and memory-based learning).",
        "The maximum entropy model (MEM) is a widely used probability model that can incorporate heterogeneous information effectively [3].",
        "In the maximum entropy model, an event ev is usually composed of a target event (te) and a history event (he), say ev=<te, he>.",
        "Event ev is represented by a bundle of feature functions, fei(ev), which represent the existence of a certain characteristic in event ev.",
        "A feature function is a binary valued function.",
        "It is activated (fei(ev)=i) when it meets its activating condition, otherwise it is deactivated (fei(ev)=0) [3].",
        "Sp and St based on the maximum entropy model can be represented as formula (1).",
        "History events in each component function are made from the left, right and current context.",
        "For example, history events for St are composed of fSGS (i.3ii+3), fPGP (i.3,i+3), and fT (i-34-1) where i is a index of the current source grapheme and phoneme to be transliterated and fx(i,m) represents features of feature type fX located from position l to position m. Target events are a set of target graphemes (phonemes) derived from history events of St (Sp).",
        "Given history events, St (Sp) finds the most probable target grapheme (phoneme), which maximizes formula (1).",
        "One important thing in designing a model",
        "Feature type",
        "L3",
        "L2",
        "L1",
        "CO",
        "R1",
        "R2",
        "R3",
        "S(C0)",
        "fs",
        "$",
        "$",
        "$",
        "b",
        "o",
        "a",
        "r",
        "'b'",
        "fp",
        "$",
        "$",
        "$",
        "/B/",
        "/AO/",
        "/~/",
        "/R/",
        "fGS",
        "$",
        "$",
        "$",
        "C",
        "V",
        "V",
        "C",
        "fGP",
        "$",
        "$",
        "$",
        "C",
        "V",
        "/~/",
        "C",
        "fT",
        "$",
        "$",
        "$",
        "based on the maximum entropy model is to determine feature functions which effectively support certain decision of the model.",
        "Our basic philosophy of feature function design for each component function is that context information collocated with the unit of interest is an important factor.",
        "With the philosophy, we determined the history events (or activating conditions) of the feature functions by combinations of features in feature types.",
        "Possible feature combinations for history events are between features in the same feature type and between features in different feature types.",
        "The used feature combinations in each component function are listed in Table 5.",
        "Table 5.",
        "Used feature combinations for history events",
        "In formula (1), history events of 4p and 4 are defined by the conditions described in Table 5.",
        "Target events of 4t are all possible target graphemes derived from its history events; while those of 4p are all possible phonemes derived from its history events.",
        "In order to model each component function based on MEM, Zhang's maximum entropy modeling tool is used [16].",
        "Decision tree learning is one of the most widely used and well-known methods for inductive inference [15].",
        "ID3, which is a greedy algorithm and constructs decision trees in a top-down manner, adopts a statistical measure called information gain that measures how well a given feature (or attribute) separates training examples according to their target class [15].",
        "We use C4.5 [15], which is a well-known tool for decision tree learning and implementation of Quinlan's ID3 algorithm.",
        "Training data for each component function is represented by features of feature types in the context of L3~L1, CO, and R1~R3 as described in Table 3.",
        "Fig.",
        "2 shows a fraction of our decision trees for 4p and 4t in English-to-Korean transliteration (note that the left side represents the decision tree for 4p and the right side represents the decision tree for 4t).",
        "A set of the target classes in the decision tree for 4p will be a set of phonemes and that for 4t will be a set of target graphemes.",
        "In Fig. 2, rectangles indicate a leaf node and circles indicate a decision node.",
        "In order to simplify our examples, we just use fS and fP in Fig. 2.",
        "Intuitively, the most effective feature for 4p and 4t may be located in CO among L3~L1, CO, and R1~R3 because the correct outputs of 4 and 4 strongly depend on source grapheme or phoneme in the CO position.",
        "As we expected, the most effective feature in the decision trees is located in the CO position like CO(fS) for 4p and C0fP) for 4 (Note that the first feature to be tested is the most effective feature).",
        "In Fig. 2, the decision tree for 4p outputs phoneme /AO/ for the instance x(SP) by retrieving the decision nodes C(fS)=o, R1(fS)=a, and R2(fS)=r represented with '*'.",
        "With the similar manner, the decision tree for 4t produces target grapheme (Korean grapheme) 'o' for the instance x(SPJ) by retrieving the decision nodes from C0(fP)=/AO/ to R1(fP)=/~/ represented with '*'.",
        "4",
        "4",
        "Between",
        "features in",
        "the same",
        "feature",
        "Between",
        "features in the same",
        "feature",
        "type",
        "type",
        "Between",
        "features in",
        "different",
        "feature",
        "Between",
        "features in different",
        "feature",
        "types",
        "types",
        "•",
        "fs,Gs and fp",
        "• • •",
        "fS,GS and fP,GP",
        "fs,Gs and fj fp, gp and fj",
        "Fig.",
        "2.",
        "Decision tree for 4p and 4",
        "Memory-based learning (MBL) is an example-based learning method.",
        "It is also called instance-based learning and case-based learning method.",
        "It is based on a k-nearest neighborhood algorithm [1], [5].",
        "MBL represents a training data as a vector.",
        "In the training phase, MBL puts all training data as examples in memory, and clusters some examples with a k-nearest neighborhood principle.",
        "It then outputs a target class using similarity-based reasoning between test data and examples in the memory.",
        "Let test data be x and a set of examples in a memory be Y, the similarity between x and Y is estimated by a distance function, A(x,Y).",
        "MBL selects an example yi or a cluster of examples that are most similar to x, then assign a target class of the example to x's class.",
        "We use a memory-based learning tool called TiMBL (Tilburg memory-based learner) version 5.O [5].",
        "Training data for each component function is represented by features of feature types in the context of L3~L1, CO, and R1~R3 as described in Table 4.",
        "Fig.",
        "3 shows examples of 4p and 4 based on MBL in English-to-Korean transliteration.",
        "In order to simplify our examples, we just use fS and fP in Fig. 3.",
        "All training data are represented with their features in the context of L3~L1, CO, and R1~R3 and their target classes for 4 and 4t.",
        "They are stored in the memory through a training phase.",
        "Feature weighting for dealing with features of differing importance is also performed in the training phase.",
        "In Fig. 3, 4p based on MBL outputs the phoneme /AO/ for x(SP) by comparing the similarities between x(SP) and Y using distance metric A(x(SP),Y).",
        "With the similar manner, 4t based on MBL outputs the target grapheme 'o'.",
        "x(SP)",
        "Feature type",
        "L3",
        "L2",
        "L1",
        "CO",
        "R1",
        "R2",
        "R3",
        "4",
        "$",
        "$",
        "b",
        "o",
        "a",
        "r",
        "d",
        "/AO/",
        "Fig.",
        "3.",
        "Memory-based learning for 4p and 4t"
      ]
    },
    {
      "heading": "4. Experiments",
      "text": [
        "We perform experiments for English-to-Korean and English-to-Japanese transliteration.",
        "English-to-Korean test set (EKSet) [14] consists of 7,185 English-Korean pairs the number of training data is 6,185 and that of test data is 1,OOO.",
        "EKSet contains no transliteration variations.",
        "English-to-Japanese test set (EJSet), which is an English-katakana pair in EDICT, consists of 1O,398 - 1,OOO for test and the rest for training.",
        "EJSet contains transliteration variations, like (micro, 'maikuro') and (micro, 'mi-kuro'); the average number of Japanese transliterations for an English word is 1.15.",
        "Evaluation is performed by word accuracy (W.",
        "A.)",
        "in formula (2).",
        ", #of correct words # of generated words",
        "We perform two experiments called \"Comparison test\" and \"Context window size test\".",
        "In the \"Comparison test\", we compare our i//C with the previous works.",
        "In \"Context window size test\", we evaluate the performance of our transliteration model depending on context window size.",
        "Table 6 shows results of \"Comparison test\".",
        "MEM, DT, and MBL represent i//Cbased on maximum entropy model, decision tree, and memory-based learning, respectively.",
        "GDT [8], GPC [9], GMEM [7] and HWFST [4], which are one of the best machine transliteration methods in English-to-Korean transliteration and English-to-Japanese transliteration, are compared with yc.",
        "Table 7 shows the key feature of each method in the viewpoint of information type (SG, PH, COR) and information usage (Context size, POut).",
        "Information type indicates that each transliteration method belongs to which transliteration model.",
        "For example, GDT, GPC, and GMEM will belong to i//G because they use only the source grapheme; while HWFST belongs to y/H.",
        "Information usage gives information about what kinds of information each transliteration method can deal with.",
        "From the viewpoint of information type, phoneme and correspondence, which most previous works do not consider, is the key point of the performance gap between our method and the previous works.",
        "[ Training instances in a memory (4) 1",
        "Training instances in a memory (4) |",
        "yi",
        "Feature",
        "type",
        "L3",
        "L2",
        "L1",
        "CO",
        "R1",
        "R2",
        "R3",
        "4p(C0)",
        "£(x(SP),yi)",
        ")",
        "Feature",
        "type",
        "L3",
        "L2",
        "L1",
        "CO",
        "R1",
        "R2",
        "R3",
        "4.co>",
        "A(x(SPT),yj",
        "2",
        "fs fs",
        "h",
        "a",
        "b",
        "o",
        "$",
        "$",
        "$",
        "/OW/",
        "O 38",
        "f-",
        "$",
        "/AH/",
        "/B/",
        "/AO/",
        "a~/",
        "/R/",
        "/D/",
        "3",
        "fs",
        "$",
        "$",
        "b",
        "o",
        "a",
        "s",
        "t",
        "/OW/",
        "fs",
        "$",
        "$",
        "c",
        "o",
        "a",
        "r",
        "s",
        "O.63",
        "4",
        "fs",
        "$",
        "$",
        "b",
        "o",
        "a",
        "t",
        "$",
        "/OW/",
        "O81",
        "fp",
        "$",
        "$",
        "/K/",
        "/OW/",
        "/~/",
        "/R/",
        "/S/",
        "5",
        "fs",
        "$",
        "$",
        "c",
        "o",
        "a",
        "r",
        "s",
        "/AO/",
        "O73",
        "3",
        "fS",
        "$",
        "e",
        "d",
        "o",
        "a",
        "r",
        "d",
        "O.55",
        "6",
        "/s",
        "$",
        "e",
        "d",
        "o",
        "a",
        "r",
        "d",
        "/W/",
        "O75",
        "fp",
        "$",
        "/~/",
        "/D/",
        "/W/",
        "/~/",
        "/R/",
        "/D/",
        "7",
        "fs",
        "c",
        "k",
        "s",
        "a",
        "w",
        "$",
        "$",
        "/AO/",
        "O16",
        "f.S",
        "e",
        "a",
        "b",
        "o",
        "u",
        "t",
        "$",
        "'u'",
        "O.31",
        "■",
        "$",
        "fs",
        "e",
        "a",
        "b",
        "o",
        "u",
        "t",
        "$",
        "/UW/",
        "O 51",
        "1--3*",
        "I-' :",
        "y :",
        "x(SP)",
        "'eature type",
        "L3",
        "L2",
        "1",
        "CO",
        "R1",
        "R2",
        "R3",
        "4",
        "x(SPJ",
        "Feature type",
        "L3",
        "L2",
        "L1",
        "CO",
        "R1",
        "R2",
        "R3",
        "4",
        "$",
        "$",
        "o",
        "a",
        "/AO/",
        "fS",
        "$",
        "$",
        "b",
        "o",
        "r",
        "d",
        "fP",
        "$",
        "$",
        "/B/",
        "/AO/",
        "~/",
        "/R",
        "/D/",
        "An Ensemble of Grapheme and Phoneme for Machine Transliteration 459 Table 6.",
        "Evaluation results of \"Comparison test\" Table 7.",
        "Key features of our machine transliteration model and the previous works: SG, PH, COR and POut represent source grapheme, phoneme, correspondence and previous output, respectively",
        "From the viewpoint of information usage, if a transliteration model adopts wide context window and considers previous outputs, it tends to show better performance.",
        "For example, GMEM that satisfies the conditions gives more accurate results than GDT which does not satisfy one of them.",
        "Because machine transliteration is sensitive to context, wider contexts give more powerful transliteration ability to machine transliteration systems.",
        "Note that the previous works, however, limit their context window size to 3, because the context window size over 3 degrades the performance [8] or does not change the performance of their transliteration model [9].",
        "Determining reasonable context window size, therefore, is very important for machine transliteration.",
        "For \"Context window size test\", we use yC based on MBL, which shows the best performance among three machine learning algorithms in Table 6.",
        "Experiments are performed by changing the context window size from 1 to 5.",
        "Table 8 shows results of context window size test.",
        "The results indicate that the best performance is shown when the context window size is 3.",
        "When the context window size is 1, there are many cases where the correct transliterations are not produced due to lack of information.",
        "For example, in order to produce the correct target grapheme of t in -tion, we need the right three graphemes of t, -ion.",
        "When the context window size is over 3, it is difficult to generalize the training data because of increase of variety of the training data.",
        "With the two reasons, our system shows the best performance when the context window size is 3.",
        "Table 8 also shows that context size should be at least 2 to avoid significant decrease of performance due to lack of contextual information.",
        "Method",
        "EKSet",
        "EJSet",
        "W.A",
        "Chg %",
        "W.A",
        "Chg %",
        "GDT",
        "51.4%",
        "23.2%",
        "5O.3%",
        "43.5%",
        "GPC",
        "55.1%",
        "17.6%",
        "53.2%",
        "35.7%",
        "GMEM",
        "55.9%",
        "16.4%",
        "56.2%",
        "28.5%",
        "HWFST",
        "58.3%",
        "14.7%",
        "62.5%",
        "15.5%",
        "DT",
        "62.O%",
        "7.3%",
        "66.8%",
        "8.1%",
        "MEM",
        "63.3%",
        "5.4%",
        "67.O%",
        "7.8%",
        "MBL",
        "66.9%",
        "72.2%",
        "Method",
        "SG",
        "PH",
        "COR",
        "Context size",
        "POut",
        "GDT",
        "O",
        "X",
        "X",
        "<-3, +3>",
        "X",
        "GPC",
        "O",
        "X",
        "X",
        "Unbounded",
        "O",
        "GMEM",
        "O",
        "X",
        "X",
        "<-3, +3>",
        "O",
        "HWFST",
        "O",
        "O",
        "X",
        "-",
        "-",
        "Ours",
        "O",
        "O",
        "O",
        "<-3, +3>",
        "O",
        "Table 8.",
        "Evaluation results of \"Context window size test\"",
        "Context Size",
        "In summary, our method shows significant performance improvement, about 15%~23%, in English-to-Korean transliteration, and about 15%~ 43% in English-to-Japanese transliteration.",
        "Experiments show that a good transliteration system should consider; 1) source grapheme and phoneme along with their correspondence simultaneously and 2) reasonable context size and previous output.",
        "Our transliteration model satisfies the two conditions, thus it shows higher performance than the previous works."
      ]
    },
    {
      "heading": "5. Conclusion",
      "text": [
        "This paper has described a correspondence-based machine transliteration model (ifrC).",
        "Unlike the previous transliteration models, i(fC uses correspondence between source grapheme and phoneme.",
        "The correspondence makes it possible for yC to effectively produce both grapheme-based transliterations and phoneme-based transliterations.",
        "Moreover, the correspondence helps i(fC to reduce transliteration ambiguities more easily.",
        "Experiments show that i(fC is more powerful transliteration model than the previous transliteration models (y/C shows significant performance improvement, about 15%~23%, in English-to-Korean transliteration, and about 15%~ 43% in English-to-Japanese transliteration).",
        "In future work, we will apply our transliteration model to English-to-Chinese transliteration model.",
        "In order to prove usefulness of our method in NLP applications, we need to apply our system to applications such as automatic bilingual dictionary construction, information retrieval, machine translation, speech recognition and so on.",
        "Acknowledgement",
        "This work was supported by the Korea Ministry of Science and Technology, the Korea Ministry of Commerce, Industry and Energy, and the Korea Science and Engineering Foundation (KOSEF)."
      ]
    }
  ]
}
