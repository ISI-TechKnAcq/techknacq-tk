{
  "info": {
    "authors": [
      "Mark Johnson"
    ],
    "book": "COLING-ACL",
    "id": "acl-P98-1101",
    "title": "Finite-state Approximation of Constraint-based Grammars using Left-corner Grammar Transforms",
    "url": "https://aclweb.org/anthology/P98-1101",
    "year": 1998
  },
  "references": [
    "acl-C92-1032",
    "acl-J97-3004",
    "acl-P85-1018",
    "acl-P91-1032"
  ],
  "sections": [
    {
      "heading": "Abstract",
      "text": [
        "This paper describes how to construct a finite-state machine (FSM) approximating a 'unification-based' grammar using a left-corner grammar transform.",
        "The approximation is presented as a series of grammar transforms, and is exact for left-linear and right-linear CFGs, and for trees up to a user-specified depth of center-embedding."
      ]
    },
    {
      "heading": "1 Introduction",
      "text": [
        "This paper describes a method for approximating grammars with finite-state machines.",
        "Unlike the method derived from the LR(k) parsing algorithm described in Pereira and Wright (1991), these methods use grammar transformations based on the left-corner grammar transform (Rosenkrantz and Lewis II, 1970; Aho and Ullman, 1972).",
        "One advantage of the left corner methods is that they generalize straightforwardly to complex feature \"unification based\" grammars, unlike the LR(k) based approach.",
        "For example, the implementation described here translates a DCG version of the example grammar given by Pereira and Wright (1991) directly into a FSM without constructing an approximating CFG.",
        "Left-corner based techniques are natural for this kind of application because (with the simple optimization described below) they can parse pure left-branching or pure right-branching structures with a stack depth of one (two if terminals are pushed and popped from the stack).",
        "Higher stack depth occurs with center-embedded structures, which humans find difficult to comprehend.",
        "This suggests that we may get a finite-state approximation to human performance by simply imposing a stack depth bound.",
        "We provide a simple tree-geometric description of the configurations that cause an increase in a left corner parser's stack depth below.",
        "The rest of this paper is structured as follows.",
        "The remainder of this section outlines the \"grammar transform\" approach, summarizes the top-down",
        "parsing algorithm and discusses how finite state approximations of top-down parsers can be constructed.",
        "The fact that this approximation is not exact for left linear grammars (which define finite-state languages) motivates a finite-state approximation based on the left-corner parsing algorithm (which is presented as a grammar transform in section 2).",
        "In its standard form the approximation based on the left-corner parsing algorithm suffers from the complementary problem to the top-down approximation: it is not exact for right-linear grammars, but the \"optimized\" variants presented in section 3 overcome this deficiency, resulting in finite-state CFG approximations which are exact for left-linear and right-linear grammars.",
        "Section 4 discusses how these techniques can be combined in an implementation."
      ]
    },
    {
      "heading": "1.1 Parsing strategies as grammar transformations",
      "text": [
        "The parsing algorithms discussed here are presented as grammar transformations, i.e., functions T that map a context-free grammar G into another context-free grammar T(G).",
        "The transforms have the property that a top-down parse using the transformed grammar is isomorphic to some other kind of parse using the original grammar.",
        "Thus grammar transforms provide a simple, compact way of describing various parsing algorithms, as a top-down parser using T(G) behaves identically to the kind of parser we want to study using G."
      ]
    },
    {
      "heading": "1.2 Mappings from trees to trees",
      "text": [
        "The transformations presented here can also be understood as isomorphisms from the set of parse trees of the source grammar G to parse trees of the transformed grammar which preserve terminal strings.",
        "Thus it is convenient to explain the transforms in terms of their effect on parse trees.",
        "We call a parse tree with respect to the source grammar G an analysis tree, in order to distinguish it from parse trees with respect to some transform of G. The analysis tree t in Figure 1 will be used as an example throughout this paper."
      ]
    },
    {
      "heading": "1.3 Top-down parsers and parse trees",
      "text": [
        "The \"predictive\" or \"top-down\" recognition algorithm is one of the simplest CFG recognition algorithms.",
        "Given a CFG G = (N ,T , P, S), a (top-down) stack state is a sequence of terminals and nonterminals.",
        "Let Q = (N UT)* be the set of stack states for G. The start state qo E Q is the sequence S, and the final state qf E Q is the empty sequence f. The state transition function 8: Q x (TU{c}) 1-4 2Q maps a state and a terminal or epsilon into a set of states.",
        "It is the smallest function 8 that satisfies the following conditions:",
        "A string w is accepted by the top-down recognition algorithm if gf E 5*(go,w), where 8* is the reflexive transitive closure of 5 with respect to epsilon moves.",
        "Extending this top-down parsing algorithm to a 'unification-based' grammar is straight-forward, and described in many textbooks, such as Pereira and Shieber (1987).",
        "It is easy to read off the stack states of a top-down parser constructing a parse tree from the tree itself.",
        "For any node X in the tree, the stack contents of a top-down parser just before the construction of X consists of (the label of) X followed by the sequence of labels on the right siblings of the nodes encountered on the path from X back to the root.",
        "It is easy to check that a top-down parser requires a stack of depth 3 to construct the tree t depicted in Figure 1."
      ]
    },
    {
      "heading": "1.4 Finite-state approximations",
      "text": [
        "We obtain a finite-state approximation to a top-down parser by restricting attention to only a finite number of possible stack states.",
        "The system implemented here imposes a stack depth restriction, i.e., the transition function is modified so that there are no transitions to any stack state whose size is larger than some user-specified limit.'",
        "This restriction ensures that there is only a finite number of possible stack states, and hence that the top down parser is an finite-state machine.",
        "The resulting finite-state machine accepts a subset of the language generated by the original grammar.",
        "The situation becomes more complicated when we move to 'unification-based' grammars, since there may be an unbounded number of different categories appearing in the accessible stack states.",
        "In the system implemented here we used restriction (Shieber, 1985) on the stack states to restrict attention to a finite number of distinct stack states for any given stack depth.",
        "Since the restriction operation maps a stack state to a more general one, it produces a finite-state approximation which accepts a superset of the language generated by the original unification grammar.",
        "Thus for general constraint-based grammars the language accepted by our finite-state approximation is not guaranteed to be either a superset or a subset of the language generated by the input grammar."
      ]
    },
    {
      "heading": "2 The left-corner transform",
      "text": [
        "While conceptually simple, the top-down parsing algorithm presented in the last section suffers from a number of drawbacks for a finite-state approximation.",
        "For example, the number of distinct accessible stack states is unbounded if the grammar is left-recursive, yet left-linear grammars always generate regular languages.",
        "This section presents 'With the optimized left-corner transforms described below we obtain acceptable approximations with a stack size limit of 5 or less.",
        "In many useful cases, including the example grammar provided by Pereira and Wright (1991), this stack bound is never reached and the system reports that the FSA it returns is exact.",
        "the standard left-corner grammar transformation (Rosenkrantz and Lewis II, 1970; Aho and Ullman, 1972); these references should be consulted for proofs of correctness.",
        "This transform serves as the basis for the further transforms described in the next section; these transforms have the property that the output grammar induces a finite number of distinct accessible stack states if their input is a left-recursive left-linear grammar.",
        "Given an input grammar G with nonterminals N and terminals T, these transforms a i produce grammars with an enlarged set of nonterminals N' = N U (N x (N UT)).",
        "The new \"pair\" categories in N x (N U T) are written A-X, where A is a nonterminal of G and X is either a terminal or nonterminal of G. It turns out that if A X-y then A-X =.",
        "*cci(G) -y, i.e., a non-terminal A-X in the transformed grammar derives the difference between A and X in the original grammar, and the notation is meant to be suggestive of this.",
        "The left-corner transform of a CFG G = (N,T, P, S) is a grammar LCi (G) = (N' , , S) where P1 contains all productions of the form (1.a1.c).",
        "This paper assumes that N n T = 0, as is standard.",
        "To save space we assume that P does not contain any epsilon productions (but it is straightforward to deal with them).",
        "A 4 a A-a : A E N,a E T. (1.a)",
        "Informally, the productions (1.a) start the left-corner recognition of A by recognizing a terminal a as a possible left-corner of A.",
        "The actual left-corner recognition is performed by the productions (1.b), which extend the left-corner from X to its parent B by recognizing 0; these productions are used repeatedly to construct increasingly larger left-corners.",
        "Finally, the productions (1.c) terminate the recognition of A when this left-corner construction process has constructed an A.",
        "The left-corner transform preserves the number of parses of a string, so it defines an isomorphism from analysis trees (i.e., parse trees with respect to G) to parse trees with respect to LCi(G).",
        "If t is a parse tree with respect to G then (abusing notation) LC1(t) is the corresponding parse tree with respect to LC1(G).",
        "Figure 1 shows the effect of this mapping on a simple tree.",
        "The transformed tree is considerably more complex: it has double the number of nodes of the original tree.",
        "In a top-down parse of the tree LCi (t) in Figure 1 the maximum stack depth is 3, which occurs at the recognition of the terminals ran and fast."
      ]
    },
    {
      "heading": "2.1 Filtering useless categories",
      "text": [
        "In general the grammar produced by the transform LCi(G) contains a large number of useless nonterminals, i.e., non-terminals which can never appear in any complete derivation, even if the grammar G is fully pruned (i.e., contains no useless productions).",
        "While CC1(G) can be pruned using standard algorithms, given the observation about the relationship between the pair non-terminals in LC1(G) and nonterminals in G, it is clear that certain productions can be discarded immediately as useless.",
        "Define the left-corner relation a C (N U T) x N as follows:",
        "X a A if 30.",
        "A 4 X [3 E P,",
        "Let .4* be the reflexive and transitive closure of a.",
        "It is easy to show that a category A-X is useless in LCi (G) (i.e., derives no sequence of terminals) unless X a* A.",
        "Thus we can restrict the productions in (1.a-1.c) without affecting the language (strongly) generated to those that only contain pair categories A-X where X a* A.",
        "2.2 Unification grammars One of the main advantages of left-corner parsing algorithms over LR(k) based parsing algorithms is that they extend straightforwardly to complex feature based \"unification\" grammars.",
        "The transformation LC1 itself can be encoded in several lines of Prolog (Matsumoto et al., 1983; Pereira and Shieber, 1987).",
        "This contrasts with the LR(k) methods.",
        "In LR(k) parsing a single LR state may correspond to several items or dotted rules, so it is not clear how the feature \"unification\" constraints should be associated with transitions from LR state to LR state (see Nakazawa (1995) for one proposal).",
        "In contrast, extending the techniques described here to complex feature based \"unification\" grammar is straightforward.",
        "The main complication is the filter on useless nonterminals and productions just discussed.",
        "Generalizing the left-corner closure filter on pair categories to complex feature \"unification\" grammars in an efficient way is complicated, and is the primary difficulty in using left-corner methods with complex feature based grammars.",
        "van Noord (1997) provides a detailed discussion of methods for using such a \"left-corner filter\" in unification-grammar parsing, and the methods he discusses are used in the implementation described below."
      ]
    },
    {
      "heading": "3 Extended left-corner transforms",
      "text": [
        "This section presents some simple extensions to the basic left-corner transform presented above.",
        "The 'tail-recursion' optimization permits bounded-stack parsing of both left and right linear constructions.",
        "Further manipulation of this transform puts it into a form in which we can identify precisely the tree configurations in the original grammar which cause the stack size of a left-corner parser to increase.",
        "These",
        "observations motivate the special binarization methods described in the next section, which minimize stack depth in grammars that contain productions of length no greater than two."
      ]
    },
    {
      "heading": "3.1 A tail-recursion optimization",
      "text": [
        "If G is a left-linear grammar, a top-down parser using 1X1 (G) can recognize any string generated by G with a constant-bounded stack size.",
        "However, the corresponding operation with right-linear grammars requires a stack of size proportional to the length of the string, since the stack fills with paired categories A – A for each non-left-corner nonterminal in the analysis tree.",
        "The 'tail recursion' or 'composition' optimization (Abney and Johnson, 1991; Resnik, 1992) permits right-branching structures to be parsed with bounded stack depth.",
        "It is the result of epsilon removal applied to the output of GC1, and can be described in terms of resolution or partial evaluation of the transformed grammar with respect to productions (1.c).",
        "In effect, the schema (1.b) is split into two cases, depending on whether or not the rightmost nonterminal A – B is expanded by the epsilon rules produced by schema (1.c).",
        "This expansion yields a grammar £C2 (G) = (N', T, P2 S ) , where P2 contains all productions of the form (2.a-2.c).",
        "(In these schemata A, B E N; a E T; X E NUT and",
        "Figure 1 shows the effect of the transform 12C2 on the example tree.",
        "The maximum stack depth required for this tree is 2.",
        "When this 'tail recursion' optimization is applied, pair categories in the transformed grammar encode proper left-corner relationships between nodes in the analysis tree.",
        "This lets us strengthen the 'useless category' filter described above as follows.",
        "Let a+ be the transitive closure of the left-corner relation a defined above.",
        "It is easy to show that a category A – X is useless in 12C2 (G) (i.e., derives no sequence of terminals) unless Xa+ A.",
        "Thus we can restrict the productions in (2.a-2.b) without affecting the language (strongly) generated to just those that only contain pair categories A – X where X a+ A."
      ]
    },
    {
      "heading": "3.2 The special case of binary productions",
      "text": [
        "We can get a better idea of the properties of transformation LC2 if we investigate the special case where the productions of G are unary or binary.",
        "In this situation, transformation £C2(G) can be more explicitly written as CCa(G) = (N',T, P3 , S ) , where P3 contains all instances of the production schemata (3.a-3.e).",
        "(In these schemata, a E T; A, B E N and X,YENUT).",
        "characteristic of the use of production schema (4.f) in transform LC4.",
        "This is the only configuration which causes an increase in stack depth in a top-down parser using a grammar transformed with LC4.",
        "Productions (3.b-3.c) and (3.d-3.e) correspond to unary and binary productions respectively in the original grammar.",
        "Now, note that nonterminals from N only appear in the right hand sides of productions of type (3.d) and (3.e).",
        "Moreover, any such nonterminals must be immediately expanded by a production of type (3.a).",
        "Thus these non-terminals are eliminable by resolving them with (3.a); the only remaining nonterminal is the start symbol S. This expansion yields a new transform LC4, where £C4(G) = ({S} u (N x (N U T)), P4, S).",
        "P4 defined in (4.a-4.g), still contains productions of type (3.a), but these only expand the start symbol, as all occurences of nonterminals in N have been resolved away.",
        "(In these schemata a E T; A,B,C,D E N andXENUT).",
        "In the production schemata defining LC4, (4.a-4.c) are copied directly from (3.a-3.c) respectively.",
        "The schemata (4.d-4.e) are obtained by instantiating Y in (3.d-3.e) to a terminal a E T, while the other two schemata (4.f-4.g) are obtained by instantiating Y in (3.d-3.e) with the right hand sides of (3.a).",
        "Figure 1 shows the result of applying the transformation £C4 to the example analysis tree t. The transform also simplifies the specification of finite-state machine approximations.",
        "Because all terminals are introduced as the leftmost symbols in",
        "their productions, there is no need for terminal symbols to appear on the parser's stack, saving an epsilon transition associated with a stack push and an immediately following stack pop with respect to the standard left-corner algorithm.",
        "Productions (4.a) and (4.d-4.g) can be understood as transitions over a terminal a that replace the top stack element with a sequence of other elements, while the other productions can be interpreted as epsilon transitions that manipulate the stack contents accordingly.",
        "Note that the right hand sides of all of these productions except for schema (4.f) are right-linear.",
        "Thus instances of this schema are the only productions that can increase the stack size in a top-down parse with LC4(G), and the stack depth required to parse an analysis tree is the maximum number of \"zig-zag\" patterns in the path in the analysis tree from any terminal node to the root.",
        "Figure 2 sketches the configuration of nodes in the analysis trees in which instances of schemata (4.f) would be used in a parse using LC4(G).",
        "This highly distinctive \"zig-zag\" or \"lightning bolt\" pattern does not occur at all in the example tree t in Figure 1, so the maximum required stack depth is 2.",
        "(Recall that in a traditional top-down parser terminals are pushed onto the stack and popped later, so initialization productions (4.a) cause two symbols to be pushed onto the stack).",
        "It follows that this finite state approximation is exact for left-linear and right-linear CFGs.",
        "Indeed, analysis trees that consist simply of a left-branching subtree followed by a right-branching subtree, such as the example tree t, are transformed into strictly right-branching trees by LC4."
      ]
    },
    {
      "heading": "4 Implementation",
      "text": [
        "This section provides further details of the finite-state approximator implemented in this research.",
        "The approximator is written in Sicstus Prolog.",
        "It takes a user-specifier Definite Clause Grammar G (without Prolog annotations) as input, which it bi-narizes and then applies transform LC4 to.",
        "The implementation annotates each transition with the production it corresponds to (represented as a pair of a LC4 schema number and a production number from G), so the finite-state approximation actually defines a transducer which transduces a lexical input to a sequence of productions which specify a parse of that input with respect to LC4(G).",
        "A following program inverts the tree transform LC4, returning a corresponding parse tree with respect to G. This parse tree can be checked by performing complete unifications with respect to the original grammar productions if so desired.",
        "Thus the finite-state approximation provides an efficient way of determining if an analysis of a given input string with respect to a unification grammar G exists, and if so, it can be used to suggest such analyses."
      ]
    },
    {
      "heading": "5 Conclusion",
      "text": [
        "This paper surveyed the issues arising in the construction of finite-state approximations of left-corner parsers.",
        "The different kinds of parsers were presented as grammar transforms, which let us abstract away from the algorithmic details of parsing algorithms themselves.",
        "It derived the various forms of the left-corner parsing algorithms in terms of grammar transformations from the original left-corner grammar transform."
      ]
    }
  ]
}
