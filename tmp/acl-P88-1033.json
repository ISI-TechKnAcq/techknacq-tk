{
  "info": {
    "authors": [
      "Remo Pareschi"
    ],
    "book": "Annual Meeting of the Association for Computational Linguistics",
    "id": "acl-P88-1033",
    "title": "A Definite Clause Version of Categorial Grammar",
    "url": "https://aclweb.org/anthology/P88-1033",
    "year": 1988
  },
  "references": [
    "acl-C86-1045",
    "acl-J88-4001",
    "acl-P86-1037",
    "acl-P87-1011",
    "acl-P87-1012"
  ],
  "sections": [
    {
      "heading": "ABSTRACT",
      "text": [
        "We introduce a first-order version of Catego-rial Grammar, based on the idea of encoding syntactic types as definite clauses.",
        "Thus, we drop all explicit requirements of adjacency between combinable constituents, and we capture word-order constraints simply by allowing subformula.e of complex types to share variables ranging over string positions.",
        "We are in this way able to account for constructions involving discontinuous constituents.",
        "Such constructions are difficult to handle in the more traditional version of Cate-gorial Grammar, which is based on propositional types and on the requirement of strict string adjacency between combinable constituents.",
        "We show then how, for this formalism, parsing can be efficiently implemented as theorem proving.",
        "Our approach to encoding types-as definite clauses presupposes a modification of standard Horn logic syntax to allow internal implications in definite clauses.",
        "This modification is needed to account for the types of higher-order functions and, as a consequence, standard Prolog-like Horn logic theorem proving is not powerful enough.",
        "We tackle this •I am indebted to Dale Miller for help and advice.",
        "I am also grateful to Aravind Joshi, Mark Steedrnan, David Weir, Bob Frank, Mitch Marcus and Yves Schabes for comments and discussions.",
        "Thanks are due to Elsa Gunter and Amy Felty for advice on typesetting.",
        "Parts of this research were supported by: a Sloan foundation grant to the Cognitive Science Program, Univ.",
        "of Pennsylvania; and NSF grants MCS-8219196-CER, IRI-10413 A02, ARO grants DAA29-84-K-0061, DAA29-84-9-0027 and DARPA grant N00014-85-K0018 to CIS, Univ.",
        "of Pennsylvania."
      ]
    },
    {
      "heading": "t Address for correspondence",
      "text": [
        "problem by adopting an intuitionistic treatment of implication, which has already been proposed elsewhere as an extension of Prolog for implementing hypothetical reasoning and modular logic programming."
      ]
    },
    {
      "heading": "1 Introduction",
      "text": [
        "Classical Categorial Grammar (CG) [I] is an approach to natural language syntax where all linguistic information is encoded in the lexicon, via the assignment of syntactic types to lexical items.",
        "Sudi syntactic types can be viewed as expressions of an implicational calculus of propositions, where atomic propositions correspond to atomic types, and implicational propositions account for complex types.",
        "A string is grammatical if and only if its syntactic type can be logically derived from the types of its words, assuming certain inference rules.",
        "In classical CG, a common way of encoding word-order constraints is by having two symmetric forms of \"directional\" implication, usually indicated with the forward slash / and the backward slash \\, constraining the antecedent of a complex type to be, respectively, right or left-adjacent.",
        "A word, or a string of words, associated with a right-(left-) oriented type can then be thought of as a right (left-) oriented function looking for an argument of the type specified in the antecedent.",
        "A convention more or less generally followed by linguists working in CG is to have the antecedent and the consequent of an implication respectively on",
        "the right and on the left of the connective.",
        "Thus, the type-assignment (1) says that the ditransitive verb put is a function taking a right-adjacent argument of type NP, to return a function taking a right-adjacent argument of type PP, to return a function taking a left-adjacent argument of type NP, to finally return an expression of the atomic type S.",
        "(1) put : ((S\\NP)/PP)/NP",
        "The Definite Clause Grammar (DCG) framework [14] (see also [13]), where phrase-structure grammars can be encoded as sets of definite clauses (which are themselves a subset of Horn clauses), and the formalization of some aspects of it in [15], suggests a more expressive alternative to encode word-order constraints in CG.",
        "Such an alternative eliminates all notions of directionality from the logical connectives, and any explicit requirement of adjacency between functions and arguments, and replaces propositions with first-order formulae.",
        "Thus, atomic types are viewed as atomic formulae obtained from two-place predicates over string positions represented as integers, the first and the second argument corresponding, respectively, to the left and right end of a given string.",
        "Therefore, the set of all sentences of length j generated from a certain lexicon corresponds to the type S(0, j).",
        "Constraints over the order of constituents are enforced by sharing integer indices across subformulae inside complex (functional) types.",
        "This first-order version of CG can be viewed as a logical reconstruction of some of the ideas behind the recent trend of Categorial Unification Grammars [5, 18, 20]'.",
        "A strongly analogous development characterizes the systems of type-assignment for the formal languages of Combinatory Logic and Lambda Calculus, leading from propositional type systems to the \"formulae-as-types\" slogan which is behind the current research in type theory [2].",
        "In this paper, we show how syntactic types can be encoded using an extended version of standard Horn logic syntax."
      ]
    },
    {
      "heading": "2 Definite Clauses with Internal Implications",
      "text": [
        "Let A and – ■ be logical connectives for conjunction and implication, and let V and 3 be the univer'Indeed, Uszkoreit 1181 mentions the possibility of encoding order constraints among constituents via variables ranging over string positions in the DCG style.",
        "sal and existential quantifiers.",
        "Let A be a syntactic variable ranging over the set of atoms, i. e. the set of atomic first-order formulae, and let D and G be syntactic variables ranging, respectively, over the set of definite clauses and the set of goal clauses.",
        "We introduce the notions of definite clause and of goal clause via the two following mutually recursive definitions for the corresponding syntactic variables D and G:",
        "• D := A I G A IVxD I Di A D2 • G:=AIGiAG213xGID – *G",
        "We call ground a clause not containing variables.",
        "We refer to the part of a non-atomic definite clause coming on the left of the implication connective as to the body of the clause, and to the one on the right as to the head.",
        "With respect to standard Horn logic syntax, the main novelty in the definitions above is that we permit implications in goals and in the bodies of definite clauses.",
        "Extended Horn logic syntax of this kind has been proposed to implement hypothetical reasoning [3] and modules [7] in logic programming.",
        "We shall first make clear the use of this extension for the purpose of linguistic description, and we shall then illustrate its operational meaning."
      ]
    },
    {
      "heading": "3 First-order Categorial Grammar",
      "text": []
    },
    {
      "heading": "3.1 Definite Clauses as Types",
      "text": [
        "We take CONN (for \"connects\") to be a three-place predicate defined over lexical items and pairs of integers, such that CONN(item,i,j) holds if and only if and only if i = j – 1, with the intuitive meaning that item lies between the two consecutive string positions i and j.",
        "Then, a most direct way to translate in first-order logic the type-assignment (1) is by the type-assignment (2), where, in the formula corresponding to the assigned type, the non-directional implication connective replaces the slashes.",
        "A definite clause equivalent of the formula in (2) is given by the type-assignment (3)2.",
        "(3) put : VxVyVzVw[CONN(put, y – 1, y) A NP(y, z) A",
        "Observe that the predicate CONNwill need also to be part of types assigned to \"non-functional\" lexical items.",
        "For example, we can have for the noun-phrase Mary the type-assignment (4).",
        "(4) Mary: Vy[CONN(Mary, y – 1, y) NP(y – 1, y)]"
      ]
    },
    {
      "heading": "3.2 Higher-order Types and Internal Implications",
      "text": [
        "Propositional CG makes crucial use of functions of higher-order type.",
        "For example, the type-assignment (5) makes the relative pronoun which into a function taking a right-oriented function from noun-phrases to sentences and returning a relative clause3.",
        "This kind of type-assignment has been used by several linguists to provide attractive accounts of certain cases of extraction [16, 17, 10].",
        "(5) which : REL/(S/ NP)",
        "In our definite clause version of CG, a similar assignment, exemplified by (6), is possible, since implications are allowed in the, body of clauses.",
        "Notice that in (6) the noun-phrase needed to fill the extraction site is \"virtual\", having null length.",
        "(6) which : VvVy[CONN(which, v – 1, v) A",
        "2 See [2] for a pleasant formal characterization of first-order definite clauses as type declarations.",
        "3 For simplicity sake, we treat here relative clauses as constituents of atomic type.",
        "But in reality relative clauses are noun modifiers, that is, functions from nouns to nouns.",
        "Therefore, the propositional and the first-order atomic type for relative clauses in the examples below should be thought of as shorthands for corresponding complex types."
      ]
    },
    {
      "heading": "3.3 Arithmetic Predicates",
      "text": [
        "The fact that we quantify over integers allows us to use arithmetic predicates to determine subsets of indices over which certain variables must range.",
        "This use of arithmetic predicates characterizes also Rounds' ILFP notation [15], which appears in many ways interestingly related to the framework proposed here.",
        "We show here below how this capability can be exploited to account for a case of extraction which is particularly problematic for bidirectional propositional CG."
      ]
    },
    {
      "heading": "3.3.1 Non-peripheral Extraction",
      "text": [
        "Both the propositional type (5) and the first-order type (6) are good enough to describe the kind of constituent needed by a relative pronoun in the following right-oriented case of peripheral extraction, where the extraction site is located at one end of the sentence.",
        "(We indicate the extraction site with an upward-looking arrow.)",
        "which [ I shall put a book on However, a case of non-peripheral extraction, where the extraction site is in the middle, such as which [ I shall put T on the table ] is difficult to describe in bidirectional propositional CG, where all functions must take left or right-adjacent arguments.",
        "For instance, a solution like the one proposed in [17] involves permuting the arguments of a given function.",
        "Such an operation needs to be rather cumbersomely constrained in an explicit way to cases of extraction, lest it should wildly overgenerate.",
        "Another solution, proposed in [10], is also cumbersome and counterintuitive, in that involves the assignment of multiple types to wh-expressions, one for each site where extraction can take place.",
        "On the other hand, the greater expressive power of first-order logic allows us to elegantly generalize the type-assignment (6) to the type-assignment (7).",
        "In fact, in (7) the variable identifying the extraction site ranges over the set of integers in between the indices corresponding, respectively, to the left and right end of the sentence on which the relative pronoun operates.",
        "Therefore, such a sentence can have an extraction site anywhere between its string boundaries.",
        "Non-peripheral extraction is but one example of a class of discontinuous constituents, that is, constituents where the function-argument relation is not determined in terms of left or right-adjacency, since they have two or more parts disconnected by intervening lexical material, or by internal extraction sites.",
        "Extraposition phenomena, gapping constructions in coordinate structures, and the distribution of adverbials offer other problematic examples of English discontinuous constructions for which this first-order framework seems to promise well.",
        "A much larger batch of similar phenomena is offered by languages with freer word order than English, for which, as pointed out in [5, 18], classical CG suffers from an even clearer lack of expressive power.",
        "Indeed, Joshi [4] proposes within the TAG framework an attractive general solution to word-order variations phenomena in terms of linear precedence relations among constituents.",
        "Such a solution suggests a similar approach for further work to be pursued within the framework presented here."
      ]
    },
    {
      "heading": "4 Theorem Proving",
      "text": [
        "In propositional CG, the problem of determining the type of a string from the types of its words has been addressed either by defining certain \"combinatory\" rules which then determine a rewrite relation between sequences of types, or by viewing the type of a string as a logical consequence of the types of its words.",
        "The first alternative has been explored mainly in Combinatory Grammar [16, 17], where, beside the rewrite rule of functional application, which was already in the initial formulation of CG in [1], there are also the rules of functional composition and type raising, which are used to account for extraction and coordination phenomena.",
        "This approach offers a psychologically attractive model of parsing, based on the idea of incremental processing, but causes \"spurious ambiguity\", that is, an almost exponential proliferation of the possible derivation paths for identical analyses of a given string.",
        "In fact, although a rule like functional composition is specifically needed for cases of extraction and coordination, in principle nothing prevents its use to analyze strings not characterized by such phenomena, which would be analyzable in terms of functional application alone.",
        "Tentative solutions of this problem have been recently discussed in [12, 19].",
        "The second alternative has been undertaken in the late fifties by Lambek [6] who defined a decision procedure for bidirectional propositional CG in terms of a Gentzen-style sequent system.",
        "Lam-bek's implicational calculus of syntactic types has recently enjoyed renewed interest in the works of van Benthem, Moortgat and other scholars.",
        "This approach can account for a range of syntactic phenomena similar to that of Combinatory Grammar, and in fact many of the rewrite rules of Combinatory Grammar can be derived as theorems in the calculus.",
        "However, analyses of cases of extraction and coordination are here obtained via inferences over the internal implications in the types of higher-order functions.",
        "Thus, extraction and coordination can be handled in an expectation-driven fashion, and, as a consequence, there is no problem of spuriously ambiguous derivations.",
        "Our approach here is close in spirit to Lambek's enterprise, since we also make use of a Gentzen system capable of handling the internal implications in the types of higher-order functions, but at the same time differs radically from it, since we do not need to have a \"specialized\" propositional logic, with directional connectives and adjacency requirements.",
        "Indeed, the expressive power of standard first-order logic completely eliminates the need for this kind of specialization, and at the same time provides the ability to account for constructions which, as shown in section 3.3.1, are problematic for an (albeit specialized) propositional framework."
      ]
    },
    {
      "heading": "4.1 An Intuitionistic Extension of Prolog",
      "text": [
        "The inference system we are going to introduce below has been proposed in [7] as an extension of Prolog suitable for modular logic programming.",
        "A similar extension has been proposed in [3] to implement hypotethical reasoning in logic programming.",
        "We are thus dealing with what can be considered the specification of a general purpose logic programming language.",
        "The encoding of a particular linguistic formalism is but one other application of such a language, which Miller [7] shows to be sound and complete for intuitionistic logic, and to have a well defined semantics in terms of",
        "Kripke models.",
        "We take a logic program or, simply, a program",
        "P to be any set of definite clauses.",
        "We formally represent the fact that a goal clause G is logically derivable from a program P with a sequetat of the form P G, where P and G are, respectively, the antecedent and the succedent of the sequent.",
        "If P is a program then we take its substitution closure [P] to be the smallest set such that • P C [7:1 • if D1 A D2 E pi then DIE VI and D2 E • if VxD E [2] then [xlt]D E [P) for all terms I,",
        "where [zit] denotes the result of substituting I for free occurrences of t in D",
        "We introduce now the following proof rules, which define the notion of proof for our logic programming language:",
        "In the inference figures for rules (II) - (V), the sequent(s) appearing above the horizontal line are the upper seguent(s), while the sequent appearing below is the lower seguent.",
        "A proof for a sequent P G is a tree whose nodes are labeled with sequents such that (i) the root node is labeled with P G, (ii) the internal nodes are instances of one of proof rules (II) - (V) and (iii) the leaf nodes are labeled with sequents representing proof rule (I).",
        "The height of a proof is the length of the longest path from the root to some leaf.",
        "The size of a proof is the number of nodes in it.",
        "Thus, proof rules (I)-(V) provide the abstract specification of a first-order theorem prover which can then be implemented in terms of depth-first search, backtracking and unification like a Prolog interpreter.",
        "(An example of such an implementation, as a metainterpreter on top of Lambda-Prolog, is given in [9].)",
        "Observe however that an important difference of such a theorem prover from a standard Prolog interpreter is in the wider distribution of \"logical\" variables, which, in the logic programming tradition, stand for existentially quantified variables within goals.",
        "Such variables can get instantiated in the course of a Prolog proof, thus providing the procedural ability to return specific values as output of the computation.",
        "Logical variables play the same role in the programming language we are considering here; moreover, they can also occur in program clauses, since subformulae of goal clauses can be added to programs via proof rule (V)."
      ]
    },
    {
      "heading": "4.2 How Strings Define Programs",
      "text": [
        "Let a be a string al ... an of words from a lexicon L. Then a defines a program Pa = such that",
        "• ra = {CONN(ai, i – 1, i) I 1 < i < n} • Ac, = {Dlai:D ELandl<i<n}",
        "Thus, ra just contains ground atoms encoding the position of words in a. Aa contains instead all the types assigned in the lexicon to words in a.",
        "We assume arithmetic operators for addition, subtraction, multiplication and integer division, and we assume that any program Pa works together with an infinite set of axioms A defining the comparison predicates over ground arithmetic expressions <, <, >, >.",
        "(Prolog's evaluation mechanism treats arithmetic expressions in a similar way.)",
        "Then, under this approach a string a is of type Ga if and only if there is a proof for the sequent Pal.JA Gc, according to rules (I) - (V)."
      ]
    },
    {
      "heading": "4.3 An Example",
      "text": [
        "We give here an example of a proof which determines a corresponding type-assignment.",
        "Consider the string whom John loves Such a sentence determines a program P with the following set 1' of ground atoms:",
        "We assume lexical type assignments such that the remaining set of clauses A is as follows:",
        "The clause assigned to the relative pronoun whom corresponds to the type of a higher-order function, and contains an implication in its body.",
        "Figure 1 shows a proof tree for such a type-assignment.",
        "The tree, which is represented as growing up from its root, has size 11, and height 8."
      ]
    },
    {
      "heading": "5 Structural Rules",
      "text": [
        "We now briefly examine the interaction of structural rules with parsing.",
        "In intuitionistic sequent systems, structural rules define ways of subtracting, adding, and reordering hypotheses in sequents during proofs.",
        "We have the three following structural rules:",
        "• Interchange, which allows to use hypotheses in any order • Contraction, which allows to use a hypothesis more than once • Thinning, which says that not all hypotheses need to be used"
      ]
    },
    {
      "heading": "5.1 Programs as Unordered Sets of Hypotheses",
      "text": [
        "All of the structural rules above are implicit in proof rules (I)-(V), and they are all needed to obtain intuitionistic soundness and completeness as in [7].",
        "By contrast, Lambek's propositional calculus does not have any of the structural rules; for instance, Interchange is not admitted, since the hypotheses deriving the type of a given string must also account for the positions of the words to which they have been assigned as types, and must obey the strict string adjacency requirement between functions and arguments of classical CG.",
        "Thus, Lambek's calculus must assume ordered lists of hypotheses, so as to account for word-order constraints.",
        "Under our approach, word-order constraints are obtained declaratively, via sharing of string positions, and there is no strict adjacency requirement.",
        "In proof-theoretical terms, this directly translates in viewing programs as unordered sets of hypotheses."
      ]
    },
    {
      "heading": "5.2 Trading Contraction against Decidability",
      "text": [
        "The logic defined by rules (I)-(V) is in general undecidable, but it becomes decidable as soon as Contraction is disallowed.",
        "In fact, if a given hypothesis can be used at most once, then clearly the number of internal nodes in a proof tree for a sequent P G is at most equal to the total number of occurrences of A and 3 in P G, since these are the logical constants for which proof rules with corresponding inference figures have been defined.",
        "Hence, no proof tree can contain infinite branches and decidability follows.",
        "Now, it seems a plausible conjecture that the programs directly defined by input strings as in Section 4.2 never need Contraction.",
        "In fact, each time we use a hypothesis in the proof, either we consume a corresponding word in the input string, or we consume a \"virtual\" constituent corresponding to a step of hypothesis introduction determined by rule (V) for implications.",
        "(Constructions like parasitic gaps can be accounted for by associating specific lexical items with clauses which determine the simultaneous introduction of gaps of the same type.)",
        "If this conjecture can be formally confirmed, then we could automate our formalism via a metainterpreter based on rules (I)-(V), but implemented in such a way that clauses are removed from programs as soon as they are used.",
        "Being based on a decidable fragment of logic, such a metainterpreter would not be affected by the kind of infinite loops normally characterizing DCG parsing."
      ]
    },
    {
      "heading": "5.3 Thinning and Vacuous Abstraction",
      "text": [
        "Thinning can cause problems of overgeneration, as hypotheses introduced via rule (V) may end up as being never used, since other hypotheses can be used instead.",
        "For instance, the type assignment",
        "REL(v – 1 , w) can be used to account for the well-formedness of both which [ I shall put a book on and which [ I shall put on the table ] but will also accept the ungrammatical which [ I shall put a book on the table ] In fact, as we do not have to use all the hypotheses, in this last case the virtual noun-phrase corresponding to the extraction site is added to the program but is never used.",
        "Notice that our conjecture in section 4.4.2 was that Contraction is not needed to prove the theorems corresponding to the types of grammatical strings; by contrast, Thinning givcs us more theorems than we want.",
        "As a consequence, eliminating Thinning would compromise the proof-theoretic properties of (I)-(V) with respect to intuitionistic logic, and the corresponding Kripke models semantics of our programming language.",
        "There is however a formally well defined way to account for the ungrammaticality of the example above without changing the logical properties of our inference system.",
        "We can encode proofs as terms of Lambda Calculus and then filter certain kinds of proof terms.",
        "In particular, a hypothesis introduction, determined by rule (V), corresponds to a step of )-abstraction, while a hypothesis elimination, determined by one of rules (I)-(II), corresponds to a step of functional application and .\\-contraction.",
        "Hypotheses which are introduced but never eliminated result in corresponding cases of vacuous abstraction.",
        "Thus, the three examples above have the three following Lambda encodings of the proof of the sentence for which an extraction site is hypothesized, where the last ungrammatical example corresponds to a case of vacuous abstraction:",
        "• Ax putaa book], [on x], I) • Ax put(x, [on the table], I) • Ax putaa book], [on the table], I)",
        "Constraints for filtering proof terms characterized by vacuous abstraction can be defined in a straightforward manner, particularly if we are working with a metainterpreter implemented on top of a language based on Lambda terms, such as Lambda-Prolog [8, 9].",
        "Beside the desire to maintain certain well defined proof-theoretic and semantic properties of our inference system, there are other reasons for using this strategy instead of disallowing Thinning.",
        "Indeed, our target here seems specifically to be the elimination of vacuous Lambda abstraction.",
        "Absence of vacuous abstraction has been proposed by Steedman [17] as a universal property of human languages.",
        "Morrill and Carpenter [11] show that other well-formedness constraints formulated in different grammatical theories such as GPSG, LFG and GB reduce to this same property.",
        "Moreover, Thinning gives us a straightforward way to account for situations of lexical ambiguity, where the program defined by a certain input string can in fact contain hypotheses which are not needed to derive the type of the string."
      ]
    }
  ]
}
