{
  "info": {
    "authors": [
      "Mehryar Mohri",
      "Richard W. Sproat"
    ],
    "book": "Annual Meeting of the Association for Computational Linguistics",
    "id": "acl-P96-1031",
    "title": "An Efficient Compiler for Weighted Rewrite Rules",
    "url": "https://aclweb.org/anthology/P96-1031",
    "year": 1996
  },
  "references": [
    "acl-H94-1050",
    "acl-J94-3001",
    "acl-J94-3002",
    "acl-P94-1028",
    "acl-P95-1003"
  ],
  "sections": [
    {
      "heading": "Abstract",
      "text": [
        "Context-dependent rewrite rules are used in many areas of natural language and speech processing.",
        "Work in computational phonology has demonstrated that, given certain conditions, such rewrite rules can be represented as finite-state transducers (FSTs).",
        "We describe a new algorithm for compiling rewrite rules into FSTs.",
        "We show the algorithm to be simpler and more efficient than existing algorithms.",
        "Further, many of our applications demand the ability to compile weighted rules into weighted FSTs, transducers generalized by providing transitions with weights.",
        "We have extended the algorithm to allow for this."
      ]
    },
    {
      "heading": "1. Motivation",
      "text": [
        "Rewrite rules are used in many areas of natural language and speech processing, including syntax, morphology, and phonology'.",
        "In interesting applications, the number of rules can be very large.",
        "It is then crucial to give a representation of these rules that leads to efficient programs.",
        "Finite-state transducers provide just such a compact representation (Mohri, 1994).",
        "They are used in various areas of natural language and speech processing because their increased computational power enables one to build very large machines to model interestingly complex linguistic phenomena.",
        "They also allow algebraic operations such as union, composition, and projection which are very useful in practice (Berstel, 1979; Eilen-berg, 1974 1976).",
        "And, as originally shown by Johnson (1972), rewrite rules can be modeled as 'Parallel rewrite rules also have interesting applications in biology.",
        "In addition to their formal language theory interest, systems such as those of Aristid Lin-denmayer provide rich mathematical models for biological development (Rozenberg and Salomaa, 1980).",
        "finite-state transducers, under the condition that no rule be allowed to apply any more than a finite number of times to its own output.",
        "Kaplan and Kay (1994), or equivalently Kart-tunen (1995), provide an algorithm for compiling rewrite rules into finite-state transducers, under the condition that they do not rewrite their non-contextual part2.",
        "We here present a new algorithm for compiling such rewrite rules which is both simpler to understand and implement, and computationally more efficient.",
        "Clarity is important since, as pointed out by Kaplan and Kay (1994), the representation of rewrite rules by finite-state transducers involves many subtleties.",
        "Time and space efficiency of the compilation are also crucial.",
        "Using naive algorithms can be very time consuming and lead to very large machines (Liberman, 1994).",
        "In some applications such as those related to speech processing, one needs to use weighted rewrite rules, namely rewrite rules to which weights are associated.",
        "These weights are then used at the final stage of applications to output the most probable analysis.",
        "Weighted rewrite rules can be compiled into weighted finite-state transducers, namely transducers generalized by providing transitions with a weighted output, under the same context condition.",
        "These transducers are very useful in speech processing (Pereira et al., 1994).",
        "We briefly describe how we have augmented our algorithm to handle the compilation of weighted rules into weighted finite-state transducers.",
        "In order to set the stage for our own contribution, we start by reviewing salient aspects of the Kaplan and Kay algorithm."
      ]
    },
    {
      "heading": "2. The KK Algorithm",
      "text": [
        "The rewrite rules we consider here have the following general form:",
        "Such rules can be interpreted in the following way: 0 is to be replaced by whenever it is preceded by A and followed by p. Thus, A and p represent the left and right contexts of application of the rules.",
        "In general, 0, 0, A and p are all regular expressions over the alphabet of the rules.",
        "Several types of rules can be considered depending on their being obligatory or optional, and on their direction of application, from left to right, right to left or simultaneous application.",
        "Consider an obligatory rewrite rule of the form ik /A p, which we will assume applies left to right across the input string.",
        "Compilation of this rule in the algorithm of Kaplan and Kay (1994) (KK for short) involves composing together six transducers, see Figure 1.",
        "We use the notations of KK.",
        "In particular, E denotes the alphabet, < denotes the set of context labeled brackets {<a, <i, <c}, > the set {>a, >i, >c}, and 0 an additional character representing deleted material.",
        "Subscript symbols of an expression are symbols which are allowed to freely appear anywhere in the strings represented by that expression.",
        "Given a regular expression r, Id(r) is the identity transducer obtained from an automaton A representing r by adding output labels to A identical to its input labels.",
        "The first transducer, Prologue, freely introduces labeled brackets from the set {< a , >a, >, >,} which are used by left and right context transducers.",
        "The last transducer, Prologue-1, erases all such brackets.",
        "In such a short space, we can of course not hope to do justice to the KK algorithm, and the reader who is not familiar with it is urged to consult their paper.",
        "However, one point that we do need to stress is the following: while the construction of Prologue, Prologue-1 and Replace is fairly direct, construction of the other transducers is more complex, with each being derived via the application of several levels of regular operations from the original expressions in the rules.",
        "This clearly appears from the explicit expressions we have indicated for the transducers.",
        "The construction of the three other transducers involves many operations including: two intersections of automata, two distinct subtractions, and nine complementations.",
        "Each subtraction involves an intersection and a complementation algorithm3.",
        "So, in the whole, four intersections and eleven complementations need to be performed.",
        "Intersection and complementation are classical automata algorithms (Aho et al., 1974; Aho et al., 1986).",
        "The complexity of intersection is quadratic.",
        "But the classical complementation algorithm requires the input automaton to be deterministic.",
        "Thus, each of these 11 operations requires first the determinization of the input.",
        "Such operations can be very costly in the case of the automata involved in the KK algorithm4.",
        "In the following section we briefly describe a new algorithm for compiling rewrite rules.",
        "For reasons of space, we concentrate here on the compilation of left-to-right obligatory rewrite rules.",
        "However, our methods extend straightforwardly to other modes of application (optional, right-to-left, simultaneous, batch), or kinds of rules (two-level rules) discussed by Kaplan and Kay (1994).",
        "3A subtraction can of course also be performed directly by combining the two steps of intersection and complementation, but the corresponding algorithm has exactly the same cost as the total cost of the two operations performed consecutively.",
        "40ne could hope to find a more efficient way of determining the complement of an automaton that would not require determinization.",
        "However, this problem is PSPACE-complete.",
        "Indeed, the regular expression non-universality problem is a subproblem of complementation known to be PSPACE-complete (Garey and Johnson, 1979, page 174), (Stockmeyer and Meyer, 1973).",
        "This problem also known as the emptiness of complement problem has been extensively studied (Aho et al., 1974, page 410-419)."
      ]
    },
    {
      "heading": "3. New Algorithm",
      "text": []
    },
    {
      "heading": "3.1. Overview",
      "text": [
        "In contrast to the KK algorithm which introduces brackets everywhere only to restrict their occurrence subsequently, our algorithm introduces context symbols just when and where they are needed.",
        "Furthermore, the number of intermediate transducers necessary in the construction of the rules is smaller than in the KK algorithm, and each of the transducers can be constructed more directly and efficiently from the primitive expressions of the rule, 0, 'kb, A, p. A transducer corresponding to the left-to-right obligatory rule 0 0/A p can be obtained by composition of five transducers:",
        "r of o replace o o 12 (3) 1.",
        "The transducer r introduces in a string a marker > before every instance of p. For reasons that will become clear we will notate this as E*p E* > p. 2.",
        "The transducer f introduces markers <1 and <2 before each instance of 0 that is followed by >: (E U {>})* >--* U {>})*{<1, <2 }0 >.",
        "In other words, this transducer Marks just those 0 that occur before p. 3.",
        "The replacement transducer replace replaces 0 with tp in the context <1 >, simultaneously deleting > in all positions (Figure 2).",
        "Since >, <1, and <2 need to be ignored when determining an occurrence of 0, there are loops over the transitions >: c, <1: c, <2: at all states of 0, or equivalently of the states of the cross product transducer 0 x 0.",
        "4.",
        "The transducer 11 admits only those strings in which occurrences of <1 are preceded by A and deletes <1 at such occurrences: E*A E*A.",
        "5.",
        "The transducer 12 admits only those strings in which occurrences of <2 are not preceded by .\\ and deletes <2 at such occurrences: E*A <2--+ E*A.",
        "Clearly the composition of these transducers leads to the desired result.",
        "The construction of the transducer replace is straightforward.",
        "In the following, we show that the construction of the other four transducers is also very simple, and that it only requires the determinization of 3 automata and additional work linear (time and space) in the size of the determinized automata."
      ]
    },
    {
      "heading": "3.2. Markers Markers of TYPE I",
      "text": [
        "Let us start by considering the problem of constructing what we shall call a TYPE 1 transducer,",
        "which inserts a marker after all prefixes of a string that match a particular regular expression.",
        "Given a regular expression (3 defined on the alphabet E, one can construct, using classical algorithms (Aho et al., 1986), a deterministic automaton a representing E*fl.",
        "As with the KK algorithm, one can obtain from a a transducer x = Id(a) simply by assigning to each transition the same output label as the input label.",
        "We can easily transform x into a new transducer r such that it inserts an arbitrary marker # after each occurrence of a pattern described by #.",
        "To do so, we make final the non-final states of x and for any final state q of x we create a new state q', a copy of q.",
        "Thus, q' has the same transitions as q, and q' is a final state.",
        "We then make q non-final, remove the transitions leaving q and add a transition from q to q' with input label the empty word c, and output #.",
        "Figures 3 and 4 illustrate the transformation of x into",
        "Proposition 1 Let a be a deterministic automaton representing E.,3, then the transducer 7 obtaMed as described above is a transducer postmarking occurrences of /3 in a string of E* by #.",
        "Proof.",
        "The proof is based on the observation that a deterministic automaton representing E*P' is necessarily complete'.",
        "Notice that non-deterministic automata representing E*13 are not necessarily complete.",
        "Let q be a state of a and let u E E* be a string reaching q6.",
        "Let v be a string described by the regular expression )1.",
        "Then, for any a E E, uav is in E*P. Hence, uav is accepted by the automaton a, and, since a is deterministic, there exists a transition labeled with a leaving q.",
        "Thus, one can read any string u E E* using the automaton a.",
        "Since by definition of a, the state reached when reading a prefix u' of u is final if U' E E*P, by construction, the transducer 7 inserts the symbol # after the prefix u' if tz' ends with a pattern of fl.",
        "This ends the proof of the proposition.",
        "0 Markers of TYPE 2 In some cases, one wishes to check that any occurrence of # in a string s is preceded (or followed) by an occurrence of a pattern of P. We shall say that the corresponding transducers are of TYPE 2.",
        "They play the role of a filter.",
        "Here again, they can be defined from a deterministic automaton representing E*T3.",
        "Figure 5 illustrates the modifications to make from the automaton of figure 3.",
        "The symbols # should only appear at final states and must be erased.",
        "The loop # : c added at final states of Id(a) is enough for that purpose.",
        "All states of the transducer are then made final since any string conforming to this restriction is acceptable: cf. the transducer /1 for A above.",
        "Markers of TYPE 3 In other cases, one wishes to check the reverse constraint, that is that occurrences of # in the string s are not preceded (or followed) by any occurrence of a pattern of p. The transformation then simply consists of adding a loop at each non-final state of Id(a), and of making all states final.",
        "Thus, a state such as that of figure 6 is trans",
        "The construction of these transducers (TYPE 1-3) can be generalized in various ways.",
        "In particular:",
        "• One can add several alternative markers {#1, • • , #k} after each occurrence of a pattern of P in a string.",
        "The result is then an automaton with transitions labeled with, for instance, #1, • • • , #k after each pattern of /3: cf. transducer f for 0 above.",
        "• Instead of inserting a symbol, one can delete a symbol which would be necessarily present after each occurrence of a pattern of [3.",
        "For any regular expression a, define M arker(a ,type, deletions, insertions) as the transducer of type type constructed as previously described from a deterministic automaton representing a, insertions and deletions being, respectively, the set of insertions and deletions the transducer makes.",
        "Proof.",
        "We proved in the previous proposition that the modifications do indeed lead to the desired transducer for TYPE 1.",
        "The proof for other cases is similar.",
        "That the construction is linear in space is clear since at most one additional transition and state is created for final or non-final states7.",
        "The overall time complexity of the construction is linear, since the construction of Id(a) is linear in the /For TYPE 2 and TYPE 3, no state is added but only a transition per final or non-final state.",
        "number of transitions of a and that other modifications consisting of adding new states and transitions and making states final or not are also linear.",
        "0 We just showed that M arker(a,type,deletions, insertions) can be constructed in a very efficient way.",
        "Figure 7 gives the expressions of the four transducers r, f, /1, and 12 using Marker.",
        "Thus, these transducers can be constructed very efficiently from deterministic automata repre-senting' E*reverse(p), (EU {>})* reverse(0> >), and E*A.",
        "The construction of r and f requires two reverse operations.",
        "This is because these two transducers insert material before p or cb."
      ]
    },
    {
      "heading": "4. Extension to Weighted Rules",
      "text": [
        "In many applications, in particular in areas related to speech, one wishes not only to give all possible analyses of some input, but also to give some measure of how likely each of the analyses is.",
        "One can then generalize replacements by considering extended regular expressions, namely, using the terminology of formal language theory, rational power series (Berstel and Reutenauer, 1988; Salomaa and Soittola, 1978).",
        "The rational power series we consider here are functions mapping E* to R4.",
        "U {00} which can be described by regular expressions over the alphabet (74 U loop x E. S = (4a)(2b)*(3b) is an example of rational power series.",
        "It defines a function in the following way: it associates a non-null number only with the strings recognized by the regular expression ab* b.",
        "This number is obtained by adding the coefficients involved in the recognition of the string.",
        "The value associated with abbb, for instance, is (S, abbb) = 4 + 2 + 2 + 3 = 11.",
        "In general, such extended regular expressions can be redundant.",
        "Some strings can be matched 8 As in the KK algorithm we denote by 0> the set of the strings described by containing possibly occurrences of > at any position.",
        "In the same way, subscripts such as >:> for a transducer r indicate that loops by >:> are added at all states of r. We denote by reverse(a) the regular expression describing exactly the reverse strings of a if a is a regular expression, or the reverse transducer of a if a is a transducer.",
        "in different ways with distinct coefficients.",
        "The value associated with those strings is then the minimum of all possible results.",
        "S' = (2a)(3b)(4b) + (5a)(3b*) matches abb with the different weights 2 + 3 + 4 = 9 and 5 + 3 + 3 = 11.",
        "The minimum of the two is the value associated with abb: (S', abb) = 9.",
        "Non-negative numbers in the definition of these power series are often interpreted as the negative logarithm of probabilities.",
        "This explains our choice of the operations: addition of the weights along the string recognition and min, since we are only interested in that result which has the highest probability9.",
        "Rewrite rules can be generalized by letting ik be a rational power series.",
        "The result of the application of a generalized rule to a string is then a set of weighted strings which can be represented by a weighted automaton.",
        "Consider for instance the following rule, which states that an abstract nasal, denoted N, is rewritten as in in the context of a following labial:",
        "Now suppose that this is only probabilistically true, and that while ninety percent of the time N does indeed become in in this environment, about ten percent of the time in real speech it becomes n. Converting from probabilities to weights, one would say that N becomes in with weight = – log(0.9), and n with weight /6' = – log(0.1), in the stated environment.",
        "One could represent this by the following rule:",
        "We define Weighted finite-state transducers as transducers such that in addition to input and output labels, each transition is labeled with a weight.",
        "The result of the application of a weighted transducer to a string, or more generally to an automaton is a weighted automaton.",
        "The corresponding operation is similar to the unweighted case.",
        "However, the weight of the transducer and those of the string or automaton need to be combined too, here added, during composition (Pereira et al., 1994).",
        "We have generalized the composition operation to the weighted case by introducing this combination of weights.",
        "The algorithm we described in the previous sections can then also be used to compile weighted rewrite rules.",
        "As an example, the obligatory rule 9 can be represented by the weighted transducer of Figure 8 1°.",
        "The following theorem extends to the weighted case the assertion proved by Kaplan and Kay (1994).",
        "Proof.",
        "The construction we described in the previous section also provides a constructive proof of this theorem in the unweighted case.",
        "In case is a power series, one simply needs to use in that construction a weighted finite-state transducer representing O.",
        "By definition of composition of weighted transducers, or multiplication of power series, the weights are then used in a way consistent with the definition of the weighted context-dependent rules.",
        "0"
      ]
    },
    {
      "heading": "5. Experiments",
      "text": [
        "In order to compare the performance of the algorithm presented here with KK, we timed both algorithms on the compilation of individual rules taken from the following set (k E [0, 10]):",
        "10We here use the symbol to denote all letters different from b, m, n, p, and N. In other words we tested twenty two rules where the left context or the right context is varied in length from zero to ten occurrences of c. For our experiments, we used the alphabet of a realistic application, the text analyzer for the Bell Laboratories German text-to-speech system consisting of 194 labels.",
        "All tests were run on a Silicon Graphics IRIS Indigo 4000, 100 MhZ IP20 Processor, 128 Mbytes RAM, running IRIX 5.2.",
        "Figure 9 shows the relative performance of the two algorithms for the left context: apparently the performance of both algorithms is roughly linear in the length of the left context, but KK has a worse constant, due to the larger number of operations involved.",
        "Figure 10 shows the equivalent data for the right context.",
        "At first glance the data looks similar to that for the left context, until one notices that in Figure 10 we have plotted the time on a log scale: the KK algorithm is hyperexponential.",
        "What is the reason for this performance degradation in the right context?",
        "The culprits turn out to be the two intersectands in the expression of Rightcontext(p,<,>) in Figure 1.",
        "Consider for example the righthand intersectand, namely 0 > p>0E*>0 – > E, which is the complement of E> p>0E;0 – > E. As previously indicated, the complementation algorithm, requires determinization, and the determinization of automata representing expressions of the form E* a, where a is a regular expression, is often very expensive, specially when the expression a is already complex, as in this case.",
        "Figure 11 plots the behavior of determinization on the expression E> p>oE*>0 – > E*>o for each of the rules in the set a – > b Ck , (k E [0,10]).",
        "On the horizontal axis is the number of arcs of the non-deterministic input machine, and on the vertical axis the log of the number of arcs of the deterministic machine, i.e. the machine result of the determinization algorithm without using any minimization.",
        "The perfect linearity indicates an exponential time and space behavior, and this in turn explains the observed difference in performance.",
        "In contrast, the construction of the right context machine in our algorithm involves only the single determinization of the automaton representing E* p, and thus is much less expensive.",
        "The comparison just discussed involves a rather artificial ruleset, but the differences in performance that we have highlighted show up in real applications.",
        "Consider two sets of pronunciation rules from the Bell Laboratories German text-to-speech system: the size of the alphabet for this ruleset is 194, as noted above.",
        "The first ruleset, consisting of pronunciation rules for the orthographic vowel <O> contains twelve rules, and the second ruleset, which deals with the orthographic",
        "vowel <a> contains twenty five rules.",
        "In the actual application of the rule compiler to these rules, one compiles the individual rules in each ruleset one by one, and composes them together in the order written, compacts them after each composition, and derives a single transducer for each set.",
        "When done off-line, these operations of compo",
        "sition and compaction dominate the time corresponding to the construction of the transducer for each individual rule.",
        "The difference between the two algorithms appears still clearly for these two sets of rules.",
        "Table 1 shows for each algorithm the times in seconds for the overall construction, and the number of states and arcs of the output transducers."
      ]
    },
    {
      "heading": "6. Conclusion",
      "text": [
        "We briefly described a new algorithm for compiling context-dependent rewrite rules into finite-state transducers.",
        "Several additional methods can be used to make this algorithm even more efficient.",
        "The automata determinizations needed for this algorithm are of a specific type.",
        "They represent expressions of the type E*0 where cb is a regular expression.",
        "Given a deterministic automaton representing 0, such determinizations can be performed in a more efficient way using failure functions (Mohri, 1995).",
        "Moreover, the corresponding determinization is independent of E which can be very large in some applications.",
        "It only depends on the alphabet of the automaton representing 0.",
        "One can devise an on-the-fly implementation of the composition algorithm leading to the final transducer representing a rule.",
        "Only the necessary part of the intermediate transducers is then expanded for a given input (Pereira et al., 1994).",
        "The resulting transducer representing a rule is often subsequentiable or p-subsequentiable.",
        "It can then be determinized and minimized (Mohri, 1994).",
        "This both makes the use of the transducer time efficient and reduces its size.",
        "We also indicated an extension of the theory of rule-compilation to the case of weighted rules, which compile into weighted finite-state transducers.",
        "Many algorithms used in the finite-state theory and in their applications to natural language processing can be extended in the same way.",
        "To date the main serious application of this compiler has been to developing text-analyzers for text-to-speech systems at Bell Laboratories (Sproat, 1996): partial to more-or-less complete analyzers have been built for Spanish, Italian, French, Romanian, German, Russian, Mandarin and Japanese.",
        "However, we hope to also be able to use the compiler in serious applications in speech",
        "deterministic automaton r representing PS = E>o > P>0E;0 – > E*;0 versus the log of the number of arcs in the automaton obtained by determinization of T. recognition in the future."
      ]
    },
    {
      "heading": "Acknowledgements",
      "text": [
        "We wish to thank several colleagues of AT&T/Bell Labs, in particular Fernando Pereira and Michael Riley for stimulating discussions about this work and Bernd MObius for providing the German pronunciation rules cited herein."
      ]
    }
  ]
}
