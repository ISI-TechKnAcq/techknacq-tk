{
  "info": {
    "authors": [
      "Ewan Klein"
    ],
    "book": "International Conference on Computational Linguistics",
    "id": "acl-C92-1026",
    "title": "Data Types in Computational Phonology",
    "url": "https://aclweb.org/anthology/C92-1026",
    "year": 1992
  },
  "references": [
    "acl-C88-1009",
    "acl-P86-1038",
    "acl-P87-1013"
  ],
  "sections": [
    {
      "heading": "ABSTRACT",
      "text": [
        "This paper examines certain aspects of phonological structure from the viewpoint of abstract data types.",
        "Our immediate goal is to find a format for phonological representation which will be reasonably faithful to the concerns of theoretical phonology while being rigorous enough to admit a computational interpretation.",
        "The longer term goal is to incorporate such representations into an appropriate general framework for natural language processing.",
        "I"
      ]
    },
    {
      "heading": "Introduction",
      "text": [
        "One of the dominant paradigms in current cont-putational linguistics is provided by unification-based grammar formalisms.",
        "Such formalisms (cf. (Shieber 1986; Kasper k Rounds 1986)) describe hierarchical feature structures, which in many ways would appear to be an ideal setting for formal phonological analyses.",
        "Feature bundles have long been used by phonologists, and more recent work on so-called feature geometry (e.g. (Clements 1985; Sagey 1986)) has introduced hierarchy into such representations.",
        "Nevertheless.",
        "there are reasons to step back from standard feature-based approaches, and instead to adopt the algebraic perspective of abstract data types (A DT) which has been widely adopted in computer science.",
        "One general motivation.",
        "which we shall not explore here, is that the activity of grammar writing, viewed as a process of programme specification.",
        "should be amenable to qinwise refinement in which the set of (not necessarily isomorphic) models admitted by a loose 'The work reported in this paper has Mon carried out as part of the research progrimmies of the Human Communication Research Centre.",
        "supported by the tr8 Economic and Social Research Council and the project Computational Phonology: A Constraini 0.4(4 Approach, funded by the tt E Science and Engineering Research Council, under grant (111/(i-22981.",
        "I am grateful to Steven Bird, Khnba Newton and Tone Simon for di, missions relating to this work.",
        "specification is gradually narrowed down to a unique algebra (cf. (Sannella Tarlecki 1987) for an overview, and (Newton in prep.)",
        "for the application to grammar writing).",
        "A second motivation, discussed in detail by (Beierle & Pletat 1988; Beierle & Pletat 1989; Beierle et al.",
        "1988), is to use equational A ITS to provide a mathematical foundation for feature structures.",
        "A third motivation, dominant in this paper, is to use the A DT approach to provide a richer array of explicit.",
        "data types than are readily admitted by :pure' feature structure approaches.",
        "Briefly, in their raw form, feature terms (i.e., formalisms for describing feature structures) do not always provide a perspicuous format for representing structure.",
        "On the A DT approach, complex data types are built up front atomic types by means of constructor functions.",
        "For example, _._ (where we use the underscore to mark the position of the function's arguments) creates elements of type List.",
        "A data type may also have selector functions for taking data elements apart.",
        "Thus, selectors for the type List are the functions first and last.",
        "Standard feature-based encoding of lists uses only selectors for the data type; i.e. the feature labels FIRST and LAST ill",
        "(1) FIRST : : (FIRST : a2 LAST : nil)",
        "However.",
        "the list constructor is left implicit.",
        "That is, the feature term encoding tells you how lists are pulled apart, but does not say how they are built up.",
        "When we confine our attention just to lists, this is not much to worry about.",
        "However, the situation becomes less satisfactory when we attempt to encode a larger variety of data structures into one and the same feature term; say, for example, standard lists, associative lists (i.e. strings), constituent.",
        "structure hierarchy, and am tosegmental association.",
        "In order to distinguish adequately between elements of such data types, we really need to know the logical properties of t heir respective constructors, and this is awk-Acne ward when the constructors are not made explicit.",
        "For computational phonology, it is not an unlikely scenario to be confronted with such a variety of data structures, since one may well wish to study the complex interaction between, say, non-linear temporal relations and prosodic hierarchy.",
        "As a vehicle for computational implementation, the uniformity of standard attribute/value notation is extremely useful.",
        "As a vehicle for theory development, it can be extraordinarily unperspicuous.",
        "The approach which we present here treats phonological concepts as abstract data, types.",
        "A particularly convenient development environment is provided by the language 0113 (Goguen S.7 Winkler 1988), which is based on order sorted equational logic, and all the examples given below (except where explicitly indicated to the contrary) run in the version of 01313 released by SIP in 1988.",
        "The &notational semantics of an 011.1 module is an algebra, while its operational semantics is based on order sorted rewriting.",
        "§ 1.1 and 1.2 give a more detailed introduction into the formal framework, while § 2 and 3 illustrate the approach with some phonological examples."
      ]
    },
    {
      "heading": "1.1 Abstract Data Types",
      "text": [
        "A data type consists of one or more domains of data items, of which certain elements me designated as basic, together with a set of operations on the domains which suffice to generate all data items in the domains from the basic items.",
        "A data type is abstract if it is independent of any particular representational scheme.",
        "A fundamental claim of the ADJ group (cf. (Goguen.",
        "Thatcher k Wagner 1976)) and much subsequent work (cf. (Ehrig Mahr 1985)) is that abstract data types are (to he modelled as) algebras: and moreover, that the models of abstract data types are initial algebras.",
        "The signature of a many-sorted algebra is a pair E = (8,0) consisting of a set S of sorts and a set 0 of constant and operation symbols.",
        "A specification is a pair (E,E) consisting of a signature together with a set e of equations over terms constructed from symbols in 0 and variables of the sorts in S. A model for a specification is 'An initial algebra is characterized uniquely up to isomorphism as the semantics of a specification: there is a unique homomorphism from the initial algebra into every algebra of the specification.",
        "an algebra over the signature which satisfies all the equations E. Initial algebras play a special role as the semantics of an algebra.",
        "An initial algebra is minimal.",
        "in the sense expressed by the principles 'DO junk' and 'no confusion'.",
        "'No junk' means that the algebra only contains data which are denoted by variable-free terms built up from operation symbols in the signature.",
        "'No confu-sion' means that two such terms t and tl denote the same object in the algebra only if the equation t = is derivable from the equations of the specification.",
        "Specifications are written in a conventional format consisting of a declaration of sorts, operation symbols (op), and equations (eq).",
        "Preceding the equations we list all the variables (var) which figure in them.",
        "As an illustration, we give below an 013.1 specification of the data type LIST1.",
        "eq head(X = X .",
        "eq tail(X .",
        "L) = L endo The sort list between the : and the -> in an operation declaration is called the arity of the operation.",
        "while the sort after the -> is its value sort.",
        "Together.",
        "the arity and value sort constitute the rank of all operation.",
        "The declaration op nil : -> Elt means that nil is a constant of sort Elt.",
        "The specification (2) fails to guarantee that there are any objects of Elt.",
        "While we could of course add some constants of this sort, we would like to have a more general solution.",
        "In a particular application.",
        "we might want to define phonological words as a List of syllables (plus other constraints, of course).",
        "and phonological phrases as a List of words.",
        "That is, we need to parameterize the type LIST1 with respect to the class of elements which constitute the lists.",
        "Before turning to parameterization, we will first see how a many-sorted specification language is generalized to an order sorted language by introducing a snbsort relation.",
        "Suppose, for example, that we adopt the claim that all syllables have C I. onsets'.",
        ",Vloreover.",
        "we wish to divide syllables into the subclasses heavy and light.",
        "Obviously we want heavy and light syllables to inherit, the properties of the class of all syllables, e.g., they have ('1 onsets.",
        "We use Heavy < Syll to state that Heavy is a subsoil of the sort Syll.",
        "We interpret this to mean that the class of heavy syllables is a subset of the class of all syllables.",
        "Now, let onset_ : Syll -> Mora be an operation which selects the first 'flora of a syllable, and let us impose the following constraint (where Cv is a subsort of Mora):",
        "(3) var S : Syll .",
        "var CV : Cv .",
        "eq onset S = CV .",
        "Then the framework of order sorted algebra ensures that onset is also defined for objects of sort Heavy.",
        "Returning to lists, the specification in (.1) (slightly simplified from that used by (Ooguen Winklor 1988)) introduces Elt and NeList(mom-ern ply lists) as subsorts of List.",
        "and thereby improves on LIST1 in a number of respects.",
        "In addition.",
        "the specification is parameterized.",
        "That is.",
        "it characterizes a list of Xs, where the parameter X can be instantiated to any module which satisfies the condition TRIV; the latter is What (Goguen ,r Winkler 1988) call a 'requirement theory.. and in this case simply imposes on any input module that it have a sort which can be mapped to tho sort.",
        "Elt.",
        "(4) obj LIST[X TRIV] is sorts List NeList subsorts Elt < NeList < List .",
        "Notice that the list constructor _._ now performs the additional function of oppc\"nd.",
        "allowing two lists to be concatenated.",
        "In addition.",
        "the selectors have been made 'safe'.",
        "in the sense that they only apply to objects (i.e.. nonempty lists) for which they give sensible results: for what.",
        "is LIST1, would have been the meaning of head(nil)°.",
        "'Here.",
        "the term ONSET refers to the inital 'lima of a syllable in Ilyman's (1981) version of the moraa Iteort"
      ]
    },
    {
      "heading": "2 Metrical Trees",
      "text": [
        "As a further illustration, we give below a specification of the data type BINTREE.",
        "This module has two parameters, both of whose requirement theories are TRIV.4",
        "(5) obj BINTREE[NONTERM TERM :: TRIV] is sorts Tree Netree .",
        "subsorts Elt.TERM Netree < Tree .",
        "op : Elt.NONTERM Tree Tree -> Netree .",
        "op _[_] : Elt.NONTERM Elt.TERM -> Tree .",
        "op label_ : Tree -> Elt.NONTERM op left_ : Netree -> Tree .",
        "op right_ : Netree -> Tree .",
        "vars El E2 : Tree .",
        "vars A : Elt.NONTERM eq label (A [ El , E2 = A eq label (A [ El ]) = A .",
        "eq left (A El , E2 ]) = El .",
        "eq right (A [ El , E2 ]) 52 .",
        "endo",
        "We cult now OISlailliale the formal parameters of the module in (5) with input modules which supply appropriate sets oh nonterminal and terminal symbols.",
        "let us use uppercase quoted identifiers (elements of the 014.1 module QID) for nonterminals.",
        "and lower case for terminals.",
        "The specification in ('1) allows us to treat terminals as trees, so that a binary tree.",
        "rooted in a node 'A, can have terminals as its daughters.",
        "However, we also allow terminals to be directly dominated by a non-branching mother node.",
        "Both possibilities occur in the examples below.",
        "(6) illustrates the instantiation of formal parameters by an actual module.",
        "namely QID.",
        "using the make construct.",
        "(6) make BINTREE-QID is BINTREE[QID,QID] endm",
        "The next example shows some reductions in this module, obtained by treating the equations as rewrite rules applying from left to right.",
        "'The notation Elt.NONTERM, Elt.TERM utilizes a qualification of t he sort Elt by the input module's parameter label: this is simply to allow disambiguation.",
        "Suppose we now wish to modify the definition of binary trees to obtain metrical trees, These are binary trees whose branches are ordered according to whether they are labelled (strong) or `w' (weak).",
        "w In addition, all trees have a distinguished leaf node called the 'designated terminal element' ( dte ), which is connected to the root of the tree by a path of 's' nodes.",
        "Let us define 's' and •w' to be our non terminals:",
        "(8) obj MET is sorts Label .",
        "ops s w : -> Label .",
        "endo",
        "In order to build the data type of tnetrical trees on top of binary trees, we can import the !nodule BINTREE, suitably instantiated, using OB.I's extending construct.",
        "Notice that we use MET to instantiate the parameter which fixes BINTREE's set of non terminal symbols.'",
        "(9) obj METTREE is extending BINTREE[MET,QID]*(sort Id to Leaf) op dte_ : Tree -> Leaf .",
        "'The* construct tells us that die principal sort of ()ID.",
        "namely Id, is mapped (by a signature morphismi to the sort Leaf in METTREE.",
        "ceq signals the presence of a conditional equation.",
        "is a built-in polymorphic equality operation in OBJ.",
        "if label T1 == s. ceq dte ( X [ Ti , T2 ]) = dte T2 if label T2 == s. endo The equations state that the dte (designated terminal element) of a tree is the dte of its strong subtree.",
        "Another way of stating this is that the information about dte element of a subtree T is percolated up to its parent node, just in case T is the 's' branch of that node.",
        "The specification METTREE can be criticised on a number of grounds.",
        "It has to use conditional equations in a cumbersome way to test which daughter of a binary tree is labelled 's'.",
        "Moreover, it fails to capture the restriction that no binary tree can have daughters which are both weak, or both strong.",
        "That is, it fails to capture the essential property of metrical trees, namely that metrical strength is a relational notion.",
        "What we require is a method for encoding the following information at a node: \"my left (or right) daughter is strong\".",
        "One economical method of doing this is to label (all and only) branching nodes in a binary tree with one of the following two labels: 'sw' (my left daughter is strong), `ws' ( my right daughter is strong).",
        "Thus, we replace MET with the following: obj MET2 is sorts Label ops sw vs : -> Label .",
        "endo 1-Ve can now simplify both BINTR.Eli and ME-TREE: obj BINTREE2[NONTERM TERM :: TRIV] is sorts Tree Netree subsorts Elt.TERM Netree < Tree .",
        "op _[_,_] : E1t.NONTERM Tree Tree -> Netree op label_ : Tree -> E1t.NONTERM op left_ : Netree -> Tree .",
        "op right_ : Netree -> Tree .",
        "ears El E2 : Tree .",
        "ears A : E1t.NONTERM .",
        "eq label (A [ El , E2 ]) = A eq left (A El , E2 1) El .",
        "eq right (A [ El , E2 ]) = E2 .",
        "endo",
        "var L : Leaf .",
        "yarn Ti T2 : Tree .",
        "eq dte L = L .",
        "eq dte T if label T == s❑ then dte(left T) else dte(right T) fi endo"
      ]
    },
    {
      "heading": "3 Feature Geometry",
      "text": [
        "The particular feature geometry we shall specify here is based on the articulatory structure defined in (Brownian & Goldstein 1989).6 The five active articulators are grouped into a hierarchical structure involving a tongue node and an oral node, as shown in the following diagram.",
        "commit dorsal This structure is specified via term constructors 1_4 and which give a standard positional encoding of features.",
        "Each feature value is expressed as a natural number between 0 and 1. representing the constriction degree of the corresponding articulator.",
        "For example.",
        "the tern: {4,0}: Tongue is an item of sort Tongue consisting of the value 4 for the feature conoN.,■i.",
        "and 0 for the DORSAL; this in turn expresses a situation where there is maximal constriction of the tongue tip, and minimal constriction of t he tongue body.",
        "Of course, this encoding is rat her crude, and possibly sacrifices clarity for concision.",
        "However, it suffices as a working example.",
        "We will return to constriction degrees below.",
        "The four sorts Gesture, Root.",
        "Oral and Tongue in (JO) and the first three operators rapture 'lie 'For space reasons we have omitted any discussion 01 11rowman Goldstein's constriction location ICI.)",
        ".01 constriction shape (CS) parameters.",
        "We also Moe omitted the supralaryngeal node, since its phonological rolcN somewhat dubious.",
        "desired tree structure, using an approach which should be familiar by now.",
        "For example, the third constructor takes the constriction degrees of Glottal and Velic gestures, and combines them with a complex item of sort Oral to build an item of Sort Root.",
        "'lime specification imports the module NAT of natural numbers to provide values for constriction degrees.",
        "(10) obj FEATS is extending NAT .",
        "sorts Gesture Root Oral Tongue .",
        "subsorts Nat Root Oral Tongue < Gesture .",
        "op {_,_} : Nat Nat -> Tongue .",
        "op {_,_} : Tongue Nat -> Oral .",
        "op f_,_,_1 : Nat Nat Oral -> Root op _!coronal : Tongue -> Nat .",
        "op _!dorsal : Tongue -> Nat .",
        "op _!labial : Oral -> Nat .",
        "op _!tongue : Oral -> Tongue .",
        "op _!glottal : Root -> Nat .",
        "op _!velic : Root -> Nat .",
        "op _!oral : Root -> Oral .",
        "eq { Cl , C2 I !coronal = Cl eq { Cl , C2 1 !dorsal = C2 eq f T , C 1 !tongue = T .",
        "eq { T , C / !labial = C eq { Cl , C2 , 0 } !glottal = Cl eq { Cl , C2 , 0 1 !velic = C2 .",
        "eq { Cl , C2 , 0 } !oral 0 .",
        "endo We adopt the notational convention of prepend, ing a to the name of selectors which correspond directly to features.",
        "For example, dm !coronal selector is a function defined on complex items of sort Tongue which returns an item of sort Nat, representing the constriction degree value for coronality.",
        "Some illustrative reductions in the FEATS module are given below.",
        "(II) 13,4,{14,1},1}} !oral {{4,1},1} {3,4,{{4,11,1}/ !oral !tongue .",
        "{3,4,{{4,1},1}} !oral !tongue !coronal In the A approach to feature structures, reen-rancy is represented by equating the values of selector,.",
        "Hts.",
        "suppose that t WO segments S2 share a voicing specification.",
        "We can write I his as follows:",
        "This structure sharing is consistent with one of the main motivating factors behind autosegmen-tal phonology, namely, the undesirability of rules such as [a voice] [a nasal].",
        "Now we can illustrate the function of selectors in phonological rules.",
        "Consider the case of English regular plural formation (-s), where the voicing of the suffix segment agrees with that of the immediately preceding segment.",
        "unless it is a corona' fricative (in which case there must be an intervening vowel).",
        "Suppose we introduce the variables S1 S2 : Root, where S1 is the stem-final segment and S2 is the suffix.",
        "The rule must also be able to access the corona' node of Sl.",
        "Making use of the selectors.",
        "this is simply S2 !oral !tongue !coronal (a notation reminiscent of paths in feature logic.",
        "(Kasper k Hounds 1986)).",
        "The rule must test whether this corona] node contains a fricative specification.",
        "This necessitates an extension to our specification.",
        "which is described below.",
        "Browman & Goldstein (1989.",
        "234ff ) define 'Constriction degree percolation'.",
        "based 011 What they call 'tube geometry.",
        "The vocal tract can be viewed as an interconnected set of tubes.",
        "and the articulators correspond to valves which have a number of settings ranging from fully open to fully closed.",
        "As already mentioned, these settings are called constriction degrees ( !cds).",
        "where fully closed is the maximal constriction and fully open is the minimal constriction.",
        "The net constriction degree of the oral cavity may be expressed as the maximum of the constriction degrees of the lips, tongue tip and longue body.",
        "The net constriction degree of the oral and nasal cavities together is simply the mininium of the two component constriction degrees.",
        "To recast this in the present framework is straightforward.",
        "However, we need to first define the operations max and min over pairs of natural numbers: (13)obj Mina is protecting NAT .",
        "ops min max : Nat Nat -> Nat vars M N : Nat .",
        "eq min(M,N) = if H <= N then M else N fi eq max(M,N) = if 14 >= N then M else N fi endo",
        "extending FEATS + MINMAX op _!cd : Gesture -> Nat ops clo crit narrow mid wide obs open : Gesture -> Bool var G : Gesture .",
        "var N N1 N2 : Nat .",
        "vars 0 : Oral .",
        "vars T : Tongue .",
        "eq N !cd = N eq {Nid12} !cd = max(N1,N2) eq {T,N} !cd max(T !cd,N) .",
        "eq 011,m2,0 !cd = max(N1,min(N2,0 !cd)) .",
        "eq clo(G) = G !cd == 4 .",
        "eq crit(G) = G !cd == 3 .",
        "eq narrow(G) G !cd == 2 .",
        "eq mid(G) = G !cd == 1 .",
        "eq wide(G) = G !cd == o .",
        "eq obs(G) = G !cd > 2 .",
        "eq open(G) = G !cc!",
        "< 3 .",
        "endo The specification CD allows classification into five basic constriction degrees (clo, crit, narrow, mid, and wide) by means of corresponding one-place predicates.",
        "i.e. boolean-valued operations over gestures.",
        "For example, the fifth equation above states that G has the constriction degree do (i.e. clo(G) is true) if and only if G !cd"
      ]
    },
    {
      "heading": "4.",
      "text": [
        "The working of these predicates is illustrated below:",
        "(15) {3,0,i14,11,111 !oral !tongue !cd .",
        "• 4 13,0,{{4,1},1}} !oral !cd .",
        "• 4",
        "{3,0,{{4,1},01 !cd ▪ 3 mid({3,0,144,11,111 !oral !labial) .",
        "▪ true wide({3,0,i{4,1},11) !oral !labial) .",
        "▪ false open({3,0,{{4,1},1}) !oral !labial) .",
        ",, true clo({3,0,{{4,1},1)) !oral !tongue) .",
        ",, true"
      ]
    }
  ]
}
