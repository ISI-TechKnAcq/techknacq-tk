{
  "info": {
    "authors": [
      "Mark-Jan Nederhof",
      "Giorgio Satta"
    ],
    "book": "Annual Meeting of the Association for Computational Linguistics",
    "id": "acl-P96-1032",
    "title": "Efficient Tabular L R Parsing",
    "url": "https://aclweb.org/anthology/P96-1032",
    "year": 1996
  },
  "references": [
    "acl-E93-1036",
    "acl-P89-1017",
    "acl-P89-1018",
    "acl-P91-1014",
    "acl-P94-1017",
    "acl-P94-1029"
  ],
  "sections": [
    {
      "heading": "Abstract",
      "text": [
        "We give a new treatment of tabular LR parsing, which is an alternative to Tomita's generalized LR algorithm.",
        "The advantage is twofold.",
        "Firstly, our treatment is conceptually more attractive because it uses simpler concepts, such as grammar transformations and standard tabulation techniques also know as chart parsing.",
        "Secondly, the static and dynamic complexity of parsing, both in space and time, is significantly reduced."
      ]
    },
    {
      "heading": "1 Introduction",
      "text": [
        "The efficiency of LR(k) parsing techniques (Sippu and Soisalon-Soininen, 1990) is very attractive from the perspective of natural language processing applications.",
        "This has stimulated the computational linguistics community to develop extensions of these techniques to general context-free grammar parsing.",
        "The best-known example is generalized LR parsing, also known as Tomita's algorithm, described by Tomita (1986) and further investigated by, for example, Tomita (1991) and Nederhof (1994a).",
        "Despite appearances, the graph-structured stacks used to describe Tomita's algorithm differ very little from parse tables, or in other words, generalized LR parsing is one of the so called tabular parsing algorithms, among which also the CYK algorithm (Harrison, 1978) and Earley's algorithm (Earley, 1970) can be found.",
        "(Tabular parsing is also known as chart parsing.)",
        "In this paper we investigate the extension of LR parsing to general context-free grammars from a more general viewpoint: tabular algorithms can often be described by the composition of two constructions.",
        "One example is given by Lang (1974) and Billot and Lang (1989): the construction of push-down automata from grammars and the simulation of these automata by means of tabulation yield different tabular algorithms for different such constructions.",
        "Another example, on which our presentation is based, was first suggested by Leermakers (1989): a grammar is first transformed and then a standard tabular algorithm along with some filtering condition is applied using the transformed grammar.",
        "In our case, the transformation and the subsequent application of the tabular algorithm result in a new form of tabular LR parsing.",
        "Our method is more efficient than Tomita's algorithm in two respects.",
        "First, reduce operations are implemented in an efficient way, by splitting them into several, more primitive, operations (a similar idea has been proposed by Kipps (1991) for Tomita's algorithm).",
        "Second, several paths in the computation that must be simulated separately by Tomita's algorithm are collapsed into a single computation path, using state minimization techniques.",
        "Experiments on practical grammars have indicated that there is a significant gain in efficiency, with regard to both space and time requirements.",
        "Our grammar transformation produces a so called cover for the input grammar, which together with the filtering condition fully captures the specification of the method, abstracting away from algorithmic details such as data structures and control flow.",
        "Since this cover can be easily precomputed, implementing our LR parser simply amounts to running the standard tabular algorithm.",
        "This is very attractive from an application-oriented perspective, since many actual systems for natural language processing are based on these kinds of parsing algorithm.",
        "The remainder of this paper is organized as follows.",
        "In Section 2 some preliminaries are discussed.",
        "We review the notion of LR automaton in Section,3 and introduce the notion of 2LR automaton in Section 4.",
        "Then we specify our tabular LR method in Section 5, and provide an analysis of the algorithm in Section 6.",
        "Finally, some empirical results are giv",
        "en in Section 7, and further discussion of our method is provided in Section 8."
      ]
    },
    {
      "heading": "2 Definitions",
      "text": [
        "Throughout this paper we use standard formal language notation.",
        "We assume that the reader is familiar with context-free grammar parsing theory (Harrison, 1978).",
        "A context-free grammar (CFG) is a 4-tuple G (E, N, P, S), where E and N are two finite disjoint sets of terminal and nonterminal symbols, respectively, S E N is the start symbol, and P is a finite set of rules.",
        "Each rule has the form A a with A E N and a E V*, where V denotes N U E. The size of G, written I GI, is defined as E(A_,,,,,)Ep I Aa I; by I a I we mean the length of a string of symbols a.",
        "We generally use symbols A, B, C, .",
        ".",
        ".",
        "to range over N, symbols a, b, c, .",
        ".",
        ".",
        "to range over E, symbols X ,Y, Z to range over V, symbols a, /3,7, .",
        "to range over V*, and symbols v, w, x, .",
        ".",
        ".",
        "to range over E*.",
        "We write c to denote the empty string.",
        "A CFG is said to be in binary form if a E {c} U VU N2 for all of its rules A --+ a.",
        "(The binary form does not limit the (weak) generative capacity of context-free grammars (Harrison, 1978).)",
        "For technical reasons, we sometimes use the augmented grammar associated with G, defined as Gt = (Et, Nt, pt, St), where St, D and <I are fresh symbols, Et E Nt N U {St} and pt p u {St DS<}.",
        "A pushdown automaton (PDA) is a 5-tuple A = qfin), where E , Q and T are finite sets of input symbols, stack symbols and transitions, respectively; q2n E Q is the initial stack symbol and qfin E Q is the final stack symbol.1 Each transition has the form 61 62, where 61,62 E Q*, 1 < 1611, < 1,521 < 2, and z = c or z = a.",
        "We generally use symbols q, r, s, .",
        ".",
        ".",
        "to range over Q, and the symbol 6 to range over Q*.",
        "Consider a fixed input string v E E. A configuration of the automaton is a pair (6, w) consisting of a stack 6 E Q* and the remaining input w, which is a suffix of the input string v. The rightmost symbol of 6 represents the top of the stack.",
        "The initial configuration has the form (q,n, v), where the stack is formed by the initial stack symbol.",
        "The final configuration has the form (qin qfin, c), where the stack is formed by the final stack symbol stacked upon the initial stack symbol.",
        "'We dispense with the notion of state, traditionally incorporated in the definition of PDA.",
        "This does not affect the power of these devices, since states can be encoded within stack symbols and transitions.",
        "The application of a transition bi 62 is described as follows.",
        "If the topmost symbols of the stack are bi, then these symbols may be replaced by 62, provided that either z = c, or z = a and a is the first symbol of the remaining input.",
        "Furthermore, if z = a then a is removed from the remaining input.",
        "Formally, for a fixed PDA A we define the binary relation F on configurations as the least relation satisfying (661, w) (662, w) if there is a transition 61 IL, 62, and (661, atv) (662, w) if there is a transition 61 62.",
        "The recognition of a certain input v is obtained if starting from the initial configuration for that input we can reach the final configuration by repeated application of transitions, or, formally, if (q, v) (qn, qfin, c), where F* denotes the reflexive and transitive closure of F. By a computation of a PDA we mean a sequence (q, v) (Si, wi) F (6„, wa), n > 0.",
        "A PDA is called deterministic if for all possible configurations at most one transition is applicable.",
        "A PDA is said to be in binary form if, for all transitions 61 124 62, we have 16i1 <2."
      ]
    },
    {
      "heading": "3 LR automata",
      "text": [
        "Let G = (E , N, P, S) be a CFG.",
        "We recall the notion of LR automaton, which is a particular kind of PDA.",
        "We make use of the augmented grammar Gt = (Et , Nt, pt st) introduced in Section 2.",
        "Let ./LR = {A a • f3 I (A cei3) E Pt}.",
        "We introduce the function closure from 2hR to 2/LR and the function got() from 2/LR x V to 2/LR.",
        "For any q C closure(q) is the smallest set such that",
        "(i) q C closure(q); and (ii) (B a • A13) E closure(q) and (A – > 7) E Pt together imply (A • 7) E closure(q).",
        "We then define",
        "We construct a finite set RLR as the smallest collection of sets satisfying the conditions:",
        "(i) {St SL> • S4} E RLR; and (ii) for every q E R.LR.",
        "and X E V, we have goto(q, X) E RLR, provided goto(q, X) 0 0.",
        "Two elements from RLR deserve special attention: qtn = {St D. • Si}, and qfin, which is defined to be the unique set in R.LR containing (St DS • <0; in other words, qfin = goto(q,n, S).",
        "Transitions in (i) above are called shift, transitions in (ii) are called reduce."
      ]
    },
    {
      "heading": "4 2LR Automata",
      "text": [
        "The automata ALR defined in the previous section are deterministic only for a subset of the CFGs, called the LR(0) grammars (Sippu and Soisalon-Soininen, 1990), and behave nondeterministically in the general case.",
        "When designing tabular methods that simulate nondeterministic computations of ALR, two main difficulties are encountered:",
        "• A reduce transition in ALR is an elementary operation that removes from the stack a number of elements bounded by the size of the underlying grammar.",
        "Consequently, the time requirement of tabular simulation of ALR computations can be onerous, for reasons pointed out by Sheil (1976) and Kipps (1991).",
        "• The set 'R.LR can be exponential in the size of the grammar (Johnson, 1991).",
        "If in such a case the computations of ALR touch upon each state, then time and space requirements of tabular simulation are obviously onerous.",
        "The first issue above is solved here by recasting ALR in binary form.",
        "This is done by considering each reduce transition as a sequence of \"pop\" operations which affect at most two stack symbols at a time.",
        "(See also Lang (1974), Villemonte de la Clergerie (1993) and Nederhof (1994a), and for LR parsing specifically Kipps (1991) and Leermakers (1992b).)",
        "The following definition introduces this new kind of automaton.",
        "Transitions in (i) above are again called shift, transitions in (ii) are called initiate, those in (iii) are called gathering, and transitions in (iv) are called goto.",
        "The role of a reduce step in ALR is taken over in Aim by an initiate step, a number of gathering steps, and a goto step.",
        "Observe that these steps involve the new stack symbols (A – + a • E iLR that are distinguishable from possible stack symbols {A a • PI E We now turn to the second above-mentioned problem, regarding the size of set RLR.",
        "The problem is in part solved here as follows.",
        "The number of states in 12,LR is considerably reduced by identifying two states if they become identical after items A – 4 a • )3 from /La have been simplified to only the suffix of the right-hand side This is reminiscent of techniques of state minimization for finite automata (Booth, 1967), as they have been applied before to LR parsing, e.g., by Pager (1970) and Nederhof and Sarbo (1993).",
        "Let GI be the augmented grammar associated with a CFG G, and let 12LR {/3 I (A afi) E Pl.",
        "We define variants of the closure and gob o functions from the previous section as follows.",
        "For any set q C /2LR, closure1(q) is the smallest collection of sets such that",
        "We now construct a finite set R2LR as the smallest set satisfying the conditions:",
        "(i) {S•i} E 7Z2Ln,; and (ii) for every q E R2LR and X E V, we have goto1(q, X) E Te2LR) provided goto'(q, X) 0 0.",
        "As stack symbols, we take the elements from /2LR and a subset of elements from (V x R2LR):",
        "In a stack symbol of the form (X, q), the X serves to record the grammar symbol that has been recognized last, cf. the symbols that formerly were found immediately before the dots.",
        "The 2LR automaton associated with G can now be introduced.",
        "Note that in the case of a reduce/reduce conflict with two grammar rules sharing some suffix in the right-hand side, the gathering steps of A2LR will treat both rules simultaneously, until the parts of the right-hand sides are reached where the two rules differ.",
        "(See Leermakers (1992a) for a similar sharing of computation for common suffixes.)",
        "An interesting fact is that the automaton A2LR is very similar to the automaton ALR constructed for a grammar transformed by the transformation rt,„„ given by Nederhof and Satta (1994).2"
      ]
    },
    {
      "heading": "5 The algorithm",
      "text": [
        "This section presents a tabular LR parser, which is the main result of this paper.",
        "The parser is derived from the 2LR automata introduced in the previous section.",
        "Following the general approach presented by Leermakers (1989), we simulate computations of 2 For the earliest mention of this transformation, we have encountered pointers to Schauerte (1973).",
        "Regrettably, we have as yet not been able to get hold of a copy of this paper.",
        "these devices using a tabular method, a grammar transformation and a filtering function.",
        "We make use of a tabular parsing algorithm which is basically an asynchronous version of the CYK algorithm, as presented by Harrison (1978), extended to productions of the forms A – 4 B and A – 4 c and with a left-to-right filtering condition.",
        "The algorithm uses a parse table consisting in a 0-indexed square array U.",
        "The indices represent positions in the input string.",
        "We define Ili to be Uk<i Uk,i, Computation of the entries of U is moderated by a filtering process.",
        "This process makes use of a function pred from 2N to 2N, specific to a certain context-free grammar.",
        "We have a certain nonterminal Ainit which is initially inserted in U0,0 in order to start the recognition process.",
        "We are now ready to give a formal specification of the tabular algorithm.",
        "Algorithm 1 Let G = (0, N, P, S) be a CFG in binary form, let pred be a function from 2N to 2N, let Atnst be the distinguished element from N, and let v = al a2 • • • an E 0* be an input string.",
        "We compute the least (n +1) x (n +1) table U such that Amit E U0,0 and",
        "(i) A E if (A ai) E P, A E pred(Ui _1); (ii) A E Ujj if (A – 4 e) EP,A E pred(Uj); (iii) A E if B E Ui,k, C E Ukj, (A – + BC) E P, A E pred(Ui); (iv) A E if B E , (A --+ B) E P, A E pred(Ui).",
        "The string has been accepted when S E UO,n • We now specify a grammar transformation, based on the definition of Ana.",
        "Observe that there is a direct, one-to-one correspondence between transitions of A2LR and productions of C2LR(G)• The accompanying function pred is defined as follows (q, q', q\" range over the stack elements):",
        "The above definition implies that only the tabular equivalents of the shift, initiate and goto transitions are subject to actual filtering; the simulation of the gathering transitions does not depend on elements in T. Finally, the distinguished nonterminal from the cover used to initialize the table is q:n. Thus we start with (c>, {S<1}) E Uo,o, The 2LR cover introduces spurious ambiguity: where some grammar G would allow a certain number of parses to be found for a certain input, the grammar C2LR(G) in general allows more parses.",
        "This problem is in part solved by the filtering function pred .",
        "The remaining spurious ambiguity is avoided by a particular way of constructing the parse trees, described in what follows.",
        "After Algorithm 1 has recognized a given input, the set of all parse trees can be computed as tree(efin, 0, n) where the function tree, which determines sets of either parse trees or lists of parse trees for entries in U, is recursively defined by:",
        "(i) tree((a, q'), i, j) is the set {a}.",
        "This set contains a single parse tree consisting of a single node labelled a.",
        "(ii) tree(E, i, i) is the set {e}.",
        "This set consists of an empty list of trees.",
        "(iii) tree(X , j) is the union of the sets /ikx0),i j, where i < k < j, (0) E Uk,i, and there is at least one (X, q) E Uidc and (X/3) --+ (X, q) (0) in C2Ln(G), for some q.",
        "For each such k, select one such q.",
        "We define 'T(kxp),i = ft • ts t E tree((X , q), i,k) A is E iree(fl ,k, j)} .",
        "Each t • is is a list of trees, with head t and tail is.",
        "(iv) tree((A, q'), i, j) is the union of the sets",
        "7A,q,),i,j, where (a) E Uji is such that (A, q') (a) in C2Ln(G).",
        "We define {glue(A, is) I is E tree(a, j)} .",
        "The function glue constructs a tree from a fresh root node labelled A and the trees in list is as immediate subtrees.",
        "We emphasize that in the third clause above, one should not consider more than one q for given k in order to prevent spurious ambiguity.",
        "(In fact, for fixed X, i, k and for different q such that (X, q) E Uidc, tree((X , q), i, k) yields the exact same set of trees.)",
        "With this proviso, the degree of ambiguity, i.e. the number of parses found by the algorithm for any input, is reduced to exactly that of the source grammar.",
        "A practical implementation would construct the parse trees on-the-fly, attaching them to the table entries, allowing packing and sharing of subtrees (cf. the literature on parse forests (Tomita, 1986; Billot and Lang, 1989)).",
        "Our algorithm actually only needs one (packed) subtree for several (X, q) E Ui,k with fixed X,i, k but different q.",
        "The resulting parse forests would then be optimally compact, contrary to some other LR-based tabular algorithms, as pointed out by Rekers (1992), Nederhof (1993) and Nederhof (1994b)."
      ]
    },
    {
      "heading": "6 Analysis of the algorithm",
      "text": [
        "In this section, we investigate how the steps performed by Algorithm 1 (applied to the 2LR cover) relate to those performed by A2LR, for the same input.",
        "We define a subrelation WI of 1-+ as: (6, uw) (bb' , w) if and only if (6, uw) = (15, zi z2 • • • zmw)",
        "Informally, we have (6, uw) (66', w) if configuration (66', w) can be reached from (6, uw) without the bottommost part 6 of the intermediate stacks being affected by any of the transitions; furthermore, at least one element is pushed on top of 6.",
        "The following characterization relates the automaton A2LR and Algorithm 1 applied to the 2LR cover.",
        "Symbol q E Q2LR is eventually added to Uji if and only if for some 8: (q, a1 ... an) 1-* (6, ai+i .",
        "an) WI (6q, ai +1 In words, q is found in entry Ujj if and only if, at input position j, the automaton would push some element q on top of some lower-part of the stack b that remains unaffected while the input from i to j is being read.",
        "The above characterization, whose proof is not reported here, is the justification for calling the resulting algorithm tabular LR parsing.",
        "In particular, for a grammar for which A2LR is deterministic, i.e. for an LR(0) grammar, the number of steps performed",
        "by Ana and the number of steps performed by the above algorithm are exactly the same.",
        "In the case of grammars which are not LR(0), the tabular LR algorithm is more efficient than for example a backtrack realisation of A2LR• For determining the order of the time complexity of our algorithm, we look at the most expensive step, which is the computation of an element (X0) E Ui,j from two elements (X, q) E Eli,k and (#) E Uk,j, through (X , q) (#) (Xí3) E T21,R.",
        "In a straightforward realisation of the algorithm, this step can be applied 0(1 T2LR I I Vi3) times (once for each i, k, j and each transition), each step taking a constant amount of time.",
        "We conclude that the time complexity of our algorithm is Oa T2LB, I • 1v13)• As far as space requirements are concerned, each set tki or Ui contains at most 1Q2LR1 elements.",
        "(One may assume an auxiliary table storing each IA.)",
        "This results in a space complexity 0(1Q2LR1 • 1v12).",
        "The entries in the table represent single stack elements, as opposed to pairs of stack elements following Lang (1974) and Leermakers (1989).",
        "This has been investigated before by Nederhof (1994a, p. 25) and Villemonte de la Clergerie (1993, p. 155)."
      ]
    },
    {
      "heading": "7 Empirical results",
      "text": [
        "We have performed some experiments with Algorithm 1 applied to AnAt and ALR, for 4 practical context-free grammars.",
        "For AC,R a cover was used analogous to the one in Definition 4; the filtering function remains the same.",
        "The first grammar generates a subset of the programming language ALGOL 68 (van Wijngaarden and others, 1975).",
        "The second and third grammars generate a fragment of Dutch, and are referred to as the CORRie grammar (Vosse, 1994) and the Deltra grammar (Schoorl and Belder, 1990), respectively.",
        "These grammars were stripped of their arguments in order to convert them into context-free grammars.",
        "The fourth grammar, referred to as the Alvey grammar (Carroll, 1993), generates a fragment of English and was automatically generated from a unification-based grammar.",
        "The test sentences have been obtained by automatic generation from the grammars, using the Grammar Workbench (Nederhof and Koster, 1992), which uses a random generator to select rules; therefore these sentences do not necessarily represent input typical of the applications for which the grammars were written.",
        "Table 1 summarizes the test material.",
        "Our implementation is merely a prototype, which means that absolute duration of the parsing process",
        "is little indicative of the actual efficiency of more sophisticated implementations.",
        "Therefore, our measurements have been restricted to implementation-independent quantities, viz, the number of elements stored in the parse table and the number of elementary steps performed by the algorithm.",
        "In a practical implementation, such quantities will strongly influence the space and time complexity, although they do not represent the only determining factors.",
        "Furthermore, all optimizations of the time and space efficiency have been left out of consideration.",
        "Table 2 presents the costs of parsing the test sentences.",
        "The first and third columns give the number of entries stored in table U, the second and fourth columns give the number of elementary steps that were performed.",
        "An elementary step consists of the derivation of one element in %R or Q2LR.",
        "from one or two other elements.",
        "The elements that are used in the filtering process are counted individually.",
        "We give an example for the case of MAI.",
        "Suppose we derive an element q' E Uj from an element (A • a) E warranted by two elements qi , q2 E U, qi q, through pred , in the presence of qi (A • a) 12.4 qi q' E TLR and q2 (A – 4 • a) 4 q2 q' E 71R.",
        "We then count Iwo parsing steps, one for q1 and one for",
        "A2LR• Apart from the dynamic costs of parsing, we have also measured some quantities relevant to the construction and storage of the two types of tabular 1,11 parser.",
        "These data are given in Table 3.",
        "We see that the number of states is strongly reduced with regard to traditional LR parsing.",
        "In the case of the Alvey grammar, moving from 'Rut' to ITZ2LRI amounts to a reduction to 20.3 %.",
        "Whereas time and space-efficient computation of 7Z.LR for this grammar is a serious problem, computation of R2LR will not be difficult on any modern computer.",
        "Also significant is the reduction from ITLRI to IT2LRI, especially for the larger grammars.",
        "These quantities correlate with the amount of storage needed for naive representation of the respective automata."
      ]
    },
    {
      "heading": "8 Discussion",
      "text": [
        "Our treatment of tabular LR parsing has two important advantages over the one by Tomita: • It is conceptually simpler, because we make use of simple concepts such as a grammar transformation and the well-understood CYK algorithm, instead of a complicated mechanism working on graph-structured stacks.",
        "• Our algorithm requires fewer Lit states.",
        "This leads to faster parser generation, to smaller parsers, and to reduced time and space complexity of parsing itself.",
        "The conceptual simplicity of our formulation of tabular LR parsing allows comparison with other tabular parsing techniques, such as Earley's algorithm (Earley, 1970) and tabular left-corner parsing (Nederhof, 1993), based on implementation-independent criteria.",
        "This is in contrast to experiments reported before (e.g. by Shann (1991)), which treated tabular 1,it parsing differently from the other techniques.",
        "The reduced time and space complexities reported in the previous section pertain to the tabular realisation of two parsing techniques, expressed by the automata ALR and A2LR.",
        "The tabular realisation of the former automata is very close to a variant of Tomita's algorithm by Kipps (1991).",
        "The objective of our experiments was to show that the automata A2LR provide a better basis than AL R for tabular LR parsing with regard to space and time complexity.",
        "Parsing algorithms that are not based on the Lit technique have however been left out of consideration, and so were techniques for unification grammars and techniques incorporating finite-state processes.",
        "Theoretical considerations (Leermakers, 1989; Schabes, 1991; Nederhof, 1994b) have suggested that for natural language parsing, LR-based techniques may not necessarily be superior to other parsing techniques, although convincing empirical data to this effect has never been shown.",
        "This issue is difficult to resolve because so much of the relative efficiency of the different parsing techniques depends on particular grammars and particular input, as well as on particular implementations of the techniques.",
        "We hope the conceptual framework presented in this paper may at least partly alleviate this problem."
      ]
    },
    {
      "heading": "Acknowledgements",
      "text": [
        "The first author is supported by the Dutch Organization for Scientific Research (NWO), under grant 305- 00-802.",
        "Part of the present research was done while the second author was visiting the Center for Language and Speech Processing, Johns Hopkins University, Baltimore, MD.",
        "We received kind help from John Carroll, Job Honig, Kees Koster, Theo Vosse and Hans de Vreught in finding the grammars mentioned in this paper.",
        "Generous help with locating relevant literature was provided by Anton Nijholt, Rockford Ross, and Arnd RuBmann.",
        "'As remarked before by Nederhof (1993), the algorithms by Schabes (1991) and Leermakers (1989) are not really related to LR parsing, although some notation used in these papers suggests otherwise."
      ]
    }
  ]
}
