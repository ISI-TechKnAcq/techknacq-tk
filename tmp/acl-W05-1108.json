{
  "info": {
    "authors": [
      "Yael Cohen-Sygal",
      "Shuly Wintner"
    ],
    "book": "Proceedings of ACL SIGLEX Workshop on Software",
    "id": "acl-W05-1108",
    "title": "XFST2FSA: Comparing Two Finite-State Toolboxes",
    "url": "https://aclweb.org/anthology/W05-1108",
    "year": 2005
  },
  "references": [],
  "sections": [
    {
      "text": [
        "Yael Cohen-Sygal Shuly Wintner",
        "yaelcScs.haifa.ac.il shulyScs.haifa.ac.il",
        "This paper introduces xfst2fsa, a compiler which translates grammars expressed in the syntax of the XFST finite-state toolbox to grammars in the language of the FSA Utilities package.",
        "Compilation to FSA facilitates the use of grammars developed with the proprietary XFST toolbox on a publicly available platform.",
        "The paper describes the non-trivial issues of the compilation process, highlighting several shortcomings of some published algorithms, especially where replace rules are concerned.",
        "The compiler augments FSA with most of the operators supported by XFST.",
        "Furthermore, it provides a means for comparing the two systems on comparable grammars.",
        "The paper presents the results of such a comparison."
      ]
    },
    {
      "heading": "1. Introduction",
      "text": [
        "Finite-state technology is widely considered to be the appropriate means for describing the phonological and morphological phenomena of natural languages since the pioneering works of Koskenniemi (1983) and Kaplan and Kay (1994).",
        "Finite state technology has some important advantages, making it most appealing for implementing natural language morphology.",
        "One can find it very hard, almost impossible, to build the full automaton or transducer describing some morphological phenomena.",
        "This difficulty arises from the fact that there are a great number of morpho-phonological processes combining together to create the full language.",
        "However, it is usually very easy to build a finite state machine to describe a specific morphological phenomenon.",
        "The closure properties of regular languages make it most convenient to implement each phenomenon independently and combine them together.",
        "Moreover, finite state techniques have the advantage of being efficient in their time and space complexity, as the membership problem is solvable in time linear in the length of the input.",
        "Furthermore, there are known algorithms for minimizing and determinizing automata and some restricted kinds of transducers.",
        "Several finite state toolboxes (software packages) provide extended regular expression description languages and compilers of the expressions to finite state devices, automata and transducers (Karttunen et al., 1996; Beesley and Karttunen, 2003; Mohri, 1996; van Noord and Gerdemann, 2001a; van No-ord and Gerdemann, 2001b).",
        "Such toolboxes typically include a language for extended regular expressions and a compiler from regular expressions to finite-state devices (automata and transducers).",
        "These toolboxes also include efficient implementations of several standard algorithms on finite state machines, such as union, intersection, minimization, determinization etc.",
        "More importantly, they also implement special operators that are useful for linguistic description, such as replacement (Kaplan and Kay, 1994; Mohri and Sproat, 1996; Karttunen, 1997; Gerdemann and van Noord, 1999) or predicates over alphabet symbols (van Noord and Gerdemann, 2001a; van Noord and Gerdemann, 2001b), and even operators for particular linguistic theories such as Optimality Theory (Karttunen, 1998; Gerdemann and van Noord, 2000).",
        "Unfortunately, there are no standards for the syntax of extended regular expression languages and switching from one toolbox to another is a non-trivial task.",
        "This work focuses on two toolboxes, XFST (Beesley and Karttunen, 2003) and FSA Utilities (van Noord, 2000).",
        "Both are powerful tools for specifying and manipulating finite state machines (acceptors and transducers) using extended regular expression languages.",
        "In addition to the standard operators, XFST also provides advanced operators such as replacement, markup, and restriction (Karttunen, 1995; Karttunen, 1996; Karttunen, 1997; Karttunen and Kempe, 1995), and advanced methods such as compile-replace and flag-diacritics.",
        "FSA, on the other hand, supports weighted finite state machines and provides visualization of finite state networks.",
        "In addition, FSA is built over Prolog, allowing the additional usage of Prolog predicates.",
        "A first significant difference between the two packages is the wide variety of operators that XFST provides in comparison to FSA.",
        "However, FSA has the clear advantage of being a free, open source package, whereas XFST is proprietary.",
        "This paper describes xfst2fsa, a compiler which translates XFST grammars to grammars in the language of the FSA Utilities package.",
        "There is a strong parallelism between the languages, but certain constructs are harder to translate and require more innovation.",
        "In particular, all the replace operators that XFST provides do not exist in FSA and had to be re-implemented.",
        "In this work we relate only to the core of the finite state calculus - naive automata and transducers.",
        "We do not deal with extended features such as the weighted networks of FSA or with advanced methods such as Prolog capabilities in FSA and compile replace and flag diacritics in XFST.",
        "The contribution of this work is manifold.",
        "Our main motivation is to facilitate the use of grammars developed with XFST on publicly available systems.",
        "Furthermore, this work gives a closer insight into the theoretical algorithms which XFST is based on.",
        "We show that the algorithms published in the literature are incomplete and require refinement in order to be correct for all inputs.",
        "Moreover, our compiler enriches FSA with implementations of several replace rules, thereby scaling up the system and improving",
        "1rThe system and the source code are available for download from http://cl.haifa.ac.il/projects/fstfsa/index.shtml",
        "its expressivity.",
        "Finally, this work offers an investigation of two similar, but different systems: the compiler facilitates a comparison of the two systems on very similar benchmarks."
      ]
    },
    {
      "heading": "2. The xfst2fsa compiler",
      "text": [
        "Compilation of a given XFST grammar into an equivalent FSA code is done in two main stages: first, the XFST grammar is parsed, and a tree representing its syntax is created.",
        "Then, by traversing the tree, the equivalent FSA grammar is generated.",
        "In order to parse XFST grammars, a specification of the XFST syntax is required.",
        "Unfortunately, we were unable to obtain a formal specification and we resorted to reconstructing it from available documentation (Beesley and Karttunen, 2003).This turned out to be a minor inconvenience; a more major obstacle was the semantics of XFST expressions, especially those involving advanced operators such as replace rules, markup and restriction.",
        "We exemplify in this section some of these issues.",
        "XFST operators can be divided into three groups with respect to their FSA equivalence: those which have an equivalent operator in FSA, those which do not but can be easily constructed from basic FSA operators, and those whose constructions is more complicated.",
        "In what follows we refer to operators of the first two groups as basic operators.",
        "Figure 1 displays a comparison table of some basic operators in XFST and FSA.",
        "For example, consider the XFST operator $?A (\"contains at most one\").",
        "This operator is not provided by FSA but can be constructed as provided by FSA in our publicly available package of extended FSA operators.",
        "The same holds for XFST operators such as (internally ignore),",
        "(contains one) etc.",
        "As another example consider the XFST operator (n-ary concatenation).",
        "It does not have an equivalent operator in FSA, but it can be simply constructed in FSA by explicitly expressing the concatenation as many times as needed.",
        "Thus, the XFST regular expression is translated into the equivalent FSA regular expression .",
        "Similar techniques are used for other basic XFST operators such as (more than n concatenations of A), A~-[n,k} (n to k concatenations of A) etc.",
        "Another minor issue is the different operator precedence in XFST and FSA.",
        "This problem was solved by bracketing each translated operator in XFST with '( )' to force the correct precedence.",
        "Special care is needed in order to deal with XFST operators of the third group, e.g., all the replace, markup and restriction rules in XFST.",
        "These rules do not have any equivalents in FSA, and hence the only way to use them in FSA is to implement them from scratch.",
        "This was done using the existing documentation (Karttunen, 1995; Karttunen, 1996; Karttunen, 1997; Karttunen and Kempe, 1995) on the construction of these operators from the basic ones.",
        "However, not all the operators are fully documented and in some cases some innovation was needed.",
        "As an example, consider the XFST operator (obligatory, lower to upper, left to right, longest match replacement).",
        "To the best of our knowledge, this operator is not documented.",
        "However, by Karttunen (1995), the operator (obligatory, lower to upper replacement ) is defined as (where is the obligatory, upper to lower replacement of the language B by the language A).",
        "We then concluded that is constructed as (where is the obligatory, upper to lower, left to right, longest match replacement of the language B by the language A) and from Karttunen (1996) the construction of the operator is known.",
        "For some of the documented operators, we found that the published algorithms are erroneous in some special cases.",
        "Consider the replace operator (conditional replacement of the language A by the language B, in the context of L on the left and R on the right side, where both contexts are on the upper side).",
        "In Karttunen (1997; 1995), a detailed description of the construction of this operator is given.",
        "In addition, Karttunen (1997) discusses some boundary cases, such as the case in which the language A contains the empty string.",
        "We discovered that there are some cases which are not discussed as boundary ones in Karttunen (1997) and for which the standard algorithm in Karttunen (1997; 1995) does not produce the expected result by the definition of the operator denotation.",
        "One such case is a rule of the form A->B I I _ ?, where A and B are some regular expressions denoting languages.",
        "This rule states that any member of the language A on the upper side is replaced by all members of the language B on the lower side when the upper side member is not followed by the end of the string on which the rule operates.",
        "For example, the rule is expected to generate the automaton of Figure 2.",
        "However, a direct implementation of the algorithms of Karttunen (1997; 1995) always yields a network accepting the empty language, independently of the way A and B are defined.",
        "Other ambiguous cases are discussed in Vaillette (2004).",
        "Furthermore, in some cases XFST produces networks that are somewhat different from the ones in the literature: the relations (as sets) are equal but the resulting automata (as graphs) are not isomorphic.",
        "For example, consider the replace rule .",
        "This expression is compiled by XFST to the automaton shown in Figure 3.",
        "Implementing this rule from basic operators as described in Karttunen (1997; 1995), results in the automaton of Figure 4.",
        "Observe that in some cases multiple accepting paths are obtained.",
        "This is probably a result of adding £-self-loops in order to deal correctly with £ symbols, following Pereira and Riley (1997); the multiple paths can then be removed using filters.",
        "We assume that the same solution is adopted by XFST.",
        "This solution requires direct access to the underlying network, and cannot be applied at the level of the regular expression language.",
        "Therefore, we did not utilitize it in our implementation of replace rules.",
        "To validate the construction of the compiler, one would ideally want to check that the obtained FSA networks are equivalent to the XFST ones from which they were generated.",
        "Unfortunately, this is only possible for very small networks, since XFST does not allow to print its networks, when they are significantly large.",
        "We could only test XFST networks and their FSA images over test strings to validate the identity of the outputs.",
        "In addition to checking each operator by itself for several instances, we tested the compiler on a more comprehensive code, namely HAMSAH (Yona and Wintner, 2005), which was designed and implemented using XFST.",
        "We successfully converted the entire network into FSA with the compiler.",
        "Exhaustive tests produced the same outputs for both networks."
      ]
    },
    {
      "heading": "3. Comparison of XFST and FSA",
      "text": [
        "A byproduct of the compiler is a full implementation, in FSA, of a vast majority of XFST's operators.",
        "In addition to the contribution to FSA users, this also facilitates an effective comparison between the two toolboxes on similar benchmarks.",
        "We now describe the results of such a comparison, focusing on usability and performance.",
        "FSA displays networks in two possible formats: as text, by listing the network states and transitions, and through a graphical user interface.",
        "The GUI that FSA employs is user friendly, allows many kinds of manipulations of the networks and significantly helps to the understanding of the networks, especially when they are small.",
        "The viewing parameters can be scaled by the user, thus improving the visualization possibilities.",
        "Moreover, networks can be saved in many different formats including binary (for fast loading and saving), text (allowing inspection of the network without the necessity to use FSA) and postscript (for printing).",
        "FSA also enables generation of C, C++, Java and Prolog code, implementing analysis with a network.",
        "XFST syntax",
        "FSA syntax",
        "Meaning",
        "A*",
        "A*",
        "Kleene star",
        "A 1 B",
        "{A,B}",
        "union",
        "A & B",
        "A & B",
        "intersection",
        "A - B",
        "A - B",
        "A minus B",
        "A/B",
        "ignore(A,B)",
        "A ignoring B",
        "$A",
        "$A",
        "containment",
        "$?A",
        "{$A - ignore([A,A],?",
        "*) , ?",
        "* - $A}",
        "maximum one containm",
        "A B",
        "[A,B]",
        "concatenation",
        "A~n",
        "does not exist",
        "nary concatenation",
        "A.x.B",
        "A x B",
        "crossproduct",
        "A.o.B",
        "A o B",
        "composition",
        "(A)",
        "A~",
        "optionality",
        "[ ]",
        "( )",
        "precedence",
        "R.i",
        "invert (R) or inverse (R)",
        "regular relation inverse",
        "XFST, on the other hand, prints its networks only in text format, and even this is supported for small networks only.",
        "Networks in XFST can be saved in binary format only, thus requiring the usage of XFST in order to inspect the network.",
        "With respect to visual display and ease of use, therefore, FSA has clear benefits over XFST.",
        "A true comparison of the two systems should compare two different grammars, each designed specifically for one of the two toolboxes, yielding the same comprehensive network.",
        "However, as such grammars are not available, we compared the two toolboxes using a grammar designed and implemented in XFST and its conversion into FSA.",
        "Again we used",
        "HAMSAH (Yona and Wintner, 2005) for this purpose.",
        "The Hebrew morphological analyzer is a large XFST grammar: the complete network consists of approximately 2 million states and 2.2 million arcs.",
        "We also inspected two subnetworks: the Hebrew adjectives network (approximately 100,000 states and 120,000 arcs) and the Hebrew nouns network (approximately 700,000 states and 950,000 arcs).",
        "Each of the networks was created by composing a series of rules over a large-scale lexicon.",
        "Since Hebrew morphology is non-trivial, the final network is created by composing many intermediate complex regular expressions (including many replace rules and compositions).",
        "The grammars were compiled and executed on a 64-bit computer with 16Gb of memory.",
        "The table in Figure 5 shows the differences in compilation and analysis times and memory requirements between the two toolboxes.",
        "XFST performed immeasurably better than FSA.",
        "In particular, we were unable to use the complete FSA network for analysis, compared to analyzing 70 words per second with the full network in XFST.",
        "Another issue that should be noticed is the difference in memory requirements."
      ]
    },
    {
      "heading": "4. Conclusions",
      "text": [
        "We presented a compiler which translates XFST grammars to grammars in the language of the FSA Utilities package.",
        "This work allows a closer look into two of the most popular finite state toolboxes.",
        "Although FSA has the advantage of being a publicly available software, we discovered that it does not scale up as well as XFST.",
        "However, for the nonexpert user or for teaching purposes, where more modest networks are manipulated, FSA seems to be more friendly, especially with regard to graphical representation of networks.",
        "With our new implementation of replace rules in FSA, it seems that for such uses FSA is better.",
        "However, for larger systems and when time performance is an issue, XFST is preferable.",
        "This work can be extended in several directions.",
        "Not all XFST operators are implemented in FSA.",
        "Some for lack of documentation and some simply require more time for implementation.",
        "Thus, further work can be done to construct more operators (see footnote 3).",
        "We believe that replace rules still hide boundary cases which require special treatment.",
        "More work is needed in order to locate such cases.",
        "Furthermore, other finite state toolboxes exist (Mohri, 1996) which present different operators.",
        "Extending the compiler to convert XFST grammars into those formalisms will provide opportunities for better comparison of different finite-state toolboxes.",
        "On a different course, an fsa2xfst compiler can be constructed.",
        "Such a compiler will enable a reverse performance comparison, i.e. using a larger network for FSA and making it operational in XFST.",
        "Notice that in contrast to the xfst2fsa direction, this course is rather trivial: FSA allows the user to save its networks in a readable format (listing the network states and arcs).",
        "Although XFST is not capable of reading any format but its own, Kleene (1954) presents a simple algorithm for generating from a given FSA a regular expression denoting it.",
        "Using this algorithm, an XFST regular expression denoting the network can be generated.",
        "The only disadvantage of such an approach is that the resulting XFST expression will be most cumbersome."
      ]
    },
    {
      "heading": "Acknowledgments",
      "text": [
        "This research was supported by The Israel Science Foundation (grant no.",
        "136/01).",
        "We are grateful to Gertjan van Noord and Shlomo Yona for their help.",
        "FSA",
        "XFST",
        "Time",
        "Memory",
        "Time",
        "Memory",
        "complete network",
        "13h 43m",
        "«11G",
        "27m 41s",
        "«3G",
        "Compilation",
        "nouns network",
        "2h 29m",
        "11m 4s",
        "adjectives network",
        "14m 56s",
        "8m 21s",
        "complete network, 350 words",
        "not possible",
        "5s",
        "Analysis",
        "nouns network, 120 nouns",
        "lh 50m",
        "0.17s",
        "adjectives network, 50 adjectives",
        "2m 34s",
        "0.17s",
        "A A comparison table of XFST and FSA operators A.1 Symbols A.2 Basic operators A.3 Restriction",
        "XFST syntax",
        "FSA syntax",
        "Meaning",
        "a",
        "a",
        "single symbol a",
        "%* or \"*\"",
        "escape(*) or '*'",
        "escape literal symbol",
        "abc",
        "abc",
        "multi-character symbol",
        "?",
        "?",
        "any symbol",
        "0or[] or\"\"",
        "[]",
        "epsilon symbol, the empty string",
        "{abed}",
        "[a,b,c,d]",
        "single character brace",
        "XFST syntax",
        "FSA syntax",
        "Meaning",
        "A*",
        "A*",
        "Kleene star",
        "A+",
        "A+",
        "iteration (Kleene plus)",
        "A 1 B",
        "{A,5}",
        "union",
        "A&B",
        "A&5",
        "intersection",
        "A^B",
        "A^B",
        "A minus B",
        "\\A",
        "[~A] &?",
        "term complement",
        "~ A",
        "~ A",
        "complement",
        "A/B",
        "ignore(A,B)",
        "A ignoring B",
        "A./.B",
        "ignore(A,B)-{[B,l*],[l*,B]}",
        "A ignoring internally B",
        "$A",
        "$A",
        "containment",
        "$.A",
        "$A^ignore([A,A],l*)",
        "one containment",
        "$?A",
        "{$A - ignore(\\A,A],l*),l* -$A}",
        "maximum one containment",
        "AB",
        "[A,B]",
        "concatenation",
        "A~n",
        "nary concatenation",
        "A~{n,k}",
        "n to k concatenations of A",
        "A~ > «",
        "more than n concatenations of A",
        "A\" <n",
        "less than n concatenations of A",
        "A.x.B",
        "AxB",
        "crossproduct",
        "A.o.B",
        "AoB",
        "composition",
        "(A)",
        "A~",
        "optionality",
        "a : b",
        "a : b",
        "symbol pair",
        "[]",
        "0",
        "order control",
        "R.P.Q",
        "{R, (domain(Q) – domain(R)) o Q}",
        "upper-side priority union",
        "R.p.Q",
        "{R, Q o (range(Q) - range{R))}",
        "lower-side priority union",
        "R.^u.Q",
        "(domain(R) – domain(Q)) o R",
        "upper-side minus",
        "R.-I.Q",
        "R o (range(R) – range(Q))",
        "lower-side minus",
        "A <B",
        "~ $[B,A]",
        "A before B",
        "A> B",
        "~$[A,ß]",
        "A after B",
        "A.r",
        "reverse (A)",
        "reverse",
        "R.uorR.l",
        "domain(R)",
        "upper language of the regular relation R",
        "R.l orR.2",
        "range (R)",
        "lower language of the regular relation R",
        "R.i",
        "invert (R) or inverse (R)",
        "regular relation inverse",
        "XFST restriction rules are not provided by FSA, nor did we implement them.",
        "Therefore, we only present their syntax in XFST.",
        "XFST replace rules do not exist in FSA.",
        "We present implementation of most of them in FSA, based on (Karttunen, 1995; Karttunen, 1996; Karttunen, 1997; Karttunen and Kempe, 1995).",
        "XFST replace rules can be divided into 4 groups:",
        "1.",
        "Unconditional replace rules (one rule with no context).",
        "2.",
        "Unconditional parallel replace rules (several rules with no context that are performed at the same time).",
        "3.",
        "Conditional replace rules (one rule and one condition).",
        "4.",
        "Conditional parallel replace rules (several rules and/or several contexts).",
        "Meaning: Unconditional replacement of the language A by the language B.",
        "Construction: [[NO_ A [A .x.",
        "B] ]* NO_ A] where NO_ A abbreviates ~ $[ A - [ ] ].",
        "Meaning: Unconditional parallel replacement of the language A i by the language Bi and the language A2 by the language B2 ... and the language An by the language Bn.",
        "Construction: [ [N R]* N ] where N denotes the language of strings that do not contain any A;:",
        "N=~ $[ [Ai\\...\\An]-[]] and R stands for the relation that pairs every Ai with the corresponding B;:",
        "Meaning: Conditional replacement of the language A by the language B.",
        "This is like the relation A B except that any instance of A in the upper string corresponds to an instance of B in the lower string only when it is preceded by an instance of L and followed by an instance of R. Other instances of A in the upper string remain unchanged.",
        "A, B, L, and R must all denote simple languages, not relations.",
        "The slant of the double bars indicates whether the precede/follow constraints refer to the instance of A in the upper string or to its image in the lower string.",
        "In the version, both contexts refer to the upper string.",
        "Construction: InsertBrackets .o.",
        "ConstrainBrackets .o.",
        "LeftContext .o.",
        "RightContext .o.",
        "Replace .o.",
        "RemoveBrackets where:",
        "- Let < and > be two symbols not in Z.",
        "The escape character % is used since < and > are saved symbols in XFST.",
        "- InsertBrackets % % InserBrackets eliminates from the upper side language all context markers that appear on the lower side.",
        "- ConstrainBrackets $ % % ConstrainBrackets denotes the language consisting of strings that do not contain anywhere.",
        "- Le f Context = [~[~ [...LEFT] [< ...}} & ~ [ [...LEFT] ~ [< ...] ] ] LeftContext denotes the language in which any instance of is immediately preceded by LEFT and every LEFT is immediately followed by , ignoring irrelevant brackets.",
        "LEFT denotes except for a final <.",
        "[< ...] denotes [% < /% > ?",
        "*], the language of strings beginning with <, ignoring the other bracket.",
        "- RightContext RIGHT & RIGHT",
        "RightContext denotes the language in which any instance of is immediately followed by RIGHT and any RIGHT is immediately preceded by , ignoring irrelevant brackets.",
        "RIGHT denotes R % % ?",
        "% ?",
        ", the language of all strings beginning with R, ignoring all brackets except for an initial .",
        "denotes ?",
        "% % , the language of strings ending with , ignoring the other bracket.",
        "- The definition of Replace divides into three cases:",
        "1.",
        "If A does not contain the empty string (epsilon) then",
        "This is the unconditional replacement of A by B , ignoring irrelevant brackets.",
        "3.",
        "If A contains the empty string but is not equal to it (i.e., contains other strings too) then",
        "That is, the first two cases are performed in parallel.",
        "- RemoveBrackets % % .",
        "RemoveBrackets denotes the relation that maps the strings of the upper language to the same strings without any context markers.",
        "Meaning: Conditional replacement of the language A by the language B.",
        "This is like the relation A^ > B 11 L _ R except that the // variant requires the left context on the lower side of the replacement and the right context on the upper side.",
        "Construction: InsertBrackets .o.",
        "ConstrainBrackets .o.",
        "RightContext .o.",
        "Replace .o.",
        "LeftContext ,o. RemoveBrackets where InsertBrackets, ConstrainBrackets, RightContext, Replace, LeftContext and RemoveBrackets are the same as above.",
        "Meaning: Conditional replacement of the language A by the language B.",
        "This is like the relation A – > ß II L - R except that the \\\\ variant requires the left context on the upper side of the replacement and the right context on the lower side.",
        "Construction: InsertBrackets o ConstrainBrackets o Le ftContext o Replace o RightContext o RemoveBrackets where InsertBrackets, ConstrainBrackets, RightContext, Replace, LeftContext and RemoveBrackets are the same as above.",
        "Meaning: Conditional replacement of the language A by the language B.",
        "This is like the relation A – > B 11 L _R except that in the \\/ variant, both contexts refer to the lower string.",
        "Construction: InsertBrackets .o.",
        "ConstrainBrackets .o.",
        "Replace .o.",
        "LeftContext .o.",
        "RightContext .o.",
        "RemoveBrackets where InsertBrackets, ConstrainBrackets, RightContext, Replace, LeftContext and RemoveBrackets are the same as above.",
        "The rest of the obligatory upper to lower replace rules are conditional parallel replace rules that where not implemented.",
        "An example of such a rule is An – > Bn,... ,A\\n – > B\\n || L\\\\-R\\\\,- ■ ■ ,L\\m_R\\m.",
        "A.4.2 ( – >) (optional, upper to lower replacement)",
        "XFST syntax: A B Construction: ?",
        "A x B ?",
        ".",
        "XFST syntax: Ai Bi An Bn",
        "Construction: ?",
        "R ?",
        "where R stands for the relation that pairs every Ai with the corresponding B;: R = [[Ai .x.Bi]\\„, | [An .x.Bn] ].",
        "Construction: The same as the construction for the corresponding rules with the operator with the difference that in the Replace stage, for each one of the three cases the obligatory upper to lower replace operator is replaced by the optional upper to lower replace operator .",
        "The rest of the optional upper to lower replace rules are conditional parallel replace rules and were not implemented.",
        "XFST syntax: A B",
        "Construction: B A i",
        "XFST syntax: Ai Bi An Bn Construction: Bi Ai Bn An i",
        "Construction: The same as the construction for the corresponding rules with the operator with the difference that in the Replace stage, for each one of the three cases the obligatory upper to lower replace operator is replaced by the operator .",
        "The rest of the obligatory lower to upper replace rules are conditional parallel replace rules and were not implemented.",
        "XFST syntax: Ai Bi An Bn",
        "XFST syntax: A B",
        "Construction: The same as the construction for the corresponding rules with the operator – > with the difference that in the Replace stage, for each one of the three cases the obligatory upper to lower replace operator is replaced by the operator .",
        "The rest of the optional lower to upper replace rules are conditional parallel replace rules and were not implemented.",
        "Construction: Let @ be a character not in Z.",
        "We use the escape character % to precede @, since @ is a reserved character in XFST.",
        "Thus, A < – > B is defined as .o.",
        "Construction: Let @1,..., @n be characters not in Z.",
        "We use the escape character % to precede each @i, since @ is a reserved character in XFST.",
        "Thus, A < – > B is defined as",
        "The rest of the obligatory upper to lower and lower to upper replace rules are conditional replace rules and they were not implemented.",
        "A.4.6 (< – >) (optional, upper to lower, lower to upper replacement)",
        "Construction: Let @ be a character not in Z.",
        "We use the escape character % to precede @, since @ is a reserved character in XFST.",
        "Thus, A(< – >)B is defined as",
        "The rest of the optional upper to lower and lower to upper replace rules are conditional and parallel replace rules and they were not implemented.",
        "A.4.7 @ – > (obligatory, upper to lower, left to right, longest match replacement)",
        "The following operations are the same as in section A.4.1, except that instead of – > occurs @ – >.",
        "As represented an obligatory upper to lower replacement, @ represents an obligatory upper to lower left to right longest match replacement.",
        "Instances of the language A on the upper side of the relation are replaced selectively.",
        "The selection factors each upper language string uniquely into A and non-A substrings.",
        "The factoring is based on a left-to-right and longest match regimen.",
        "The starting locations are selected from left-to-right.",
        "If there are overlapping instances of A starting at the same location, only the longest one is replaced by all strings of B.",
        "XFST syntax: A@ B",
        "Construction: InitialMatch .o.",
        "LeftToRight .o.",
        "LongestMatch .o.",
        "Replacement Where:",
        "- Let ~, <, > be characters not in Z.",
        "We use the escape character % to precede them since they are reserved characters in XFST.",
        "- InitialMatch where [..] – > LOWER || LEFT_ RIGHT is a version of empty string replacement that allows only one application between any LEFT and RIGHT.",
        "The construction for [..] – > LOWER II LEFT .RIGHT is the same as for UPPER - > LOWER || LEFT .RIGHT except that Replace % % % LOWER% .",
        "- Le ft ToRight",
        "- Let ~, <, > be characters not in Z.",
        "We use the escape character % to precede them since they are reserved characters in XFST.",
        "- InitialMatch where [..] – > LOWER || LEFT_ RIGHT is a version of empty string replacement that allows only one application between any LEFT and RIGHT.",
        "The construction for LOWER II LEFT .RIGHT is the same as for UPPER - > LOWER || LEFT .RIGHT except that Replace % % % LOWER% .",
        "The rest of the obligatory upper to lower left to right longest match replace rules are conditional and parallel replace rules and they were not implemented.",
        "The following XFST operators were not implemented:",
        "• @ > (obligatory, upper to lower, left to right, shortest match replacement)",
        "• – > @ (obligatory, upper to lower, right to left, longest match replacement)",
        "@ right (obligatory, upper to lower, right to left, shortest match replacement) A.5 Markup",
        "Markup rules take an input string and mark it by inserting some strings before and after it.",
        "XFST markup rules do not exist in FSA.",
        "We present the implementation of most of them in FSA, based on Karttunen (1996).",
        "Meaning: Markup.",
        "Instances of the language A on the upper side of the relation are selected for markup.",
        "Each selected A string is marked by inserting all strings of L to its left and all strings of R to its right.",
        "The selected A strings themselves remain unchanged, along with the non-A segments.",
        "Meaning: Directed markup.",
        "Instances of the language A on the upper side of the relation are selected for markup under left-to-right, longest match regimen.",
        "Thus, the starting locations are selected from left-to-right.",
        "If there are overlapping instances of A starting at the same location, only the longest one is replaced by all strings of B.",
        "Each selected A string is marked by inserting all strings of R to its left and all strings of S to its right.",
        "The selected A strings themselves remain unchanged, along with the non-A segments.",
        "Construction: InitialMatch o Le ftToRight o LongestMatch o Insrtion Where:",
        "- Le ft ToRight",
        "The rest of the markup rules were not implemented since we could not obtain any documentation of their constructions.",
        "These operators are:",
        "Meaning: Directed markup.",
        "Instances of the language A on the upper side of the relation are selected for markup under left-to-right, shortest match regimen.",
        "Thus, the starting locations are selected from left-to-right.",
        "If there are overlapping instances of A starting at the same location, only the shortest one is replaced by all strings of B.",
        "Each selected A string is marked by inserting all strings of R to its left and all strings of S to its right.",
        "The selected A strings themselves remain unchanged, along with the non-A segments.",
        "Meaning: Directed markup.",
        "Instances of the language A on the upper side of the relation are selected for markup under right-to-left, longest match regimen.",
        "Thus, the starting locations are selected from right-to-left.",
        "If there are overlapping instances of A starting at the same location, only the longest one is replaced by all strings of B.",
        "Each selected A string is marked by inserting all strings of R to its left and all strings of S to its right.",
        "The selected A strings themselves remain unchanged, along with the non-A segments.",
        "Meaning: Directed markup.",
        "Instances of the language A on the upper side of the relation are selected for markup under right-to-left, shortest match regimen.",
        "Thus, the starting locations are selected from right-to-left.",
        "If there are overlapping instances of A starting at the same location, only the shortest one is replaced by all strings of B.",
        "Each selected A string is marked by inserting all strings of R to its left and all strings of S to its right.",
        "The selected A strings themselves remain unchanged, along with the non-A segments.",
        "A.6 Boundary symbol for restriction and replacement",
        "In the restriction, , and conditional replacement, @ @ , – > @, > @ expressions we can use a special boundary marker, .#., to refer to the beginning or to the end of a string.",
        "In the left context, the boundary marker signals the beginning of the string; in the right context it means the end of the string.",
        "Construction: We do not deal with all the cases where the boundary symbol # can be used.",
        "We only deal with boundary cases contexts that are in one of the following forms (LeftContext and RightContext are assumed not to contain # ):",
        "• .#.",
        "LeftContext -RightContext",
        "• [.#.",
        "LeftContext] .RightContext",
        "• [.#.]",
        "LeftContext -RightContext",
        "• LeftContext -RightContext .#.",
        "• LeftContext _ [RightContext .#.]",
        "• LeftContext -RightContext [.#.]",
        "• .#.",
        "LeftContext -RightContext .#.",
        "• [.#.",
        "LeftContext] -RightContext .#.",
        "• [.#.]",
        "LeftContext -RightContext .#.",
        "• [[.#.]",
        "LeftContext] -RightContext .#.",
        "As we do not deal with restriction rules we need to deal with boundary cases only in replace rules.",
        "The replace rules were constructed from six stages: InsertBrackets, ConstrainBrackets, LeftContext, RightCon-text, Replace and RemoveBrackets.",
        "In boundary cases where the left context is in the beginning of a string, only the LeftContext stage is changed.",
        "The LeftContext stage was defined as Le ftContext LEFT & LEFT where LEFT denoted concatenation and denoted",
        "The definition of LeftContext is not changed but the definition of [...LEFT] is changed into",
        "In boundary cases where the right context is at the end of a string, only the RightContext stage is changed.",
        "The RightContext stage was defined as where RIGHT denoted",
        "The definition of RightContext is not changed but the definition of [RIGHT...] is changed into",
        "In boundary cases where both the right context and the left context are at the end and in the beginning of a string respectively, both the RightContext and the LeftContext stages are changed as described above.",
        "The idea behind these changes is that the context part of replacement expression can be actually seen as ?",
        "* LEFT _ RIGHT ?",
        "* and by simply eliminating one of the ?",
        "* in one of the ends we can relate to a boundary case.",
        "The definitions that were changed above did exactly that: eliminated the appropriate ?",
        "* for each case.",
        "More complicated cases, for example a – > è 11 [.#.",
        "| a] _ should be dealt by conditional parallel replacement.",
        "For example, a – > è || [.#.",
        "| a] _, should be interpreted as",
        "Since we do not deal with conditional parallel replacement, we cannot deal with these cases.",
        "The following list defines the order of precedence of all XFST operators.",
        "Operators of same precedence are evaluated from left to right, except the prefix operators (~ \\ $ $?",
        "$.)",
        "that are evaluated from right to left.",
        "The list begins with the operators of highest precedence, i.e., with the most tightly binding ones.",
        "Operators of same precedence are on the same line.",
        "The following list defines the order of precedence in FSA:",
        "A.8 Advanced techniques",
        "Both XFST and FSA have advanced techniques that do no exist in the other toolbox.",
        "For XFST these techniques include Compile-Replace and Flag-Diacritics; for FSA these techniques include predicates and weighted networks."
      ]
    }
  ]
}
