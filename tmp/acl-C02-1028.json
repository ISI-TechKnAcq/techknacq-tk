{
  "info": {
    "authors": [
      "Eric Villemonte De La Clergerie"
    ],
    "book": "International Conference on Computational Linguistics",
    "id": "acl-C02-1028",
    "title": "Parsing Mildly Context-Sensitive Languages With Thread Automata",
    "url": "https://aclweb.org/anthology/C02-1028",
    "year": 2002
  },
  "references": [
    "acl-P92-1018"
  ],
  "sections": [
    {
      "heading": "Abstract",
      "text": [
        "We introduce simple but powerful automata, called Thread Automata, to describe a wide range of parsing strategies for Mildly Context-Sensitive languages.",
        "Thread Automata are completed by a Dynamic Programming interpretation ensuring that tabular parsing may be performed with polynomial worst-case complexity."
      ]
    },
    {
      "heading": "1 Introduction",
      "text": [
        "Mildly Context-Sensitive [MCS] formalisms form an (informal) class of formalisms presenting interesting linguistic and algorithmic properties (Weir, 1988).",
        "For instance, they include Tree Adjoining Grammars [TAG] (Joshi, 1987), and local Multi-Component TAG [MC-TAG] (Weir, 1988) where parse trees may be derived by combining elementary parse trees.",
        "MCS also include simple Range Concatenation Grammars [sRCG] (Boullier, 2000) where constraints on ranges of the input string specify linguistic constituents.",
        "A common characteristic of all these grammars is their ability to handle interleaved and discontinuous constituents, which seems important in order to handle linguistic phenomena such as topicalization, deep extraction, clitic movements or scrambling.",
        "MCS are also interesting from an algorithmic point of view because their associated languages may be parsed with polynomial worst-case complexities in both space and time.",
        "However, there is no unified framework to express and compare parsing algorithms for MCS.",
        "Furthermore, a parsing algorithm is often expressed for some underlying parsing strategy (generally a bottom-up strategy), making it difficult to adapt the algorithm for some other strategy.",
        "We introduce, in Section 2, a new kind of automata, namely thread automata [TA], that may be used to describe a wide range of parsing strategies for many MCS formalisms, including top-down prefix-valid [pv] strategies.",
        "As suggested by their name, the underlying intuition of TA is that several threads may be followed during parsing, with only one thread active at any time.",
        "A thread may start subthreads, may terminate, and may be suspended to return control either to its parent or to one of its direct descendants.",
        "Because a thread may be suspended and resumed several times, we can recognize interleaved discontinuous constituents by assigning a thread to a constituent.",
        "We illustrate these properties by explaining how to build TA encoding top-down pv strategies for TAG (Section 3) and ordered sRCG (Section 4).",
        "The interest of TA is not only descriptive but also algorithmic.",
        "Indeed, we present, in Section 5, a Dynamic Programming interpretation of TA that ensures polynomial worst-case complexities in time and space, w.r.t.",
        "the length n of the input string."
      ]
    },
    {
      "heading": "2 Thread Automata",
      "text": []
    },
    {
      "heading": "Formally, a Thread Automaton A is a tuple",
      "text": [
        "(N, Σ, S, F, κ, K, δ, U, Θ) where",
        "• Σ (resp.",
        "N) denotes a finite set of terminal (resp.",
        "non-terminal) symbols, with initial and final non-terminals S and F being two distinguished non-terminals, • The triggering function κ denotes a partial function from N to some finite set K and is used to capture the amount of information consulted in a thread to trigger the application of some kinds of transitions, 1 • U is a finite set of labels used to identify",
        "'This function is not essential but still useful to reduce complexity w.r.t.",
        "the grammar size, as illustrated for TAGs (Section 3).",
        "threads.",
        "U is also used by the partial function δ to drive computations by specifying the threads (subthreads or parents) that may be created or resumed at some point.",
        "U* is a (possibly empty) thread path, and A some non-terminal symbol from N. The empty path is denoted by E. We will usually confuse a thread with its path, speaking of thread p. A thread store S is a finite set of threads, representing a function from dom(S) to N where",
        "A TA configuration is a tuple (l, p, S) where l denotes the current position in the input string, p the active thread, and S a thread store with p ∈ dom(S).",
        "The initial configuration is cinit = (0, E, {E:S}) and the final one cfinal = (n, u, {E:S, u:F}) where u = δ(S) and n denotes the length of the input string.",
        "A derivation step c|τ c' is performed using a transition τ ∈ Θ of the following kind, where bracketed (resp.",
        "non-bracketed) parts denote contents of non active (resp.",
        "active) threads and κδ(A) being a shortcut for (κ(A), δ(A)): SWAP BHC : Changes the contents of the active thread, possibly scanning a terminal on the input string.",
        "(l, p, S ∪ p:B) |(l + |α|, p, S ∪ p:C) τ where al = α if α =7� E PUSH b −→ [b]C : Creates a new subthread, suspending its parent.",
        "(l, p, S ∪ p:B) |(l, pu, S ∪ p:B ∪ pu:C) τ where κδ(B) = (b, u) and pu ∈V dom(S) POP [B]C −→ D : Ends the active thread, returning control to its parent.",
        "(l, pu, S ∪ p:B ∪ pu:C) |(l, p, S ∪ p:C) τ where δ(C) = ⊥ and pu ∈V dom(S) SPUSH b[C] 1−→ [b]D : Resumes a suspended subthread of the active thread.",
        "where κδ(B) = (b, u)"
      ]
    },
    {
      "heading": "SPOP [B]c −→ D[c] : Resumes the parent",
      "text": [
        "thread of the active thread.",
        "The reflexive transitive closure of |- is noted |* and the transitive closure |+ Without restriction, a thread may be suspended infinitely many often, to return to its parent (⊥-suspension) or to a subthread v (v-suspension).",
        "We consider TA subclasses, namely h-TA, where a thread can be ⊥- suspended at most h times.",
        "A sufficient condition to ensure that A is an h-TA is to exhibit some mapping λ : N → {0,... , h} such that the following equations hold:",
        "0-TA are actually equivalent to Push-Down Automata, because SPUSH and SPOP transitions are no longer used and because we can assume |U |= 1, without any loss of generality.",
        "recognize a2b2c2 using threads 1 and 1.1 to recognize two crossing constituents abc (and thread 1.1.1 for the empty constituent EEE) ."
      ]
    },
    {
      "heading": "3 TAGS and TA",
      "text": []
    },
    {
      "heading": "A Tree Adjoining Grammar G = (N, Σ,I, A, S)",
      "text": [
        "(Joshi, 1987) is essentially characterized by elementary trees in T = I ∪ A which correspond to partial parse trees.",
        "The label l(ν) of a node ν is a non-terminal in N or a terminal in Σ (only on leaf nodes).",
        "New trees may be derived by substituting some initial tree α ∈ I at a leaf node ν, or",
        "by adjoining some auxiliary tree β ∈ A at node ν.",
        "Figure 2 shows an example of adjoining where β is inserted at node ν with the subtree rooted at ν inserted on the distinguished foot node f of β.",
        "To simplify this presentation and without generality loss, we assume that all nodes are either marked as non-adjoinable [NA] or as obligatory adjoinable [OA], leaf nodes being marked as NA.",
        "We suppose the reader familiar with the details about TAGS.",
        "As suggested by Figure 2, parsing TAG may be seen as traversing elementary trees (from left to right), using standard dotted nodes •ν, •ν, ν•, and ν• to specify which part of a tree has already been recognized.",
        "Using TA, we associate a thread to each tree traversal.",
        "When a substitution or an adjunction starts, a new thread is started (with PUSH transitions [SCALL] or [ACALL]).",
        "When a substitution or an ad-junction is completed, the associated thread is removed (with POP transitions [SRET] or [ARET]).",
        "More interestingly, the thread attached to an auxiliary tree is ⊥-suspended to return to the adjunction node when reaching the foot node (with SPOP transition [FCALL]) and resumed when coming back from the adjunction node to the foot node (with SPUSH transition [FRET]).",
        "Intuitively, a thread may only be ⊥-suspended once (to handle a foot node) and at most d direct subthreads of a thread may be alive at any time, where d denotes the maximal depth of elementary trees.",
        "More formally, we build the Thread Automaton AG = (NG, Σ, S, ret, κ,K, δ, U, Θ) :",
        "• NG = {Na, Ns |N ∈ N} ∪DG where DG denotes the minimal set of all dotted nodes for G modulo the equivalence relation identifying dotted nodes that actually correspond to a same computation point.2 • K = {Na, Ns |N ∈ N} ∪ {adj, foot} and U = {0,... , d} where d = maxt∈T depth(t) • κ and δ are defined as follows, where N =",
        "• Θ includes the following transitions,3 to handle",
        "ger function κ.",
        "For instance, without κ, [FCALL] becomes ['ν].f --> .ν[.f] referring to nodes from two different trees and leading to complexity in O(JG12), instead of O(IGI) otherwise.",
        "We express with κ that the triggering info for [FCALL] is to reach a foot node, its name being not pertinent.",
        "The automaton AG encodes a top-down pv parsing strategy for G. It also belongs to the 1-TA subclass (at most one ⊥-suspension), because of the mapping λ defined by λ('ν) =",
        "on the left of a spine (or in an initial tree);",
        "strictly on the right of a spine; λ('ν) = λ(ν') =",
        "By assigning a thread to a set of elementary trees and slightly extending the definition of δ, one can describe parsing strategies for tree-local or set-local Multi-Component TAG (Villemonte de la Clergerie, 2002)."
      ]
    },
    {
      "heading": "4 Ordered simple RCG",
      "text": [
        "Figure 3 illustrates the ordered simple RCG [osRCG] clause γ : A(X1X2X3X4, X5X6) −→ B(X1, X3, X5)C(X2, X4, X6) where range variables Xi are instantiated by ranges of the input string.",
        "A discontinuous constituent A is built from two discontinuous constituents B and C that interleave their ranges.",
        "The two parts of A are separated by a hole range H, inherited from some ancestor or sibling of A. OsRCG may typically be used to describe such phenomena of complex constituent interleaving.",
        "Actually, osRCG, like simple RCG, are equivalent to Linear Context-Free Rewriting systems (Weir, 1992), a very general class of MCS.",
        "More formally, a osRCG G = (N, Σ, V, C, S)",
        "where N0 is a non-terminal in N, −→αk = αk.1 ... αk.",
        "fk, and αk.i is a terminal in Σ or a range variable in V. We note ranges(γ) ="
      ]
    },
    {
      "heading": "2. The body literal Aj = Nj (Yj.1, ... , Yj.mj )",
      "text": [
        "where Nj is a non-terminal and Yj.l is a range variable.",
        "3.",
        "Each range variable X of γ has exactly two occurrences, one in the head literal (X = αk.i) and one in some body literal (X = Yj.l).",
        "We note k.i >γ j. l. 4.",
        "If a range variable X precedes a range variable Y (as argument) in some body literal, then X also precedes Y (as argument) in the head literal (total range ordering), i.e.",
        "We assume that each non-terminal N ∈ N has a fixed arity a(N).",
        "An instantiation σ from range variables X to ranges σ(X) = [l,r[ of the input string must satisfy (a) a concatenation constraint α = α1α2 with σ(α) = [l, s] if σ(α1) = [l, r[ and σ(α2) = [r, s[; and (b) a literal A = N(α1, ... , αa(N)) with σ(A) = (σ(α1),... ,σ(αa(N)) if its arguments αi are all satisfied.",
        "A literal A is derivable for σ if there exists a clause γ : A0 −→ A1,... , Am such that σ(A) = σ(A0), σ satisfies Ai i ≥ 0, and all Ai are derivable.",
        "We define the number �γ j of uncompleted constituents at Aj, i.e. started before Aj but",
        "Because the ranges occurring in a clause are ordered, it is relatively easy to describe a TA encoding a top-down left-to-right pv parsing strategy by traversing each range k.i in order, executing the action attached at k.i: create or resume a thread for some sub-constituent Aj, or resume the parent thread at holes.",
        "We build the Tread Automaton AG = (NG, Σ, S, ret, κ, K, δ, U, Θ)",
        "such that: • NG = N ∪ {ret} ∪ {γk.0, γk.i |γ ∈ C, k.i ∈",
        "ranges(γ)}, where γk.i are new symbols, denoting computation points and similar to dotted rules.",
        "• K = N ∪ {void} and U = {0,... , d}, where d = max γ, j #γ j denotes the maximal number of uncompleted body literals at some point in a clause.",
        "• κδ(γk.i) = (Nj, �γj) if k.i + 1 >γ j.1;",
        "(RET) [γk.i]ret H γk.i+1 if αk.i+1 is the last argument of some body literal in γ.",
        "(HOLE) void[γk.i] −→ [void]γk+1.0 if k.i is a ⊥-point, but not the last one.",
        "(COMP) [γk.i]void −→ γk.i+1 [void] if αk.i+1 is a range variable, not occurring as the last argument of a body literal.",
        "AG is an h-TA with h = a − 1 with a = maxNE,r a(N) denoting the maximal arity of a non terminal."
      ]
    },
    {
      "heading": "5 Dynamic Programming",
      "text": [
        "interpretation Directly applying transitions upon configurations would lead to exponential time complexity and even looping in many cases.",
        "Instead, we design a Dynamic Programming [DP] interpretation of TA that allows us to build tabular parsers running in polynomial complexity.",
        "We first identify a class of derivations, called escaped Context-Free derivations, that may be represented in a compact way using items.",
        "Then we show how these items may be combined together and with transitions to retrieve all possible derivations."
      ]
    },
    {
      "heading": "5.1 Escaped Context-Free derivations",
      "text": [
        "An escaped Context-Free [xCF] derivation D resumes all information relative to the active thread π of a given configuration, namely its starting point, its current ending point, and when it was suspended to return to its parent thread (⊥-suspension) or to some uncompleted subthread πv (v-suspension).",
        "For instance, Figure 4 shows an xCF derivation with π = pu created at S, with a ⊥-suspension between C and D, two v-suspensions (AB and GH), and a w-suspension (EF).",
        "Formally, D is characterized by (di)i=0 ... 2m+1 where di are sequences of transitions leading to",
        "and",
        "1.",
        "A new subthread π = p0u of the active thread p0 is created at c0 (π ∈�",
        "3.",
        "Each derivation c2i-1 |+ (l, p, S) |* c2i, i = 1... m, suspends p2i-1 = π and gives con",
        "trol to either ancestors (⊥-suspend) or descendants alive at c2m+1 (v-suspend)."
      ]
    },
    {
      "heading": "5.2 Items",
      "text": [
        "An item is a trace of a xCF derivation where we remove as much as possible useless information in order to increase computation sharing.",
        "In particular, we do not keep full configurations c = (l, p, S ∪ p:A) but only micro-configuration c = (l, A) or κ-micro-configuration cκ = (l, a)κ where a = κ(A).",
        "We will often simplify (l,a)κ into (l, a).",
        "Given an xCF derivation D, its projection D is defined by an item of the form c0κ/C/c2m+1 where C = v1 : S1 ... vi : Si ... vm : Sm, Si = c2i-1κc2iκ, and vi = v ∈ UL if c2i-1 |dzi c2i is a v-suspension.",
        "For instance, the item s/v : ab,⊥ : cd, w : ef, v : gh/I is associated to the xCF derivation of Fig. 4."
      ]
    },
    {
      "heading": "5.3 Application rules",
      "text": [
        "Combining transitions and items to build new items will generally involve two items I and J, I being related to a parent thread and J to some sub-thread u.",
        "Furthermore, either I prepares an extension of its son J by filling its ⊥-suspensions (down extension, Figure 5) or J prepares an extension of its parent I by filling its u-suspensions (up extension, Figure 6).",
        "To define formally these extensions, we need some auxiliary definitions.",
        "Given an item I = (l, a) /u 5 / (r, B), we define I' = (r, B), δ(I) = δ(B), and its index set ind(I) = {u ∈ U'|u = δ(I) ∧ ∃i, u = ui}.",
        "For u ∈ ind(I), we define its u-complement",
        "We can now define the up and down extension predicates when δ(I) = u and δ(J) = ⊥: J /Tu I ⇐⇒def J,_L =I�u J. I \\u J ⇐⇒def I u = J,1 I* Using these predicates, we easily specify how to combine transitions and items, as shown in"
      ]
    },
    {
      "heading": "5.4 Some results",
      "text": [
        "The DP interpretation is sound (for each derivable item I, there exists a derivable configuration c such that c = I')4 and complete (for each derivable configuration c, there exists a derivable item I such that c = I').",
        "The termination of the DP interpretation is ensured for h-TA, with naive worst-case complexities O(n2+2s) for space and O(n3+2s) for time, where s, bounded by h + dh, denotes the maximal number of suspensions occurring in items.",
        "Indeed, the number of ⊥-suspensions and of subthreads being bounded, the number of distinct items is also bounded.",
        "Space complexity comes from the number of possible distinct positions occurring in items.",
        "Time complexity is given by the number of distinct positions that are consulted when applying the application rules.",
        "For h = 0, we retrieve the worst-case complexities for CFG, namely O(n2) in space and O(n3) in time.",
        "For TAG (h = 1), we get O(n4+2d) in space and O(n5+2d) in time, where d denotes the maximal depth of elementary trees.",
        "These complexities are not optimal but correspond to those mentioned in (Eric Villemonte de la Clergerie, 2001) for a very similar parsing algorithm for TAG, based on 2-Stack Automata [2SA], and which seems to be efficient in practice for linguistic grammars.",
        "These worst-case complexities are upper estimations.",
        "A finer analysis gives, in many cases, complexities as low as O(n2+s) for space and O(n3+s) for time (Villemonte de la Clergerie, 2002)."
      ]
    },
    {
      "heading": "6 Conclusion",
      "text": [
        "The Thread Automata presented in this paper generalize and simplify various kinds of automata that have been previously proposed to parse MCS languages such as 2SA for TAGS.",
        "They may be used for a wide range of languages and parsing strategies.",
        "Their DP interpretation provides a uniform method to build tabular parsers for these languages, running in polynomial time, independently of the underlying parsing strategies.",
        "We should implement the DP interpretation for TA in a near future, extending TA to handle logic arguments.",
        "We would also like (a) to compare the formal power of TA w.r.t.",
        "other automata formalisms such as Tree-Walking Transducers (Weir, 1992) and (b) to investigate the descriptive power of TA for other linguistic formalisms.",
        "For instance, it does not seem possible to use TA in their current form to recognize the MIX language of strings having an equal number of each letter of some alphabet.",
        "The MIX language is an extreme case of scrambling but is conjectured not to be a MCS language."
      ]
    }
  ]
}
