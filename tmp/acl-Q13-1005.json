{
  "info": {
    "authors": [
      "Yoav Artzi",
      "Luke Zettlemoyer"
    ],
    "book": "TACL",
    "id": "acl-Q13-1005",
    "title": "Weakly Supervised Learning of Semantic Parsers for Mapping Instructions to Actions",
    "url": "https://aclweb.org/anthology/Q13-1005",
    "year": 2013
  },
  "references": [
    "acl-C92-4181",
    "acl-D07-1071",
    "acl-D10-1119",
    "acl-D11-1039",
    "acl-D11-1140",
    "acl-D12-1040",
    "acl-D12-1069",
    "acl-E12-1024",
    "acl-J07-4004",
    "acl-P06-1115",
    "acl-P07-1121",
    "acl-P09-1010",
    "acl-P09-1011",
    "acl-P10-1083",
    "acl-P10-1129",
    "acl-P11-1060",
    "acl-P11-1149",
    "acl-P12-1045",
    "acl-W04-3201",
    "acl-W10-2903"
  ],
  "sections": [
    {
      "heading": "Abstract",
      "text": [
        "The context in which language is used provides a strong signal for learning to recover its meaning.",
        "In this paper, we show it can be used within a grounded CCG semantic parsing approach that learns a joint model of meaning and context for interpreting and executing natural language instructions, using various types of weak supervision.",
        "The joint nature provides crucial benefits by allowing situated cues, such as the set of visible objects, to directly influence learning.",
        "It also enables algorithms that learn while executing instructions, for example by trying to replicate human actions.",
        "Experiments on a benchmark navigational dataset demonstrate strong performance under differing forms of supervision, including correctly executing 60% more instruction sets relative to the previous state of the art."
      ]
    },
    {
      "heading": "1 Introduction",
      "text": [
        "The context in which natural language is used provides a strong signal to reason about its meaning.",
        "However, using such a signal to automatically learn to understand unrestricted natural language remains a challenging, unsolved problem.",
        "For example, consider the instructions in Figure 1.",
        "Correct interpretation requires us to solve many sub-problems, such as resolving all referring expressions to specific objects in the environment (including, ?the corner?",
        "or ?the third intersection?",
        "), disambiguating word sense based on context (e.g., ?the chair?",
        "could refer to a chair or sofa), and finding executable action sequences that satisfy stated constraints (such as ?twice?",
        "or ?to face the blue hall?).",
        "move forward twice to the chair ?a.move(a) ?",
        "dir(a, forward) ?",
        "len(a, 2) ?",
        "to(a, ?x.chair(x)) at the corner turn left to face the blue hall ?a.pre(a, ?x.corner(x)) ?",
        "turn(a) ?",
        "dir(a, left) ?",
        "post(a, front(you, ?x.blue(x) ?",
        "hall(x))) move to the chair in the third intersection ?a.move(a) ?",
        "to(a, ?x.sofa(x)) ?",
        "intersect(order(?y.junction(y), frontdist, 3), x)",
        "We must also understand implicit requests, for example from the phrase ?at the corner,?",
        "that describe goals to be achieved without specifying the specific steps.",
        "Finally, to do all of this robustly without prohibitive engineering effort, we need grounded learning approaches that jointly reason about meaning and context to learn directly from their interplay, with as little human intervention as possible.",
        "Although many of these challenges have been studied separately, as we will review in Section 3, this paper represents, to the best of our knowledge, the first attempt at a comprehensive model that addresses them all.",
        "Our approach induces a weighted Combinatory Categorial Grammar (CCG), including both the parameters of the linear model and a CCG lexicon.",
        "To model complex instructional language, we introduce a new semantic modeling approach that can represent a number of key linguistic constructs that are common in spatial and instructional language.",
        "To learn from indirect supervision, we define the notion of a validation function, for example that tests the state of the agent after interpreting an instruction.",
        "We then show how this function can be used to drive online learning.",
        "For",
        "that purpose, we adapt the loss-sensitive Perceptron algorithm (Singh-Miller & Collins, 2007; Artzi & Zettlemoyer, 2011) to use a validation function and coarse-to-fine inference for lexical induction.",
        "The joint nature of this approach provides crucial benefits in that it allows situated cues, such as the set of visible objects, to directly influence parsing and learning.",
        "It also enables the model to be learned while executing instructions, for example by trying to replicate actions taken by humans.",
        "In particular, we show that, given only a small seed lexicon and a task-specific executor, we can induce high quality models for interpreting complex instructions.",
        "We evaluate the method on a benchmark navigational instructions dataset (MacMahon et al., 2006; Chen & Mooney, 2011).",
        "Our joint approach successfully completes 60% more instruction sets relative to the previous state of the art.",
        "We also report experiments that vary supervision type, finding that observing the final position of an instruction execution is nearly as informative as observing the entire path.",
        "Finally, we present improved results on a new version of the MacMahon et al. (2006) corpus, which we filtered to include only executable instructions paired with correct traces."
      ]
    },
    {
      "heading": "2 Technical Overview",
      "text": [
        "Task Let S be the set of possible environment states and A be the set of possible actions.",
        "Given a start state s ?",
        "S and a natural language instruction x, we aim to generate a sequence of actions ~a = ?a1, .",
        ".",
        ".",
        ", an?, with each ai ?",
        "A, that performs the steps described in x.",
        "For example, in the navigation domain (MacMahon et al., 2006), S is a set of positions on a map.",
        "Each state s = (x, y, o) is a triple, where x and y are integer grid coordinates and o ?",
        "{0, 90, 180, 270} is an orientation.",
        "Figure 2 shows an example map with 36 states; the ones we use in our experiments contain an average of 141.",
        "The space of possible actions A is {LEFT, RIGHT,MOVE, NULL}.",
        "Actions change the state of the world according to a transition function T : A ?",
        "S ?",
        "S. In our navigation example, moving forward can change the x or y coordinates while turning changes the orientation o.",
        "Model To map instructions to actions, we jointly reason about linguistic meaning and action execution.",
        "We use a weighted CCG grammar to rank possible meanings z for each instruction x.",
        "Section 6 defines how to design such grammars for instructional language.",
        "Each logical form z is mapped to a sequence of actions ~a with a deterministic executor, as described in Section 7.",
        "The final grounded CCG model, detailed in Section 6.3, jointly constructs and scores z and ~a, allowing for robust situated reasoning during semantic interpretation.",
        "Learning We assume access to a training set containing n examples {(xi, si,Vi) : i = 1 .",
        ".",
        ".",
        "n}, each containing a natural language sentence xi, a start state si, and a validation function Vi.",
        "The validation function Vi : A ?",
        "{0, 1} maps an action sequence ~a ?",
        "A to 1 if it's correct according to available supervision, or 0 otherwise.",
        "This training data contains no direct evidence about the logical form zi for each xi, or the grounded CCG analysis used to construct zi.",
        "We model all these choices as latent variables.",
        "We experiment with two validation functions.",
        "The first, VD(~a), has access to an observable demonstration of the execution ~ai, a given ~a is valid iff ~a = ~ai.",
        "The second, VSi (~a), only encodes the final state s?i of the execution of x, therefore ~a is valid iff its final state is s?i.",
        "Since numerous logical forms often execute identically, both functions provide highly ambiguous supervision.",
        "Evaluation We evaluate task completion for single instructions on a test set {(xi, si, s?i) : i = 1 .",
        ".",
        ".",
        "n}, where s?i is the final state of an oracle agent following the execution of xi starting at state si.",
        "We will also report accuracies for correctly interpreting instruction sequences ~x, where a single error can cause the entire sequence to fail.",
        "Finally, we report accuracy on recovering correct logical forms zi on a manually annotated subset of the test set."
      ]
    },
    {
      "heading": "3 Related Work",
      "text": [
        "Our learning is inspired by the reinforcement learning (RL) approach of Branavan et al. (2009), and related methods (Vogel & Jurafsky, 2010), but uses latent variable model updates within a semantic parser.",
        "Branavan et al. (2010) extended their RL approach to model high-level instructions, which correspond to implicit actions in our domain.",
        "Wei et al. (2009) and Kollar et al. (2010) used shallow linguistic representations for instructions.",
        "Recently, Tellex",
        "et al (2011) used a graphical model semantics representation to learn from instructions paired with demonstrations.",
        "In contrast, we model significantly more complex linguistic phenomena than these approaches, as required for the navigation domain.",
        "Other research has adopted expressive meaning representations, with differing learning approaches.",
        "Matuszek et al. (2010, 2012) describe supervised algorithms that learn semantic parsers for navigation instructions.",
        "Chen and Mooney (2011), Chen (2012) and Kim and Mooney (2012) present state-of-the-art algorithms for the navigation task, by training a supervised semantic parser from automatically induced labels.",
        "Our work differs in the use of joint learning and inference approaches.",
        "Supervised approaches for learning semantic parsers have received significant attention, e.g. Kate and Mooney (2006), Wong and Mooney (2007), Muresan (2011) and Kwiatkowski et al. (2010, 2012).",
        "The algorithms we develop in this paper combine ideas from previous supervised CCG learning work (Zettlemoyer & Collins, 2005, 2007; Kwiatkowski et al., 2011), as we describe in Section 4.",
        "Recently, various alternative forms of supervision were introduced.",
        "Clarke et al. (2010), Goldwasser and Roth (2011) and Liang et al. (2011) describe approaches for learning semantic parsers from sentences paired with responses, Krishna-murthy and Mitchell (2012) describe using distant supervision, Artzi and Zettlemoyer (2011) use weak supervision from conversational logs and Goldwasser et al. (2011) present work on unsupervised learning.",
        "We discuss various forms of supervision that complement these approaches.",
        "There has also been work on learning for semantic analysis tasks from grounded data, including event streams (Liang et al., 2009; Chen et al., 2010) and language paired with visual perception (Matuszek et al., 2012).",
        "Finally, the topic of executing instructions in non-learning settings has received significant attention (e.g., Winograd (1972), Di Eugenio and White (1992), Webber et al. (1995), Bugmann et al. (2004), MacMahon et al. (2006) and Dzifcak et al. (2009))."
      ]
    },
    {
      "heading": "4 Background",
      "text": [
        "We use a weighted linear CCG grammar for semantic parsing, as briefly reviewed in this section.",
        "Combinatory Categorial Grammars (CCGs) CCGs are a linguistically-motivated formalism for modeling a wide range of language phenomena (Steedman, 1996, 2000).",
        "A CCG is defined by a lexicon and a set of combinators.",
        "The lexicon contains entries that pair words or phrases with categories.",
        "For example, the lexical entry chair ` N : ?x.chair(x) for the word ?chair?",
        "in the parse in Figure 4 pairs it with a category that has syntactic type N and meaning ?x.chair(x).",
        "Figure 4 shows how a CCG parse builds a logical form for a complete sentence in our example navigation domain.",
        "Starting from lexical entries, each intermediate parse node, including syntax and semantics, is constructed with one of a small set of CCG combinators (Steedman, 1996, 2000).",
        "We use the application, composition and coordination combinators, and three others described in Section 6.3.",
        "Factored CCG Lexicons Recently, Kwiatkowski et al. (2011) introduced a factored CCG lexicon representation.",
        "Each lexical item is composed of a lexeme and a template.",
        "For example, the entry chair ` N : ?x.chair(x) would be constructed by combining the lexeme chair ` [chair], which contains a word paired with logical constants, with the template ?v.",
        "[N : ?x.v(x)], that defines the rest of the category by abstracting over logical constants.",
        "This approach allows the reuse of common syntactic structures through a small set of templates.",
        "Section 8 describes how we learn such lexical entries.",
        "Weighted Linear CCGs A weighted linear CCG (Clark & Curran, 2007) ranks the space of possible parses under the grammar, and is closely related to several other approaches (Lafferty et al., 2001; Collins, 2004; Taskar et al., 2004).",
        "Let x be a sentence, y be a CCG parse, and GEN(x; ?)",
        "be the set of all possible CCG parses for x given the lexicon ?.",
        "Define ?",
        "(x, y) ?",
        "Rd to be a d-dimensional feature?vector representation and ?",
        "?",
        "Rd to be a parameter vector.",
        "The optimal parse for sentence x is",
        "and the final output logical form z is the ?-calculus expression at the root of y?(x).",
        "Section 7.2 describes how we efficiently compute an approximation to y?",
        "(x) within the joint interpretation and execution model.",
        "Supervised learning with GENLEX Previous work (Zettlemoyer & Collins, 2005) introduced a function GENLEX(x, z) to map a sentence x and its meaning z to a large set of potential lexical entries.",
        "These entries are generated by rules that consider the logical form z and guess potential CCG categories.",
        "For example, the rule p ?",
        "N : ?x.p(x) introduces categories commonly used to model certain types of nouns.",
        "This rule would, for example, introduce the category N : ?x.chair(x) for any logical form z that contains the constant chair.",
        "GENLEX uses a small set of such rules to generate categories that are paired with all possible substrings in x, to create a large set of lexical entries.",
        "The complete learning algorithm then simultaneously selects a small subset of these entries and estimates parameter values ?.",
        "In Section 8, we will introduce a new way of using GENLEX to learn from different signals that, crucially, do not require a labeled logical form z."
      ]
    },
    {
      "heading": "5 Spatial Environment Modeling",
      "text": [
        "We will execute instructions in an environment, see Section 2, which has a set of positions.",
        "A position is a triple (x, y, o), where x and y are horizontal and vertical coordinates, and o ?",
        "O = {0, 90, 180, 270} is an orientation.",
        "A position also includes properties indicating the object it contains, its floor pattern and its wallpaper.",
        "For example, the square at (4, 3) in Figure 2 has four positions, one per orientation.",
        "Because instructional language refers to objects and other structures in an environment, we introduce the notion of a position set.",
        "For example, in Figure 2, the position set D = {(5, 3, o) : o ?",
        "O} represents a chair, while B = {(x, 3, o) : o ?",
        "O, x ?",
        "[0 .",
        ".",
        ".",
        "5]} represents the blue floor.",
        "Both sets contain all orientations for each (x, y) pair, thereby representing properties of regions.",
        "Position sets can have many properties.",
        "For example, E, in addition to being a chair, is also an intersection because it overlaps with the neighboring halls A and B.",
        "The set of possible entities includes all position sets and a few additional entries.",
        "For example, set C = {(4, 3, 90)} in"
      ]
    },
    {
      "heading": "6 Modeling Instructional Language",
      "text": [
        "We aim to design a semantic representation that is learnable, models grounded phenomena such as spa",
        "and example of semantics of spatial phrases.",
        "tial relations and object reference, and is executable.",
        "Our semantic representation combines ideas from Carpenter (1997) and Neo-Davidsonian event semantics (Parsons, 1990) in a simply typed ?- calculus.",
        "There are four basic types: (1) entities e that are objects in the world, (2) events ev that specify actions in the world, (3) truth values t, and (4) meta-entities m, such as numbers or directions.",
        "We also allow functional types, which are defined by input and output types.",
        "For example, ?e, t?",
        "is the type of function from entities to truth values."
      ]
    },
    {
      "heading": "6.1 Spatial Language Modeling Nouns and Noun Phrases Noun phrases are",
      "text": [
        "paired with e-type constants that name specific entities and nouns are mapped to ?e, t?-type expressions that define a property.",
        "For example, the noun ?chair?",
        "(Figure 2a) is paired with the expression ?x.chair(x), which defines the set of objects for",
        "which the constant chair returns true.",
        "The denotation of this expression is the set {D,E} in Figure 2 and the denotation of ?x.hall(x) (Figure 2b) is {A,B}.",
        "Also, the noun phrase ?you?",
        "(Figure 2d), which names the agent, is represented by the constant you with denotation C, the agent's position.",
        "Determiners Noun phrases can also be formed by combining nouns with determiners that pick out specific objects in the world.",
        "We consider both definite reference, which names contextually unique objects, and indefinites, which are less constrained.",
        "The definite article is paired with a logical expression ?",
        "of type ?",
        "?e, t?, e?,1 which will name a single object in the world.",
        "For example, the phrase ?the chair?",
        "in Figure 2c will be represented by ?x.chair(x) which will denote the appropriate chair.",
        "However, computing this denotation is challenging when there is perceptual ambiguity, for positions where multiple chairs are visible.",
        "We adopt a simple heuristic approach that ranks referents based on a combination of their distance from the agent and whether they are in front of it.",
        "For our example, from position C our agent would pick the chair E in front of it as the denotation.",
        "The approach differs from previous, non-grounded models that fail to name objects when faced with such ambiguity (e.g., Carpenter (1997), Heim and Kratzer (1998)).",
        "To model the meaning of indefinite articles, we depart from the Frege-Montague tradition of using existential quantifiers (Lewis, 1970; Montague, 1973; Barwise & Cooper, 1981), and instead introduce a new quantifier A that, like ?, has type ?",
        "?e, t?, e?.",
        "For example, the phrase ?a chair?",
        "would be paired with Ax.chair(x) which denotes an arbitrary entry from the set of chairs in the world.",
        "Computing the denotation for such expressions in a world will require picking a specific object, without further restrictions.",
        "This approach is closely related to Steedman's generalized Skolem terms (2011).2 Meta Entities We use m-typed terms to represent non-physical entities, such as numbers (1, 2, etc.)",
        "and directions (left, right, etc.)",
        "whose denotations 1Although quantifiers are logical constants with type ?",
        "?e, t?, e?",
        "or ?",
        "?e, t?, t?, we use a notation similar to that used for first-order logic.",
        "For example, the notation ?x.f(x) represents the logical expression ?",
        "(?x.f(x)) 2Steedman (2011) uses generalized Skolem terms as a tool for resolving anaphoric pronouns, which we do not model.",
        "are fixed.",
        "The ability to refer to directions allows us to manipulate position sets.",
        "For example, the phrase ?your left?",
        "is mapped to the logical expression orient(you, left), which denotes the position set containing the position to the left of the agent.",
        "Prepositions and Adjectives Noun phrases with modifiers, such as adjectives and prepositional phrases are ?e, t?-type expressions that implement set intersection with logical conjunctions.",
        "For example in Figure 2, the phrase ?blue hall?",
        "is paired with ?x.hall(x)?",
        "blue(x) with denotation {B} and the phrase ?chair in the intersection?",
        "is paired with ?x.chair(x) ?",
        "intersect(?y.junction(y), x) with denotation {E}.",
        "Intuitively, the adjective ?blue?",
        "introduces the constant blue and ?in the?",
        "adds a intersect.",
        "We will describe the full details of how these expressions are constructed in Section 6.3.",
        "Spatial Relations The semantic representation allows more complex reasoning over position sets and the relations between them.",
        "For example, the binary relation in front of (Figure 2g) tests if the first argument is in front of the second from the point of view of the agent.",
        "Additional relations are used to model set intersection, relative direction, relative distance, and relative position by distance."
      ]
    },
    {
      "heading": "6.2 Modeling Instructions",
      "text": [
        "To model actions in the world, we adopt Neo-Davidsonian event semantics (Davidson, 1967; Parsons, 1990), which treats events as ev-type primitive objects.",
        "Such an approach allows for a compact lexicon where adverbial modifiers introduce predicates, which are linked by a shared event argument.",
        "Instructional language is characterized by heavy usage of imperatives, which we model as functions from events to truth values.3 For example, an imperative such as ?move?",
        "would have the meaning ?a.move(a), which defines a set of events that match the specified constraints.",
        "Here, this set would include all events that involve moving actions.",
        "The denotation of ev-type terms is a sequence of n instances of the same action.",
        "In this way, an event defines a function ev : s ?",
        "s?, where s is the start state and s?",
        "the end state.",
        "For example, the 3Imperatives are ?ev, t?-type, much like ?e, t?-type wh-interrogatives.",
        "Both define sets, the former includes actions to execute, the later defines answers to a question.",
        "denotation of ?a.move(a) is the set of move action sequences {?MOVE1, .",
        ".",
        ".",
        ",MOVEn?",
        ": n ?",
        "1}.",
        "Although performing actions often require performing additional ones (e.g., the agent might have to turn before being able to move), we treat such actions as implicit (Section 7.1), and don't model them explicitly within the logical form.",
        "Predicates such as move (seen above) and turn are introduced by verbs.",
        "Events can also be modified by adverbials, which are intersective, much like prepositional phrases.",
        "For example in the imperative, logical form (LF) pair: Imp.",
        ": move from the sofa to the chair LF: ?a.move(a) ?",
        "to(a, ?x.chair(x)) ?",
        "from(a, ?y.sofa(y)) Each adverbial phrase provides a constraint, and changing their order will not change the LF."
      ]
    },
    {
      "heading": "6.3 Parsing Instructional Language with CCG",
      "text": [
        "To compose logical expressions from sentences we use CCG, as described in Section 4.",
        "Figures 3 and 4 present a sample of lexical entries and how they are combined, as we will describe in this section.",
        "The basic syntactic categories are N (noun), NP (noun phrase), S (sentence), PP (prepositional phrase), AP (adverbial phrase), ADJ (adjective) and C (a special category for coordinators).",
        "Type Raising To compactly model syntactic variations, we follow Carpenter (1997), who argues for polymorphic typing.",
        "We include the more simple, or lower type, entry in the lexicon and introduce type-raising rules to reconstruct the other when necessary at parse time.",
        "We use four rules:",
        "where the first three are for prepositional, adjectival and adverbial modifications, and the fourth models the fact that adverbials are often topicalized.4 Figures 3 and 4 show parses that use type-raising rules.",
        "Indefinites As discussed in Section 6.1, we use a new syntactic analysis for indefinites, follow-4Using type-raising rules can be particularly useful when learning from sparse data.",
        "For example, it will no longer be necessary to learn three lexical entries for each adverbial phrase (with syntax AP , S\\S, and S/S).",
        "chair in the corner",
        "where ?a?",
        "has the relatively complex syntactic category PP\\(PP/NP )/N and where similar entries would be needed to quantify over different types of verbs (e.g., S\\(S/NP )/N ) and adverbials (e.g., AP\\(AP/NP )/N ).",
        "Instead, we include a single lexical entry a ` NP/N : ?f.Ax.f(x) which can be used to construct the correct meaning in all cases."
      ]
    },
    {
      "heading": "7 Joint Parsing and Execution",
      "text": [
        "Our inference includes an execution component and a parser.",
        "The parser maps sentences to logical forms, and incorporates the grounded execution model.",
        "We first discuss how to execute logical forms, and then describe the joint model for execution and parsing."
      ]
    },
    {
      "heading": "7.1 Executing Logical Expressions",
      "text": [
        "Dynamic Models In spatial environments, such as the ones in our task, the agent's ability to observe the world depends on its current state.",
        "Taking this aspect of spatial environments into account is challenging, but crucial for correct evaluation.",
        "To represent the agent's point of view, for each state s ?",
        "S, as defined in Section 2, let Ms be the state-dependent logical model.",
        "A model M consists of a domain DM,T of objects for each type T and an interpretation function IM,T : OT ?",
        "DM,T , where OT is the set of T type constants.",
        "IM,T maps logical symbols to T type objects, for example, it will map you to the agent's position.",
        "We have domains for position sets, actions and so on.",
        "Finally, let VT be the set of variables of type T , and",
        "facing the lamp go until you reach a chair",
        "tion, which maps variables to domain objects.",
        "For each model Ms the domain DMs,ev is a set of action sequences {?a1, ..., an?",
        ": n ?",
        "1}.",
        "Each ~a defines a sequences of states si, as defined in Section 6.2, and associated models Msi .",
        "The key challenge for execution is that modifiers of the event will need to be evaluated under different models from this sequence.",
        "For example, consider the sentence in Figure 4.",
        "To correctly execute, the pre literal, introduced by the ?facing?",
        "phrase, it must be evaluated in the model Ms0 for the initial state s0.",
        "Similarly, the literal including post requires the final model Msn+1 .",
        "Such state dependent predicates, including pre and post, are called stateful.",
        "The list of stateful predicates is predefined and includes event modifiers, as well the ?",
        "quantifier, which is evaluated under Ms0 , since definite determiners are assumed to name objects visible from the start position.",
        "In general, a logical expression is traversed depth first and the model is updated every time a stateful predicate is reached.",
        "For example, the two e-type you constants in Figure 4 will be evaluated under different models: the one within the pre literal under Ms0 , and the one inside the post literal under Msn+1 .",
        "Evaluation Given a logical expression l, we can compute the interpretation IMs0 ,T (l) by recursivelymapping each subexpression to an entry on the appropriate model M .",
        "To reflect the changing state of the agent during evaluation, we define the function update(~a, pred).",
        "Given an action sequence ~a and a stateful predicate pred, update returns a model Ms, where s is the state under which the literal containing pred should be interpreted, either the initial state or one visited while executing ~a.",
        "For example, given the predicate post and the action sequence ?a1, .",
        ".",
        ".",
        ", an?, update(?a1, .",
        ".",
        ".",
        ", an?, post) = Msn+1 , where sn+1 the state of the agent following action an.",
        "By convention, we place the event variable as the first argument in literals that include one.",
        "Given a T type logical expression l and a starting state s0, we compute its interpretation IMs0 ,T (l)recursively, following these three base cases: ?",
        "If l is a ?",
        "operator of type ?T1, T2?",
        "binding variable v and body b, IMs,T (l) is a set of pairs from DT1 ?DT2 , where DT1 , DT2 ?",
        "Ms. For each object o ?",
        "DT1 , we create a pair (o, i) where i is the interpretation IMs,T2(b) computed under a variable assignment function extended to map AT2(v) = o. ?",
        "If l is a literal c(c1, .",
        ".",
        ".",
        ", cn) with n arguments where c has type P and each ci has type Pi, IMs,T (l) is computed by first interpreting the predicate c to the function",
        "is a stateful predicate, such as pre or post, we instead first retrieve the appropriate new model Ms?",
        "= update(IMs,P1(c1), c), where c1 is the event argument and IMs,P1(c1) is its interpretation.",
        "Then, the final results is IMs,T (l) = f(IMs?",
        ",P1(c1), .",
        ".",
        ".",
        ", IMs?",
        ",Pn(cn)).",
        "?",
        "If l is a T type constant or variable, IMs,T (l).",
        "The worst case complexity of the process is exponential in the number of bound variables.",
        "Although in practice we observed tractable evaluation in the majority of development cases we considered, a more comprehensive and tractable evaluation procedure is an issue that we leave for future work.",
        "Implicit Actions Instructional language rarely specifies every action required for execution, see MacMahon (2007) for a detailed discussion in the maps domain.",
        "For example, the sentence in Figure 4 can be said even if the agent is not facing a blue hallway, with the clear implicit request that it should turn to face such a hallway before moving.",
        "To allow our agent to perform implicit actions, we extend the domain of ev-type variables by allowing the agent to prefix up to kI action sequences before each explicit event.",
        "For example, in the agent's position in Figure 2 (set C), the set of possible events includes ?MOVEI ,MOVEI , RIGHTI ,MOVE?, which contains two implicit sequences (marked by I)."
      ]
    },
    {
      "heading": "Resolving Action Ambiguity Logical forms of",
      "text": [
        "ten fail to determine a unique action sequences, due to instruction ambiguity.",
        "For example, consider the instruction ?go forward?",
        "and the agent state as specified in Figure 2 (set C).",
        "The instruction, which maps to ?a.move(a) ?",
        "forward(a), evaluates to the set containing ?MOVE?, ?MOVE,MOVE?",
        "and ?MOVE,MOVE,MOVE?, as well as five other sequences that have implicit prefixes followed by explicit MOVE actions.",
        "To resolve such ambiguity, we prefer shorter actions without implicit actions.",
        "In the example above, we will select ?MOVE?, which includes a single action and no implicit actions."
      ]
    },
    {
      "heading": "7.2 Joint Inference",
      "text": [
        "We incorporate the execution procedure described above with a linear weighted CCG parser, as described in Section 4, to create a joint model of parsing and execution.",
        "Specifically, we execute logical forms in the current state and observe the result of their execution.",
        "For example, the word ?chair?",
        "can be used to refer to different types of objects, including chairs, sofas, and barstools, in the maps domains.",
        "Our CCG grammar would include a lexical item for each meaning, but execution might fail depending on the presence of objects in the world, influencing the final parse output.",
        "Similarly, allowing implicit actions provides robustness when resolving these and other ambiguities.",
        "For example, an instruction with the precondition phrase ?from the chair?",
        "might require additional actions to reach the position with the named object.",
        "To allow such joint reasoning we define an execution e to include a parse tree ey and trace e~a, and define our feature function to be ?",
        "(xi, si, e), where xi is an instruction and si is the start state.",
        "This approach allows joint dependencies: the state of the world influences how the agent interprets words, phrases and even complete sentences, while language understanding determines actions.",
        "Finally, to execute sequences of instructions, we execute each starting from the end state of the previous one, using a beam of size ks."
      ]
    },
    {
      "heading": "8 Learning",
      "text": [
        "Figure 5 presents the complete learning algorithm.",
        "Our approach is online, considering each example in turn and performing two steps: expanding the lexicon and updating parameters.",
        "The algorithm assumes access to a training set {(xi, si,Vi) : i = 1 .",
        ".",
        ".",
        "n}, where each example includes an instruction xi, starting state si and a validation function Vi, as defined in Section 2.",
        "In addition the algorithm takes a seed lexicon ?0.",
        "The output is a joint model, that includes a lexicon ?",
        "and parameters ?.",
        "Coarse Lexical Generation To generate potential lexical entries we use the function GENLEX(x, s,V; ?, ?",
        "), where x is an instruction, s is a state and V is a validation function.",
        "?",
        "is the current lexicon and ?",
        "is a parameter vector.",
        "In GENLEX we use coarse logical constants, as described below, to efficiently prune the set of potential lexical entries.",
        "This set is then pruned further using more precise inference in Step 1.",
        "To compute GENLEX , we initially generate a large set of lexical entries and then prune most of them.",
        "The full set is generated by taking the cross product of a set of templates, computed by factoring out all templates in the seed lexicon ?0, and all logical constants.",
        "For example, if ?0 has a lexical item with the categoryAP/NP : ?x.",
        "?a.to(a, x) we would create entries w ` AP/NP : ?x.",
        "?a.p(a, x) for every phrase w in x and all constants p with the same type as to.5 In our development work, this approach often generated nearly 100k entries per sentence.",
        "To ease 5Generalizing previous work (Kwiatkowski et al., 2011), we allow templates that abstract subsets of the constants in a lexical item.",
        "For example, the seed entry facing ` AP/NP : ?x.",
        "?a.pre(a, front(you, x)) would create 7 templates.",
        "Inputs: Training set {(xi, si,Vi) : i = 1 .",
        ".",
        ".",
        "n} where xi is a sentence, si is a state and Vi is a validation function, as described in Section 2.",
        "Initial lexicon ?0.",
        "Number of iterations T .",
        "Margin ?.",
        "Beam size k for lexicon generation.",
        "Definitions: Let an execution e include a parse tree ey and a trace e~a.",
        "GEN(x, s; ?)",
        "is the set of all possible executions for the instruction x and state s, given the lexicon ?.",
        "LEX(y) is the set of lexical entries used in the parse tree y.",
        "Let ?i(e) be shorthand for the feature function ?",
        "(xi, si, e) defined in Section 7.2.",
        "Define ?i(e, e?)",
        "= |?i(e)??i(e?)|1.",
        "GENLEX(x, s,V;?, ?)",
        "takes as input an instruction x, state s, validation function V , lexicon ?",
        "and model parameters ?, and returns a set of lexical entries, as defined in Section 8.",
        "Finally, for a set of executions E let MAXVi(E; ?)",
        "be {e|?e?",
        "?",
        "E, ??,?i(e?)?",
        "?",
        "??,?i(e)?",
        "?",
        "Vi(e~a) = 1}, the set of highest scoring valid executions.",
        "a.",
        "Set ?G ?",
        "GENLEX(xi, si,Vi; ?, ?",
        "), ??",
        "?",
        "?",
        "?G b.",
        "Let E be the k highest scoring executions from GEN(xi, si;?)",
        "which use at most one entry from ?G c. Select lexical entries from the highest scoring valid parses: ?i ?",
        "?e?MAXVi(E;?)",
        "LEX(ey)d. Update lexicon: ??",
        "?",
        "?",
        "?i Step 2: (Update parameters) a.",
        "Set Gi ?MAXVi(GEN(xi, si; ?",
        "); ?)",
        "and Bi ?",
        "{e|e ?",
        "GEN(xi, si; ?)",
        "?",
        "Vi(e~a) 6= 1} b. Construct sets of margin violating good and bad parses:",
        "the cost of parsing at this scale, we developed a coarse-to-fine two-pass parsing approach that limits the number of new entries considered.",
        "The algorithm first parses with coarse lexical entries that abstract the identities of the logical constants in their logical forms, thereby greatly reducing the search space.",
        "It then uses the highest scoring coarse parses to constrain the lexical entries for a final, fine parse.",
        "Formally, we construct the coarse lexicon ?a by replacing all constants of the same type with a single newly created, temporary constant.",
        "We then parse to create a set of trees A, such that each y ?",
        "A 1. is a parse for sentence x, given the world state s with the combined lexicon ?",
        "?",
        "?a, 2. scored higher than ey by at least a margin of ?L, where ey is the tree of e, the highest scoring execution of x, at position s under the current model, s.t.",
        "V(e~a) = 1, 3. contains at most one entry from ?a.",
        "Finally, from each entry l ?",
        "{l|l ?",
        "?a ?",
        "l ?",
        "y ?",
        "y ?",
        "A}, we create multiple lexical entries by replacing all temporary constants with all possible appropriately typed constants from the original set.",
        "GENLEX returns all these lexical entries, which will be used to form our final fine-level analysis.",
        "Step 1: Lexical Induction To expand our model's lexicon, we use GENLEX to generate candidate lexical entries and then further refine this set by parsing with the current model.",
        "Step 1(a) in Figure 5 uses GENLEX to create a temporary set of potential lexical entries ?G.",
        "Steps (b-d) select a small subset of these lexical entries to add to the current lexicon ?",
        ": we find the k-best executions under the model, which use at most one entry from ?G, find the entries used in the best valid executions and add them to the current lexicon.",
        "Step 2: Parameter Update We use a variant of a loss-driven perceptron (Singh-Miller & Collins, 2007; Artzi & Zettlemoyer, 2011) for parameter updates.",
        "However, instead of taking advantage of a loss function we use a validation signal.",
        "In step (a) we collect the highest scoring valid parses and all invalid parses.",
        "Then, in step (b) we construct the set Ri of valid analyses and Ei of invalid ones, such that their model scores are not separated by a margin ?",
        "scaled by the number of wrong features (Taskar et al., 2003).",
        "Finally, step (f) applies the update.",
        "Discussion The algorithm uses the validation signal to drive both lexical induction and parameter updates.",
        "Unlike previous work (Zettlemoyer & Collins, 2005, 2007; Artzi & Zettlemoyer, 2011), we have no access to a set of logical constants, either through the the labeled logical form or the weak supervision signal, to guide the GENLEX procedure.",
        "Therefore, to avoid over-generating lexical entries, thereby making parsing and learning intractable, we leverage typing for coarse parsing to prune the generated set.",
        "By allowing a single",
        "new entry per parse, we create a conservative, cascading effect, whereas a lexical entry that is introduced opens the way for many other sentence to be parsed and introduce new lexical entries.",
        "Furthermore, grounded features improve parse selection, thereby generating higher quality lexical entries."
      ]
    },
    {
      "heading": "9 Experimental Setup",
      "text": [
        "Data For evaluation, we use the navigation task from MacMahon et al. (2006), which includes three environments and the SAIL corpus of instructions and follower traces.",
        "Chen and Mooney (2011) segmented the data, aligned traces to instructions, and merged traces created by different subjects.",
        "The corpus includes raw sentences, without any form of linguistic annotation.",
        "The original collection process (MacMahon et al., 2006) created many uninterpretable instructions and incorrect traces.",
        "To focus on the learning and interpretation tasks, we also created a new dataset that includes only accurate instructions labeled with a single, correct execution trace.",
        "From this oracle corpus, we randomly sampled 164 instruction sequences (816 sentences) for evaluation, leaving 337 (1863 sentences) for training.",
        "This simple effort will allow us to measure the effects of noise on the learning approach and provides a resource for building more accurate algorithms.",
        "Table 1 compares the two sets.",
        "Features and Parser Following Zettlemoyer and Collins (2005), we use a CKY parser with a beam of k. To boost recall, we adopt a two-pass strategy, which allows for word skipping if the initial parse fails.",
        "We use features that indicate usage of lexical entries, templates, lexemes and type-raising rules, as described in Section 6.3, and repetitions in logical coordinations.",
        "Finally, during joint parsing, we consider only parses executable at si as complete.",
        "Seed Lexicon To construct our seed lexicon we labeled 12 instruction sequences with 141 lexical en",
        "standard deviation on the oracle corpus.",
        "tries.",
        "The sequences were randomly selected from the training set, so as to include two sequences for each participant in the original experiment.",
        "Figures 3 and 4 include a sample of our seed lexicon.",
        "Initialization and Parameters We set the weight of each template indicator feature to the number of times it is used in the seed lexicon and each repetition feature to -10.",
        "Learning parameters were tuned using cross-validation on the training set: the margin ?",
        "is set to 1, the GENLEX margin ?L is set to 2, we use 6 iterations (8 for experiments on SAIL) and take the 250 top parses during lexical generation (step 1, Figure 5).",
        "For parameter update (step 2, Figure 5) we use a parser with a beam of 100.",
        "GENLEX generates lexical entries for token sequences up to length 4. ks, the instruction sequence execution beam, is set to 10.",
        "Finally, kI is set to 2, allowing up to two implicit action sequences per explicit one.",
        "Evaluation Metrics To evaluate single instructions x, we compare the agent's end state to a labeled state s?, as described in Section 2.",
        "We use a similar method to evaluate the execution of instruction sequences ~x, but disregard the orientation, since end goals in MacMahon et al. (2006) are defined without orientation.",
        "When evaluating logical forms we measure exact match accuracy."
      ]
    },
    {
      "heading": "10 Results",
      "text": [
        "We repeated each experiment five times, shuffling the training set between runs.",
        "For the development cross-validation runs, we also shuffled the folds.",
        "As our learning approach is online, this allows us to account for performance variations arising from training set ordering.",
        "We report mean accuracy and standard deviation across all runs (and all folds).",
        "viation for the SAIL corpus.",
        "Table 2 shows accuracy for 5-fold cross-validation on the oracle training data.",
        "We first varied the validation signal by providing the complete action sequence or the final state only, as described in Section 2.",
        "Although the final state signal is weaker, the results are similar.",
        "The relatively large difference between single sentence and sequence performance is due to (1) cascading errors in the more difficult task of sequential execution, and (2) corpus repetitions, where simple sentences are common (e.g., ?turn left?).",
        "Next, we disabled the system's ability to introduce implicit actions, which was especially harmful to the full sequence performance.",
        "Finally, ablating the joint execution decreases performance, showing the benefit of the joint model.",
        "Table 3 lists cross validation results on the SAIL corpus.",
        "To compare to previous work (Chen & Mooney, 2011), we report cross-validation results over the three maps.",
        "The approach was able to correctly execute 60% more sequences then the previous state of the art (Kim & Mooney, 2012).",
        "We also outperform the results of Chen (2012), which used 30% more training data.6 Using the weaker validation signal creates a marginal decrease in performance.",
        "However, we still outperform all previous work, despite using weaker supervision.",
        "Interestingly, these increases were achieved with a relatively simple executor, while previous work used MARCO (MacMahon et al., 2006), which supports sophisticated recovery strategies.",
        "Finally, we evaluate our approach on the held out test set for the oracle corpus (Table 4).",
        "In contrast to experiments on the Chen and Mooney (2011) corpus, we use a held out set for evaluation.",
        "Due to this discrepancy, all development was done on the training set only.",
        "The increase in accuracy over learning with the original corpus demonstrates the significant impact of noise on our performance.",
        "In addition to",
        "deviation results.",
        "execution results, we also report exact match logical form (LF) accuracy results.",
        "For this purpose, we annotated 18 instruction sequences (105 sentences) with logical forms.",
        "The gap between execution and LF accuracy can be attributed to the complexity of the linguistic representation and redundancy in instructions.",
        "These results provide a new baseline for studying learning from cleaner supervision."
      ]
    },
    {
      "heading": "11 Discussion",
      "text": [
        "We showed how to do grounded learning of a CCG semantic parser that includes a joint model of meaning and context for executing natural language instructions.",
        "The joint nature allows situated cues to directly influence parsing and also enables algorithms that learn while executing instructions.",
        "This style of algorithm, especially when using the weaker end state validation, is closely related to reinforcement learning approaches (Branavan et al., 2009, 2010).",
        "However, we differ on optimization and objective function, where we aim for minimal loss.",
        "We expect many RL techniques to be useful to scale to more complex environments, including sampling actions and using an exploration strategy.",
        "We also designed a semantic representation to closely match the linguistic structure of instructional language, combining ideas from many semantic theories, including, for example, Neo-Davidsonian events (Parsons, 1990).",
        "This approach allowed us to learn a compact and executable grammar that generalized well.",
        "We expect, in future work, that such modeling can be reused for more general language."
      ]
    },
    {
      "heading": "Acknowledgments",
      "text": [
        "The research was supported in part by DARPA under the DEFT program through the AFRL (FA875013-2-0019) and the CSSG (N11AP20020), the ARO (W911NF-12-1-0197), and the NSF (IIS-1115966).",
        "The authors thank Tom Kwiatkowski, Nicholas FitzGerald and Alan Ritter for helpful discussions, David Chen for providing the evaluation corpus, and the anonymous reviewers for helpful comments."
      ]
    }
  ]
}
