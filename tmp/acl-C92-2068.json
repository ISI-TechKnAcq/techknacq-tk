{
  "info": {
    "authors": [
      "Hideto Tomabechi"
    ],
    "book": "International Conference on Computational Linguistics",
    "id": "acl-C92-2068",
    "title": "Quasi-Destructive Graph Unification With Structure-Sharing",
    "url": "https://aclweb.org/anthology/C92-2068",
    "year": 1992
  },
  "references": [
    "acl-C90-2039",
    "acl-J92-4004",
    "acl-P85-1017",
    "acl-P91-1041",
    "acl-P91-1042"
  ],
  "sections": [
    {
      "heading": "Abstract",
      "text": [
        "Graph unification remains the most expensive part of unification-based grammar parsing.",
        "We focus on one speed-up element in the design of unification algorithms: avoidance of copying of unmodified subgraphs.",
        "We propose a method of attaining such a design through a method of structure-sharing which avoids log(d) overheads often associated with structure-sharing of graphs without any use of costly dependency pointers.",
        "The proposed scheme eliminates redundant copying while maintaining the quasi-destructive scheme's ability to avoid over copying and early copying combined with its ability to handle cyclic structures without algorithmic additions."
      ]
    },
    {
      "heading": "1 Motivation",
      "text": [
        "Despite recent efforts in improving graph unification algorithms.",
        "graph unification remains the most expensive part of parsing, both in time and space.",
        "ATR's latest data from the SL-TRANS large-scale speech-to-speech translation project ([Morimoto, et al., 1990]) show 80 to 90 percent of total parsing time is still consumed by graph unification where 75 to 95 percent of time is consumed by graph copying func-tions.'",
        "Quasi-Destructive (Q-D) Graph Unification ([Tomabechi, 1991]) was developed as a fast variation of non-destructive graph unification based upon the notion of time-sensitive 'quasi-destruction' of node structures.",
        "The Q-D algorithm was proposed based upon the following accepted observation about graph unification: Unification does not always succeed.",
        "Copying is an expensive operation.",
        "The design of the Q-D scheme was motivated by the following two principles for fast graph unification based upon the above observations:",
        "• Copying should be performed only for successful unifications.",
        "• Unification failures should be found as soon as possible.",
        "graph unification.",
        "Similar data reportml in IKogure.",
        "19901. and eliminated Over Copying and Early Copying (as defined in [Tomabechi.",
        "1991]) and ran about twice the speed of [Wroblewski.",
        "19871's algorithm.3 In this paper we propose another design principle for graph unification based upon yet.",
        "another accepted observation that: Unmodified subgraphs can be shared.",
        "At least two schemes have been proposed recently based upon this observation (namely [Kogure.",
        "1990] and [Einele, 1991]); however, both schemes are based upon the incremental copying scheme and as described in [Tomabechi, 1991] incremental copying schemes inherently stiffer from Early Copying as defined in that article.",
        "This is because, when a unification fails, the copies that were created up to the point of failure are wasted if copies are created incrementally.",
        "By way of definition we would like to categorize the sharing of structures in graphs into Feature-Structure Sharing (FS-Sharing) and Data-Structure Sharing (DS-Sharing).",
        "Below are our definitions:",
        "• Feature-Structure Sharing: Two or more distinct paths within a graph share the sante sub-graph by converging on the same node - equivalent to the notion of structure sharing or reentrancy in linguistic theories (such as in [Pollard and Sag, 1987]).",
        "• Data-Structure Sharing: Two or more distinct graphs share the same subgraph by converging on the same node - the notion of 2 Namely.",
        "• Over Copying: Two lags are created in order to create one new dag.",
        "This typically happens when copies of two input dugs are created prior to a destructive unification operation to build one new dag.",
        "• Early Copying: Copies are created prior to the failure of unification so that copies created since the beginning of the unification up to the point of failure are wasted.",
        "Wroblewski defined Early Copying as follows: \"The argument lags are copied before unification started.",
        "If the unification fails then some of the copying is wasted effort\" and restricts early copying to cases that only apply to copies that are created prior to a miification.",
        "Our definition of Early Copying includes collies that are created during a unification and created up to the point of failure which were uncovered by Wroblewski's definition.",
        "'Recent experiments conducted in the Knowledge and Data Processing Dept.",
        "of ATE.",
        "shows the original Q-D algorithms consistently runs at about 40 percent of the elapsed time of Wroblewski's algorithm with its 11,-TRANS large-scale spoken-language translation system (with over 10.000 grammatical graph nodes).",
        "strueture-sharing at.",
        "the data structure level.",
        "[Kogure, 19901 calls copying of such structures Redundant Copying.",
        "Virtually all graph-unification algorithms support FS-Sharing and some support.",
        "DS-Sharing with varying levels of overhead.",
        "In this paper we propose a scheme of graph unification based upon a quasi-destructive graph unification method that attains DS-Sharing with virtually no overhead for structure-sharing.",
        "Henceforth, in this paper.",
        "structure-sharing refers to DS-sharing unless otherwise noted.",
        "We will see that the introduction of structure-sharing to quasi-destructive unification attains another twofold increase in run-tine speed.",
        "The graphs handled the scheme can be any directed graph and cyclicity is handled without any algorithmic additions.",
        "Our design principles for achieving structure-sharing in the quasi-destructive scheme are:",
        "• Atomic and Bottom nodes can be shared< Atomic nodes can be shared safely since they never change their values.",
        "Bottom nodes can be shared' since bottom nodes are always forwarded to sonic other nodes when they unify.",
        "• Complex nodes can he shared unless they are modified - complex nodes can be considered modified if they are a target of the forwarding operation or if they received the current addition of complement arcs (into comp-arc-list in quasi-destructive scheme).",
        "By designing an algorithm based upon these principles for structure-sharing while retaining the quasi-destructive nature of [Tomabechi, 19911's algorithm, our scheme eliminates Redundant Copying while eliminating both Early Copying and Over Copying."
      ]
    },
    {
      "heading": "2 Q-D Graph Unification",
      "text": [
        "We would first like to describe the quasi-destructive (Q-D) graph unification scheme which is the basis of our scheme.",
        "As a data structure, a node is represented with five fields: type, arc-list, comp-arc-list.",
        "forward, copy, and generation.< The data-structure for an arc has two fields, 'label' and 'value'.",
        "'Label' is an atomic symbol which labels the arc, and 'value' is a pointer to a node structure.",
        "The central notion of the Q-D algorithm is the dependency of the representational content on the global timing clock (or the global counter for the current generation of unifications).",
        "Any modification made to comp-arc-list, forward, or copy fields during one top-level unification can be invalidated by one increment operation on the global timing counter.",
        "Contents of the comp-arc-list, forward and copy fields are 'Atomic nodes aro nodes that represent atomic values, bottom nodes are nodes that represent variabloi.",
        "'As long as the unification operation is the only operation to modify graphs.",
        "Q-D graph unification has two kinds of arc lists: 1) arc-list and 2) comp-arc-list.",
        "Arc-list contains the arcs that are permanent (i.e.. ordinary graph arcs) and comp-arc-list contains arcs that are only valid during one top-level graph unification operation.",
        "The algorithm also uses two kinds of forwarding links.",
        "i.e., permanent and temporary.",
        "A permanent forwarding link is the usual forwarding link found in other algorithms Pereira, 1985], [Wroblewski.",
        "1987], etc).",
        "Temporary forwarding links are links that are only valid during one top-level unification.",
        "The currency of the temporary links is determined by matching the content of the generation field for the links with the global counter; if they match, the content of this field is respected7.",
        "As in [Pereira, 1985].",
        "the Q-D algorithm has three types of nodes: 1) :atomic.",
        "2) :bottoma, and 3) :complex.",
        ":atomic: type nodes represent atomic symbol values (such as 'Nonni, :bottom type nodes are variables and :complex type nodes are nodes that have arcs coming out of them.",
        "Arcs are stored in the arc-list field.",
        "The atomic value is also stored in the arc-list if the node type is :atomic.",
        ":bottom nodes succeed in unifying with any nodes and the result of unification takes the type and the value of the node that the :bottom Rode was unified with.",
        ":atomic nodes succeed in unifying with :bottom nodes or :atomic nodes with the same value (stored in the arc-list).",
        "Unification of an :atomic mode with a :complex node immediately fails.",
        ":complex nodes succeed in unifying with :bottom nodes or with :complex nodes whose subgraphs all unify.'",
        "Figure 2 is the central quasi-destructive graph unification algorithm and Figure 3 is the dereferencine function.",
        "Figure 4 shows the algorithm for copying nodes and arcs (called from unify()) while respecting the contents of conm arc lists.",
        "we do not have a Separate field for temporary forwarding links; instead, we designate the integer value 9 to represent a permanent forwarding link.",
        "We start incrementing the global couster from 10 So whenever the generation mark is not 9, the integer value must equal the global counter value to respect the forwarding link.",
        "'Bottom is called hat in Pereira's algorithm.",
        "9Arc values are always nodes and never symbolic values because :atomic and :bottom nodes may be (or become) pointed to by multiple arcs (i.e, FS-Sharing) depending on grammar constraints, and we do not want arcs to contain terminal atomic values.",
        "re Dereferencing is an operation to recursively traverse forwarding links to return the tmget node of forwarding.",
        "unifyl(destination of the shared arc for dgl.",
        "destination of the shared arc for d02); new complementarcs(dg2,dg1);\" IFITIdgl.conip-arc-list is non-empty) THEN IF (dgl.generation = *unify-global-counter.)",
        "THEN FOR EACH arc IN new DO push arc to dgl.comp-arc-list:",
        "The functions Complententarcs(dgl,dg2) and In119 indicates a permanent forwarding link.",
        "\"'Equal in the 'eq' sense.",
        "Because of forwarding and cycles, it is possible that dgl and dg2 are 'eq'.",
        "13 Arc-list contains atomic value if the node is of type :atomic.",
        "14 construct; i.e., immediately return to unify-dy.",
        "\"This was performed after FOR.",
        "EACH loop in 1Tornabechi, 19911 which could have caused a problem with a successful cyclic call.",
        "Thanks are due to Marie Boyle of University of Isitebingen for suggesting the change.",
        "\"Complemeniarcs(dg2,r1g1) was called before unifyl recursions ill (Tomabechi, 1991), Currently it is moved to after all unifyl recursions successfully return.",
        "Thanks are ato due to Marie Boyle for suggesting this.",
        "'7 This check was added after IToniabechi, 19911 to avoid overwriting the comp-arc-list when it is written more than once within one unify() call.",
        "Thanks are due to Peter Neuhaus of Universitat Karlsruhe for reporting this problem.",
        "in dgl and dg2).",
        "During the set-difference and set-intersection operations, the content of comp-arc-lists are respected as parts of arc lists if the generation mark matchs the current value of the global tinting counter.",
        "Forward(dgl.",
        "dg2.",
        ":forward-type) puts dg2 in the forward field of dgl.",
        "If the keyword in the function call is :temporary, the current value of the *unify-global-counter* is written its the generation field of dgl.",
        "If the keyword is :permanent.",
        "9 is written in the generation field of 41.19 The temporary forwarding links are necessary to handle reentrancy and cycles.",
        "As soon as unification (at any level of reclusion through shared arcs) is performed, a temporary forwarding link is made front dg2 to dgl (41 to dg2 if dgl is of type :bottom).",
        "Thus, during unification, a node already unified by other recursive calls to unifyl within the same unify() call has a temporary forwarding link front dg2 to dgl (or dgl to dg2).",
        "As a result, if this node becomes an input argument node, &referencing the node causes dgl and dg2 to become the same node and unification immediately succeeds.",
        "Thus, a subgraph below an already unified node will not be checked more than once even if ant argument graph has a cycle.",
        "'9",
        "\"Permanent forwardings may be needed by grammar compilers that merge graphs.",
        "\"Also, during copying subsequent to a successful unification, two arcs converging into the same node will not cause overcopying simply because if a node already has a copy then the copy is returned."
      ]
    },
    {
      "heading": "3 Q-D Copying + DS-Sharing",
      "text": [
        "In order to attain structure-sharing during Quasi-Destructive graph unification, no modification is necessary for the unification functions described in the previous section.",
        "This section describes the quasi-destructive copying with structure-sharing which replaces the original copying algorithm.",
        "Since unification functions are unmodified, the Q-I) unification without structure-sharing can be mixed trivially with the Q-D unification with structure-sharing if such a mixture is desired (by simply choosing different copying functions).",
        "Informally, the Q-D copying with structure-sharing is performed in the following way.",
        "Atomic and bottom nodes are shared.",
        "A complex node is shared if no nodes below that node are changed (a node is considered changed by being a target of forwarding or having a valid comp-arc-list).",
        "If a node is changed then that information is passed up the graph path using multiple-value binding facility when a copy of the nodes are recursively returned.",
        "Two values are returned.",
        "the first value being the copy (or original) node and the second value being the flag representing whether any of the node below that node (including that node) has been changed.",
        "Atomic and bottom nodes are always shared; however, they are considered changed if they were a target of forwarding so that the 'changed' information is passed up.",
        "If the complex node is a target of forwarding, if no node below that node is changed then the original complex node is shared; however, the 'changed' information \"I.o.. the 'generation' field of the node stored in the 'copy' field of the 'dg' node.",
        "The algorithm described in (Toniabeclii, 190 iouol 'copy-mark' field of Currently 'generation' field replaces the three mark field described iu the article.",
        "21I.e.. rue existing copy of the node.",
        "22 Creates an empty node strncture.",
        "23 Thin operation to set a newly created copy node into the 'copy' field of 'dg' was done after recursion into subgraplis the algorithm description in (Toumbechi.",
        "1991) which wax cause of infinite recursion with a particular type of cycles ill the graph.",
        "fly moving up to this position from after the recursion, such a problem can he effectively avoided.",
        "Thanks are due to Peter Noulaur for reporting the problem.",
        "is missed up when the recursion returns.",
        "Below is the actual algorithm description for the Q-D copying with structure-sharing.",
        "newarc 4 first value of copy-arc-and-contp-arc-share(arc); posh newarc into newcopyarc-list;",
        "first value of newarc copy-arc-and-core p-arc-share( comp-arc ); push newarc into newcopy.arc-list; dg.conip-arc-list ■- nil;",
        "state 4– nil, arcs 4– nil: dg.copy dg\".",
        "dg.generation *unify-global-counter*; FOR ALL arc IN dg.arc-list DO newarc,changed copy-arc-and-comp-arc-share( arc ); posh newarc into arcs; IF (changed has value) THEN state I changed;",
        "FOR ALL arc IN dg.arc-list DO newarc ,-.",
        "first value of copy-arc-and-comp-are-share(arc); push newarc into neweopy.arcdist:",
        "successful unifications to the total number of unifications.",
        "We parsed each sentence three times oil a Symbolics 3620 using three unification methods, namely, Wroblewski's algorithm.",
        "a quasi-destructive method without structure-sharing.",
        "and a quasi-destructive method with structure-sharing.",
        "We took the shortest.",
        "elapsed time for each method ('W' represents Wroblewski's algorithm with a modification to handle cycles and variables\", •QIY represents the quasi-destructive method without structure-sharing, and 'QS' represents the proposed method with structure-sharing).",
        "Data structures are the same for all three unification methods except for additional fields for comp-arc-list in the Q-D methods.",
        "Same functions are used to interface with Earley's parser and the same subhinctions are used wherever possible (such as creation and access of arcs) to minimize the differences that are not purely algorithmic.",
        "'Number of Copies' represents the number of nodes created during each parse.",
        "`Number of Arcs' represents the number of arcs created during each parse.",
        "We used Harley[s parsing algorithm for the experiment.",
        "The Japanese grammar is based on IIPSG analysis ([Pollard and Sag, 1987]) covering phenomena such as coordination, case adjunction, adjuncts, control, slash categories, zero-pronouns, interrogatives, WH constructs, and some pragmatics (speaker, hearer relations, politeness, etc.)",
        "([Yoshi-moto and Kogure, 1989]).",
        "The grammar covers many of the important linguistic phenomena in conversational Japanese.",
        "The grammar graphs which are converted from the path equations contain 2324 nodes.\" We used 16 sentences from a sample telephone conversation dialog which range from very short sentences (one word, i.e., 'no') to relatively long ones (such as soredehakochirakarasochiranitourokuyou,shiw000kuriitashimasu 'In that case, we [speaker] will send you [hearer] the registration form:).",
        "Thus, the number of (top-level) unifications per sentence varied widely (from 6 to over 500)."
      ]
    },
    {
      "heading": "5 Discussion:",
      "text": [
        "Pereira ((Pereira, 1985]) attains structure-sharing by having the result graph share information with the original graphs by storing changes to the •environ-ment'.",
        "There will be the log(d) overhead (where d is the number of nodes in a graph) associated with Pereira's method that is required during node access to assemble the whole graph from the 'skeleton' and the updates in the 'environment'.",
        "In the proposed scheme, since the arcs directly point.",
        "to the original graph structures there will be no overhead for node accesses.",
        "Also, during unification, since changes are called 3299 times for sentence 9 when unify-dg was called 480 times.",
        "\"Kogure ([Kogure, 1989)) describes a trivial time modification to Wroblewski's algorithm to ha Ile cycles which is used in our experiments.",
        "3°Disjunctive equations are preprocessed by the grammar reader module to expand into cross-multiples, whereas ht ATR's SL-Takws system.",
        "Kasper's method (Kasper.",
        "19871) to handle disjunctive feature.atructures in adopted."
      ]
    },
    {
      "heading": "4 Experiments",
      "text": [
        "Table 1 shows the results of our experiments using an HPSG-based sample Japanese grammar developed at ATR for a conference registration telephone dialogue domain.",
        "'Unifs' represents the total number of top-level unifications during a parse (i.e, the number of calls to the top-level 'unify-dg', and not mitify1')28.",
        "`USrate' represents the ratio of 24 Currently, all nodes are copied in a cycle in order to prevent the split of the copy and the original when node above an unchanged original is modified.",
        "Thanks are due to Makoto Takahani of TIS for suggesting the fix.",
        "Of course, a better method, if possible, would be to copy the whole cycle only when at least one node in the cycle in modified, 25'1/alines' return multiple values from a function.",
        "In our algorithm, two values are returned.",
        "The first value in the result of copying, and the second value is at flag indicating if there was any modification to the node or to any of its descendants.",
        "stored directly in the nodes (in the quasi-destructive wanner) there will be no overhead for reflecting the changes to graphs during unification.",
        "We share the principle of storing changes in a restorable way with [Karttunem 19861's reversible unification and copy graphs only after a successful unification.",
        "However, Karttunen's method does not use structure-sharing.",
        "Also, In Karttunen's method31, whenever a destructive change is about to be made, the attribute value pairs32 stored in the body of the node are saved into an array.",
        "The dag node structure itself is also saved in another array.",
        "These values are restored after the top level unification is completed.",
        "(A copy is made prior to the restoration operation if the unification was a successful one.)",
        "Thus, in Karttunen's method, each node in the entire argument graph that has been destructively modified must be restored separately by retrieving the attribute-values saved in an array and resetting the values into the dag structure skeletons saved in another array.",
        "In the Q-D method.",
        "one increment to the global counter call invalidate all the changes made to the nodes.",
        "[Karttunen and Kay, 1985] suggests the use of lazy evaluation to delay destructive changes during unification.",
        "[Codden, 19901 presents one method to delay copying until a destructive change is about to take place.",
        "Cockier' uses delayed closures to directly implement lazy evaluation during unification.",
        "While it may be conceptually straightforward to take advantage of delayed evaluation functionalities ill programming languages, actual efficiency gain from such a scheme may not be significant.",
        "This is because such a scheme simply shifts the time and space consumed for copying to creating and evaluating closures (which could be very costly compared to 'clefstruct.",
        "operations to create copies 31 The discussion of Karttunen's method is based oil the D-PAM implementation on Xerox 1100 machines (lKarttnnen, 1986]).",
        "\"Le- arc HUI/chit-en: 'label' and 'value' pairs 171 1,11L vocalmhuy.",
        "which are often effectively optimized in many commercial compilers).",
        "[Kogure, 1990] and [Emele.",
        "19911 also use the lazy evaluation idea to delay destructive changes.",
        "Both Kogure and Elude avoid direct usage of delayed evaluation by using pointer operations.",
        "As Emele suggests, Kogure's method also requires a special dependency information to be maintained which adds an overhead along with the cost for traversing the dependency arcs.",
        "Also, a second traversal of the set of dependent nodes is required for actually performing the copying.",
        "Em rude proposes IL method of dereferencing by adding environment in-humation that carries a sequence of generation counters so that a specific generation node can be found by traversing the forwarding links until a node with that generation is found.",
        "While this allows undoing destructive changes cheaply by backtracking the environment„ every time a specific graph is to be accessed the whole graph needs to be reconstructed by following the forwarding pointers sequentially as specified in the environment list (except for the root node) to find the node that shares the same generation number as the root node.",
        "Therefore, similar to Pereira's method, there will be Nlog(d) overhead associated with constructing each graph every time a graph is accessed, where d is the number of nodes in the graph and N is the average depth of the environmental deference clam This would cause a problem if the algorithm is adopted for a large-scale system ill which result graphs are unified against other graphs many times.",
        "Like Wroblewski's method, all three lazy methods (i.e, Godden's, Kogure's and Elude's) suffer from the problem of Early Copying as defined in [Tomabechi, 19911.",
        "This is because the copies that are incrementally created up to the point of failure during the same top-level unification are wasted.",
        "The problem is inherent in incremental copying scheme and this problem is eliminated completely in [Karttunen, 19861 and in the Q-D method.\" There is one potential problem with the structure-sharing idea which is shared by each of the schemes including the proposed method.",
        "This happens when operations other than unification modify the graphs.",
        "(This is typical when a parser cuts off a part of a graph for subsequent analysis34.)",
        "When such operations are performed.",
        "structure-sharing of bottom (variable) nodes may cause problems when a subgraph containing a bottom is shared by two different.",
        "graphs and these graphs arc used as arguments of a unification function (either as the part of the same input graph or as elements of elgl and dg2).",
        "When a graph that.",
        "shares a bottom node is not used in its entirety.",
        "then the represented constraint postulated by the path leading to the bottom node is no longer the same.",
        "Therefore, when such a graph appears in the same unification along with sonic other graph with winch it DS shares the same bottom node, there will be a false FS-Sharing.",
        "(If the graph is used in its entirety this is not a problem since the two graph paths would unify anyway.)",
        "Tins problem happens only when neither of the two graphs that DS-Shares the same bottom node was unified against some other graph before appearing in the same unification.35 (If either was once unified, forwarding would have avoided tins problem).",
        "The methods to avoid such a problem can be 1) As long as these convergence of bottom nodes are used for features that are not passed up during parsing, the problems does not affect the result of parse in any way which scents the case with the grammars at ATR.",
        "and CMU.",
        "2) A parser can be modified so that when it modifies a graph other than through graph unification36, it creates copies of the arc structures containing the bottom nodes.",
        "In the proposed method this can be done by calling the copy function without, structure-sharing before a parser modifies a graph.",
        "3) A parser can be modified so that it, does not cot off parts of graphs and use the graphs in their entirety (tins should not, add complexity once structure-sharing is introduced to unification).",
        "Thus, although the space and time reduction attained by structure-sharing can be significant.",
        "DS-Sharing can cause problems unless it is used with a caution (by making sure variable sharing 33Lazy methods delay copying until a destructive change is to be performed so that unnecessary copies are not created within a particular recursion into a unification function; however.",
        "since each shared arc recursion is independent (non-deterministic).",
        "even if there are no unnecessary copies created at all in one particular recursion, if there is a failure in some other shared arc recursion (at HOMO depth), then the copies that are created by successful shared arc recursions up to the point of detection of failure will become wasted, As long as the basic control structure remains incremental, this is inherent in the incremental motion!.",
        "In other words, the problem is inherent in these incremental methods by definition.",
        "34 For example.",
        "many parsers cut off a subgraph of the path 0 for applying further rules when a rule is accepted.",
        "35Such cases may happen When the same rule (such as V V) augmented with a heavy use of convergence in the bottom nodes is applied many times during a parse.",
        "36Such as when a rule is accepted and subgraph of 0 path is cut off.",
        "does not cause erroneous sharing by using these or sonic other methods)."
      ]
    },
    {
      "heading": "6 Conclusion",
      "text": [
        "The structure-sharing scheme introduced in this paper made the Q-D algorithm run significantly faster.",
        "The original gain of the Q-D algorithm was due to the fact that it does not, create any Over Copies or Early Copies whereas incremental copying scheme inherently produces Early Copies (as defined in [Tomabechi.",
        "19911) when a unification fails.",
        "The proposed scheme makes the Q-D algorithm fully avoid Redundant Copies as well by only copying the lowest nodes that need to be copied due to destructive changes caused by successful unifications only.",
        "Since there will be virtually no overhead associated with structure-sharing (except for returning two values instead of one to pass up :changed information when recursion for copying returns), the performance of the proposed structure-sharing scheme should not drop even when the grammar size is significantly scaled up.",
        "With the demonstrated speed of the algorithm.",
        "as well as the ability to handle cyclicity in the graphs.",
        "and ease of switching between structure-sharing and non-structure: sharing, the algorithm could be a viable alternative to existing unification algorithms used in current natural language systems."
      ]
    }
  ]
}
