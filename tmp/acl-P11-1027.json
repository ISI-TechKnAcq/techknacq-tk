{
  "info": {
    "authors": [
      "Adam Pauls",
      "Dan Klein"
    ],
    "book": "Proceedings of the 49th Annual Meeting of the Association for Computational Linguistics: Human Language Technologies",
    "id": "acl-P11-1027",
    "title": "Faster and Smaller N-Gram Language Models",
    "url": "https://aclweb.org/anthology/P11-1027",
    "year": 2011
  },
  "references": [
    "acl-D07-1021",
    "acl-D07-1090",
    "acl-D09-1079",
    "acl-D10-1026",
    "acl-J04-4002",
    "acl-P05-1033",
    "acl-W07-0712",
    "acl-W08-0402",
    "acl-W09-1505",
    "acl-W10-1718"
  ],
  "sections": [
    {
      "text": [
        "Adam Pauls Dan Klein",
        "Computer Science Division University of California, Berkeley",
        "N-gram language models are a major resource bottleneck in machine translation.",
        "In this paper, we present several language model implementations that are both highly compact and fast to query.",
        "Our fastest implementation is as fast as the widely used SRILM while requiring only 25% of the storage.",
        "Our most compact representation can store all 4 billion n-grams and associated counts for the Google n-gram corpus in 23 bits per n-gram, the most compact lossless representation to date, and even more compact than recent lossy compression techniques.",
        "We also discuss techniques for improving query speed during decoding, including a simple but novel language model caching technique that improves the query speed of our language models (and SRILM) by up to 300%."
      ]
    },
    {
      "heading": "1. Introduction",
      "text": [
        "For modern statistical machine translation systems, language models must be both fast and compact.",
        "The largest language models (LMs) can contain as many as several hundred billion n-grams (Brants et al., 2007), so storage is a challenge.",
        "At the same time, decoding a single sentence can trigger hundreds of thousands of queries to the language model, so speed is also critical.",
        "As always, trade-offs exist between time, space, and accuracy, with many recent papers considering small-but-approximate noisy LMs (Chazelle et al., 2004; Guthrie and Hepple, 2010) or small-but-slow compressed LMs (Germann et al., 2009).",
        "In this paper, we present several lossless methods for compactly but efficiently storing large LMs in memory.",
        "As in much previous work (Whittaker and Raj, 2001; Hsu and Glass, 2008), our methods are conceptually based on tabular trie encodings wherein each n-gram key is stored as the concatenation of one word (here, the last) and an offset encoding the remaining words (here, the context).",
        "After presenting a bit-conscious basic system that typifies such approaches, we improve on it in several ways.",
        "First, we show how the last word of each entry can be implicitly encoded, almost entirely eliminating its storage requirements.",
        "Second, we show that the deltas between adjacent entries can be efficiently encoded with simple variable-length encodings.",
        "Third, we investigate block-based schemes that minimize the amount of compressed-stream scanning during lookup.",
        "To speed up our language models, we present two approaches.",
        "The first is a front-end cache.",
        "Caching itself is certainly not new to language modeling, but because well-tuned LMs are essentially lookup tables to begin with, naive cache designs only speed up slower systems.",
        "We present a direct-addressing cache with a fast key identity check that speeds up our systems (or existing fast systems like the widely-used, speed-focused SRILM) by up to 300%.",
        "Our second speed-up comes from a more fundamental change to the language modeling interface.",
        "Where classic LMs take word tuples and produce counts or probabilities, we propose an LM that takes a word-and-context encoding (so the context need not be re-looked up) and returns both the probability and also the context encoding for the suffix of the original query.",
        "This setup substantially accelerates the scrolling queries issued by decoders, and also exploits language model state equivalence (Li and",
        "Khudanpur, 2008).",
        "Overall, we are able to store the 4 billion n-grams of the Google Web1T (Brants and Franz, 2006) corpus, with associated counts, in 10 GB of memory, which is smaller than state-of-the-art lossy language model implementations (Guthrie and Hepple, 2010), and significantly smaller than the best published lossless implementation (Germann et al., 2009).",
        "We are also able to simultaneously outperform SRILM in both total size and speed.",
        "Our LM toolkit, which is implemented in Java and compatible with the standard ARPA file formats, is available on the web."
      ]
    },
    {
      "heading": "2. Preliminaries",
      "text": [
        "Our goal in this paper is to provide data structures that map n-gram keys to values, i.e. probabilities or counts.",
        "Maps are fundamental data structures and generic implementations of mapping data structures are readily available.",
        "However, because of the sheer number of keys and values needed for n-gram language modeling, generic implementations do not work efficiently \"out of the box.\"",
        "In this section, we will review existing techniques for encoding the keys and values of an n-gram language model, taking care to account for every bit of memory required by each implementation.",
        "To provide absolute numbers for the storage requirements of different implementations, we will use the Google Web1T corpus as a benchmark.",
        "This corpus, which is on the large end of corpora typically employed in language modeling, is a collection of nearly 4 billion n-grams extracted from over a trillion tokens of English text, and has a vocabulary of about 13.5 million words.",
        "In the Web1T corpus, the most frequent n-gram occurs about 95 billion times.",
        "Storing this count explicitly would require 37 bits, but, as noted by Guthrie and Hepple (2010), the corpus contains only about 770 000 unique counts, so we can enumerate all counts using only 20 bits, and separately store an array called the value rank array which converts the rank encoding of a count back to its raw count.",
        "The additional array is small, requiring only about 3MB, but we save 17 bits per n-gram, reducing value storage from around 16GB to about 9GB for Web1T.",
        "We can rank encode probabilities and back-offs in the same way, allowing us to be agnostic to whether we encode counts, probabilities and/or back-off weights in our model.",
        "In general, the number of bits per value required to encode all value ranks for a given language model will vary - we will refer to this variable as v .",
        "The data structure of choice for the majority of modern language model implementations is a trie (Fredkin, 1960).",
        "Tries or variants thereof are implemented in many LM tool kits, including represent collections of n-grams using a tree.",
        "Each node in the tree encodes a word, and paths in the tree correspond to n-grams in the collection.",
        "Tries ensure that each n-gram prefix is represented only once, and are very efficient when n-grams share common prefixes.",
        "Values can also be stored in a trie by placing them in the appropriate nodes.",
        "Conceptually, trie nodes can be implemented as records that contain two entries: one for the word in the node, and one for either a pointer to the parent of the node or a list of pointers to children.",
        "At a low level, however, naive implementations of tries can waste significant amounts of space.",
        "For example, the implementation used in SRILM represents a trie node as a C struct containing a 32-bit integer representing the word, a 64-bit memory pointer to the list of children, and a 32-bit floating point number representing the value stored at a node.",
        "The total storage for a node alone is 16 bytes, with additional overhead required to store the list of children.",
        "In total, the most compact implementation in SRILM uses 33 bytes per n-gram of storage, which would require around 116 GB of memory to store Web1T.",
        "While it is simple to implement a trie node in this (already wasteful) way in programming languages that offer low-level access to memory allocation like C/C++, the situation is even worse in higher level programming languages.",
        "In Java, for example, C-style structs are not available, and records are most naturally implemented as objects that carry an additional 64 bits of overhead.",
        "Despite its relatively large storage requirements, the implementation employed by SRILM is still widely in use today, largely because of its speed - to our knowledge, SRILM is the fastest freely available language model implementation.",
        "We will show that we can achieve access speeds comparable to SRILM but using only 25% of the storage.",
        "A more compact implementation of a trie is described in Whittaker and Raj (2001).",
        "In their implementation, nodes in a trie are represented implicitly as entries in an array.",
        "Each entry encodes a word with enough bits to index all words in the language model (24 bits for Web1T), a quantized value, and a 32-bit offset that encodes the contiguous block of the array containing the children of the node.",
        "Note that 32 bits is sufficient to index all n-grams in Web1T; for larger corpora, we can always increase the size of the offset.",
        "Effectively, this representation replaces systemlevel memory pointers with offsets that act as logical pointers that can reference other entries in the array, rather than arbitrary bytes in RAM.",
        "This representation saves space because offsets require fewer bits than memory pointers, but more importantly, it permits straightforward implementation in any higherlevel language that provides access to arrays of integers.",
        "Hsu and Glass (2008) describe a variant of the implicit tries of Whittaker and Raj (2001) in which each node in the trie stores the prefix (i.e. parent).",
        "This representation has the property that we can refer to each n-gram wn by its last word wn and the offset c(wn_1) of its prefix wn_1, often called the context.",
        "At a low-level, we can efficiently encode this pair (wn,c(wn_1)) as a single 64-bit integer, where the first 24 bits refer town and the last 40 bits encode c(wn_ ).",
        "We will refer to this encoding as a context encoding.",
        "Note that typically, n-grams are encoded in tries in the reverse direction (first-rest instead of last-rest), which enables a more efficient computation of back-offs.",
        "In our implementations, we found that the speed improvement from switching to a first-rest encoding and implementing more efficient queries was modest.",
        "However, as we will see in Section 4.2, the last-rest encoding allows us to exploit the scrolling nature of queries issued by decoders, which results in speedups that far outweigh those achieved by reversing the trie."
      ]
    },
    {
      "heading": "3. Language Model Implementations",
      "text": [
        "In the previous section, we reviewed well-known techniques in language model implementation.",
        "In this section, we combine these techniques to build simple data structures in ways that are to our knowledge novel, producing language models with state-of-the-art memory requirements and speed.",
        "We will also show that our data structures can be very effectively compressed by implicitly encoding the word wn, and further compressed by applying a variable-length encoding on context deltas.",
        "A standard way to implement a map is to store an array of key/value pairs, sorted according to the key.",
        "Lookup is carried out by performing binary search on a key.",
        "For an n-gram language model, we can apply this implementation with a slight modification: we need n sorted arrays, one for each n-gram order.",
        "We construct keys (wn, c(wn_1 )) using the context encoding described in the previous section, where the context offsets c refer to entries in the sorted array of (n – 1)-grams.",
        "This data structure is shown graphically in Figure 1.",
        "Because our keys are sorted according to their context-encoded representation, we cannot straightforwardly answer queries about an n-gram w without first determining its context encoding.",
        "We can do this efficiently by building up the encoding incrementally: we start with the context offset of the unigram w1 , which is simply its integer representation, and use that to form the context encoding of the bigram wf = (w2, c(w1)).",
        "We can find the offset of",
        "Figure 1: Our Sorted implementation of a trie.",
        "The dotted paths correspond to \"the cat slept\", \"the cat ran\", and \"the dog ran\".",
        "Each node in the trie is an entry in an array with 3 parts: w represents the word at the node; val represents the (rank encoded) value; and c is an offset in the array of n – 1 grams that represents the parent (prefix) of a node.",
        "Words are represented as offsets in the unigram array.",
        "the bigram using binary search, and form the context encoding of the trigram, and so on.",
        "Note, however, that if our queries arrive in context-encoded form, queries are faster since they involve only one binary search in the appropriate array.",
        "We will return to this later in Section 4.2",
        "This implementation, SORTED, uses 64 bits for the integer-encoded keys and v bits for the values.",
        "Lookup is linear in the length of the key and logarithmic in the number of n-grams.",
        "For Web1T (v = 20), the total storage is 10.5 bytes/n-gram or about 37GB.",
        "Hash tables are another standard way to implement associative arrays.",
        "To enable the use of our context encoding, we require an implementation in which we can refer to entries in the hash table via array offsets.",
        "For this reason, we use an open address hash map that uses linear probing for collision resolution.",
        "As in the sorted array implementation, in order to insert an n-gram w1n into the hash table, we must form its context encoding incrementally from the offset of w1 .",
        "However, unlike the sorted array implementation, at query time, we only need to be able to check equality between the query key w1n = (wn, c(wn_1)) and a key w'f = (wn, c(w'1n\")) in the table.",
        "Equality can easily be checked by first checking if wn = w'n, then recursively checking equality between wn_1 and w1n-1, though again, equality is even faster if the query is already context-encoded.",
        "This HASH data structure also uses 64 bits for integer-encoded keys and v bits for values.",
        "However, to avoid excessive hash collisions, we also allocate additional empty space according to a user-defined parameter that trades off speed and time we used about 40% extra space in our experiments.",
        "For Web1T, the total storage for this implementation is 15 bytes/n-gram or about 53 GB total.",
        "Look up in a hash map is linear in the length of an n-gram and constant with respect to the number of n-grams.",
        "Unlike the sorted array implementation, the hash table implementation also permits efficient insertion and deletion, making it suitable for stream-based language models (Levenberg and Osborne, 2009).",
        "val",
        "w",
        ".",
        "val",
        "|1933 15176583",
        "6879",
        "00004498",
        "1933 !",
        "15176585;-",
        "6879",
        "00004502",
        "1933 15176593",
        "6879",
        "00004530",
        "1933 15176613",
        "\"cat\"*>",
        "6879",
        "00004568",
        "1933 15179801",
        "y",
        "-•",
        "6879",
        "00004588",
        "1933 15180051",
        "6879",
        "00004598",
        "1933 15180053",
        "6879",
        "00004668",
        "1935 ; 15176585 ;",
        "6880",
        "00004669",
        "1935 15176589",
        "\"dog\".„",
        "6880",
        "00004568",
        "1935 !",
        "15176591 r",
        "!",
        "6880 !",
        "00004577",
        "•",
        ".",
        "w",
        "• •",
        "val",
        "\"slept\" 1",
        ".",
        "•",
        "\"left\"",
        "\"the\"",
        "\"had\"",
        "• •",
        "\"dog\"",
        "The context encoding we have used thus far still wastes space.",
        "This is perhaps most evident in the sorted array representation (see Figure 1): all n-grams ending with a particular word are stored contiguously.",
        "We can exploit this redundancy by storing only the context offsets in the main array, using as many bits as needed to encode all context offsets (32 bits for Web1T).",
        "In auxiliary arrays, one for each n-gram order, we store the beginning and end of the range of the trie array in which all (w*, c) keys are stored for each w*.",
        "These auxiliary arrays are negligibly small - we only need to store 2n offsets for each word.",
        "The same trick can be applied in the hash table implementation.",
        "We allocate contiguous blocks of the main array for n-grams which all share the same last word w*, and distribute keys within those ranges using the hashing function.",
        "This representation reduces memory usage for keys from 64 bits to 32 bits, reducing overall storage for Web1T to 6.5 bytes/n-gram for the sorted implementation and 9.1 bytes for the hashed implementation, or about 23GB and 32GB in total.",
        "It also increases query speed in the sorted array case, since to find (w*, c), we only need to search the range of the array over which applies.",
        "Because this implicit encoding reduces memory usage without a performance cost, we will assume its use for the rest of this paper.",
        "The distribution of value ranks in language modeling is Zipfian, with far more n-grams having low counts than high counts.",
        "If we ensure that the value rank array sorts raw values by descending order of frequency, then we expect that small ranks will occur much more frequently than large ones, which we can exploit with a variable-length encoding.",
        "To compress n-grams, we can exploit the context encoding of our keys.",
        "In Figure 2, we show a portion",
        "Figure 2: Compression using variable-length encoding.",
        "(a) A snippet of an (uncompressed) context-encoded array.",
        "(b) The context and word deltas.",
        "(c) The number of bits required to encode the context and word deltas as well as the value ranks.",
        "Word deltas use variable-length block coding with k =1, while context deltas and value ranks use k = 2.",
        "(d) A snippet of the compressed encoding array.",
        "The header is outlined in bold.",
        "of the key array used in our sorted array implementation.",
        "While we have already exploited the fact that the 24 word bits repeat in the previous section, we note here that consecutive context offsets tend to be quite close together.",
        "We found that for 5-grams, the median difference between consecutive offsets was about 50, and 90% of offset deltas were smaller than 10000.",
        "By using a variable-length encoding to represent these deltas, we should require far fewer than 32 bits to encode context offsets.",
        "We used a very simple variable-length coding to encode offset deltas, word deltas, and value ranks.",
        "Our encoding, which is referred to as \"variable-length block coding\" in Boldi and Vigna (2005), works as follows: we pick a (configurable) radix r = 2k.",
        "To encode a number m, we determine the number of digits d required to express m in base r. We write d in unary, i.e. d – 1 zeroes followed by a one.",
        "We then write the d digits of m in base r, each of which requires k bits.",
        "For example, using k = 2, we would encode the decimal number 7 as 010111.",
        "We can choose k separately for deltas and value indices, and also tune these parameters to a given language model.",
        "We found this encoding outperformed other standard prefix codes, including Golomb and Elias 7 and 5 codes.",
        "We also experimented with the Z codes of Boldi and Vigna (2005), which modify variable-length block codes so that they are optimal for certain power law distributions.",
        "We found that Z codes performed no better than variable-length block codes and were slightly more complex.",
        "Finally, we found that Huffman codes outperformed our encoding slightly, but came at a much higher computational cost.",
        "(a) Context-Encoding",
        "(b) Context Deltas",
        "(c) Bits Required",
        "w c",
        "1 val 1",
        "Aw Ac",
        "val 1",
        "|Aw|",
        "|Ac| Ivall",
        "1933 15176585",
        "3",
        "1933 15176585",
        "3",
        "24",
        "40 3",
        "1933 15176587",
        "2",
        "+0 +2",
        "1",
        "2",
        "3 3",
        "1933 15176593",
        "1",
        "+0 +5",
        "1",
        "2",
        "3 3",
        "1933 15176613",
        "8",
        "+0 +40",
        "8",
        "2",
        "9 6",
        "1933 15179801",
        "1",
        "+0 +188",
        "1",
        "2",
        "12 3",
        "1935 15176585",
        "298",
        "+2 15176585",
        "298",
        "4",
        "36 15",
        "1935 15176589",
        "1",
        "+0 +4",
        "1",
        "2",
        "6 3",
        "Value rank for header",
        "(d) Compressed Array",
        "tip",
        "1933 15176585",
        "563097887",
        "956 3 0~] +0",
        "+2 1 2",
        "1 +0 1 +5 1",
        "+0 +40 8 •",
        "\\/",
        "~~r~",
        "t +",
        "Header key",
        "Logical Number True if offset of of bits all Aw h this block in this block are block 0",
        "We could in principle compress the entire array of key/value pairs with the encoding described above, but this would render binary search in the array impossible: we cannot jump to the midpoint of the array since in order to determine what key lies at a particular point in the compressed bit stream, we would need to know the entire history of offset deltas.",
        "Instead, we employ block compression, a technique also used by Harb et al.",
        "(2009) for smaller language models.",
        "In particular, we compress the key/value array in blocks of 128 bytes.",
        "At the beginning of the block, we write out a header consisting of: an explicit 64-bit key that begins the block; a 32-bit integer representing the offset of the header key in the uncompressed array; the number of bits of compressed data in the block; and the variable-length encoding of the value rank of the header key.",
        "The remainder of the block is filled with as many compressed key/value pairs as possible.",
        "Once the block is full, we start a new block.",
        "See Figure 2 for a depiction.",
        "When we encode an offset delta, we store the delta of the word portion of the key separately from the delta of the context offset.",
        "When an entire block shares the same word portion of the key, we set a single bit in the header that indicates that we do not encode any word deltas.",
        "To find a key in this compressed array, we first perform binary search over the header blocks (which are predictably located every 128 bytes), followed by a linear search within a compressed block.",
        "Using k = 6 for encoding offset deltas and k = 5 for encoding value ranks, this COMPRESSED implementation stores Web1T in less than 3 bytes per n-gram, or about 10.2GB in total.",
        "This is about 6GB less than the storage required by Germann et al.",
        "(2009), which is the best published lossless compression to date."
      ]
    },
    {
      "heading": "4. Speeding up Decoding",
      "text": [
        "In the previous section, we provided compact and efficient implementations of associative arrays that allow us to query a value for an arbitrary n-gram.",
        "However, decoders do not issue language model requests at random.",
        "In this section, we show that language model requests issued by a standard decoder exhibit two patterns we can exploit: they are highly repetitive, and also exhibit a scrolling effect.",
        "In a simple experiment, we recorded all of the language model queries issued by the Joshua decoder (Li et al., 2009) on a 100 sentence test set.",
        "Of the 31 million queries, only about 1 million were unique.",
        "Therefore, we expect that keeping the results of language model queries in a cache should be effective at reducing overall language model latency.",
        "To this end, we added a very simple cache to our language model.",
        "Our cache uses an array of key/value pairs with size fixed to 2b – 1 for some integer b (we used 24).",
        "We use a 6-bit hash function to compute the address in an array where we will always place a given n-gram and its fully computed language model score.",
        "Querying the cache is straightforward: we check the address of a key given by its b-bit hash.",
        "If the key located in the cache array matches the query key, then we return the value stored in the cache.",
        "Otherwise, we fetch the language model probability from the language model and place the new key and value in the cache, evicting the old key in the process.",
        "This scheme is often called a direct-mapped cache because each key has exactly one possible address.",
        "Caching n-grams in this way reduces overall latency for two reasons: first, lookup in the cache is extremely fast, requiring only a single evaluation of the hash function, one memory lookup to find the cache key, and one equality check on the key.",
        "In contrast, even our fastest (HASH) implementation may have to perform multiple memory lookups and equality checks in order to resolve collisions.",
        "Second, when calculating the probability for an n-gram",
        "the cat + fell down",
        "Figure 3: Queries issued when scoring trigrams that are created when a state with LM context \"the cat\" combines with \"fell down\".",
        "In the standard explicit representation of an n-gram as list of words, queries are issued atomically to the language model.",
        "When using a context-encoding, a query from the n-gram \"the cat fell\" returns the context offset of \"cat fell\", which speeds up the query of \"cat fell down\".",
        "not in the language model, language models with back-off schemes must in general perform multiple queries to fetch the necessary back-off information.",
        "Our cache retains the full result of these calculations and thus saves additional computation.",
        "Federico and Cettolo (2007) also employ a cache in their language model implementation, though based on traditional hash table cache with linear probing.",
        "Unlike our cache, which is of fixed size, their cache must be cleared after decoding a sentence.",
        "We would not expect a large performance increase from such a cache for our faster models since our Hash implementation is already a hash table with linear probing.",
        "We found in our experiments that a cache using linear probing provided marginal performance increases of about 40%, largely because of cached back-off computation, while our simpler cache increases performance by about 300% even over our Hash LM implementation.",
        "More timing results are presented in Section 5.",
        "Decoders with integrated language models (Och and Ney, 2004; Chiang, 2005) score partial translation hypotheses in an incremental way.",
        "Each partial hypothesis maintains a language model context consisting of at most n – 1 target-side words.",
        "When we combine two language model contexts, we create several new n-grams of length of n, each of which generate a query to the language model.",
        "These new",
        "n-grams exhibit a scrolling effect, shown in Figure 3: the n – 1 suffix words of one n-gram form the n – 1 prefix words of the next.",
        "As discussed in section 3, our LM implementations can answer queries about context-encoded n-grams faster than explicitly encoded n-grams.",
        "With this in mind, we augment the values stored in our language model so that for a key (wn, c(wn-1)), we store the offset of the suffix c(wn) as well as the normal counts/probabilities.",
        "Then, rather than represent the LM context in the decoder as an explicit list of words, we can simply store context offsets.",
        "When we query the language model, we get back both a language model score and context offset c(Wn_1), where WJ1-1 is the the longest suffix of wn_1 contained in the language model.",
        "We can then quickly form the context encoding of the next query by simply concatenating the new word with the offset c(Wn-1) returned from the previous query.",
        "In addition to speeding up language model queries, this approach also automatically supports an equivalence of LM states (Li and Khudanpur, 2008): in standard back-off schemes, whenever we compute the probability for an n-gram (wn, c(wn-1)) when w^1- is not in the language model, the result will be the same as the result of the query (wn, c(Wn-1).",
        "It is therefore only necessary to store as much of the context as the language model contains instead of all n – 1 words in the context.",
        "If a decoder maintains LM states using the context offsets returned by our language model, then the decoder will automatically exploit this equivalence and the size of the search space will be reduced.",
        "This same effect is exploited explicitly by some decoders (Li and Khudanpur, 2008).",
        "Explicit Representation",
        "the cat fell cat fell down",
        "->[lm]-►",
        "->[lm]-►",
        "0.76 0.12",
        "Context Encoding",
        "\"the cat\" 18569876 fell",
        "1 3576410 \"cat fell\"",
        "35764106 down-",
        "->[Lm] – ► -*[lm| – ►",
        "0.76 0.12",
        "Order",
        "#n-grams",
        "Order",
        "#n-grams",
        "1gm",
        "4,366,395",
        "1gm",
        "13,588,391",
        "2gm",
        "61,865,588",
        "2gm",
        "314,843,401",
        "3gm",
        "123,158,761",
        "3gm",
        "977,069,902",
        "4gm",
        "217,869,981",
        "4gm",
        "1,313,818,354",
        "5gm",
        "269,614,330",
        "5gm",
        "1,176,470,663",
        "Total",
        "676,875,055",
        "Total",
        "3,795,790,711",
        "Table 2: Memory usages of several language model implementations on the Wmt2010 language model.",
        "A ** indicates that the storage in bytes per n-gram is reported for a different language model of comparable size, and the total size is thus a rough projection."
      ]
    },
    {
      "heading": "5. Experiments",
      "text": [
        "To test our LM implementations, we performed experiments with two different language models.",
        "Our first language model, Wmt2010, was a 5-gram Kneser-Ney language model which stores probability/back-off pairs as values.",
        "We trained this language model on the English side of all French-English corpora provided for use in the WMT 2010 workshop, about 2 billion tokens in total.",
        "This data was tokenized using the tokenizer.perl script provided with the data.",
        "We trained the language model using sRILM.",
        "We also extracted a count-based language model, Web1T, from the Web1T corpus (Brants and Franz, 2006).",
        "since this data is provided as a collection of 1 to 5-grams and associated counts, we used this data without further preprocessing.",
        "The make up of these language models is shown in Table 1.",
        "We tested our three implementations (Hash, Sorted, and Compressed) on the Wmt2010 language model.",
        "For this language model, there are about 80 million unique probability/back-off pairs, so v ~ 36.",
        "Note that here v includes both the cost per key of storing the value rank as well as the (amortized) cost of storing two 32 bit floating point numbers (probability and back-off) for each unique value.",
        "The results are shown in Table 2.",
        "Table 3: Memory usages of several language model implementations on the Web1T.",
        "A t indicates lossy compression.",
        "We compare against three baselines.",
        "The first two, SRILM-H and SRILM-S, refer to the hash table-and sorted array-based trie implementations provided by sRILM.",
        "The third baseline is the Tightly-Packed Trie (TPT) implementation of Germann et al.",
        "(2009).",
        "Because this implementation is not freely available, we use their published memory usage in bytes per n-gram on a language model of similar size and project total usage.",
        "The memory usage of all of our models is considerably smaller than SRILM - our Hash implementation is about 25% the size of SRILM-H, and our Sorted implementation is about 25% the size of SRILM-S. Our Compressed implementation is also smaller than the state-of-the-art compressed TPT implementation.",
        "In Table 3, we show the results of our Compressed implementation on Web1T and against two baselines.",
        "The first is compression of the ASCII text count files using gzip, and the second is the Tiered Minimal Perfect Hash (T-MPHR) of Guthrie and Hepple (2010).",
        "The latter is a lossy compression technique based on Bloomier filters (Chazelle et al., 2004) and additional variable-length encoding that achieves the best published compression of Web1T to date.",
        "Our Compressed implementation is even smaller than T-MPHR, despite using a lossless compression technique.",
        "Note that since T-MPHR uses a lossy encoding, it is possible to reduce the storage requirements arbitrarily at the cost of additional errors in the model.",
        "We quote here the storage required when keys are encoded using 12bit hash codes, which gives a false positive rate of about 2-12 =0.02%.",
        "LMType",
        "bytes/",
        "bytes/",
        "bytes/",
        "Total",
        "key",
        "value",
        "n-gram",
        "Size",
        "srilm-h",
        "-",
        "-",
        "42.2",
        "26.6G",
        "SRILM-S",
        "-",
        "-",
        "33.5",
        "21.1G",
        "Hash",
        "5.6",
        "6.0",
        "11.6",
        "7.5G",
        "Sorted",
        "4.0",
        "4.5",
        "8.5",
        "5.5G",
        "TPT",
        "-",
        "-",
        "7.5**",
        "4.7G**",
        "Compressed",
        "2.1",
        "3.8",
        "5.9",
        "3.7G",
        "LM Type",
        "bytes/",
        "bytes/",
        "bytes/",
        "Total",
        "key",
        "value",
        "n-gram",
        "Size",
        "Gzip",
        "-",
        "-",
        "7.0",
        "24.7G",
        "T-MPHRt",
        "-",
        "-",
        "3.0",
        "10.5G",
        "Compressed",
        "1.3",
        "1.6",
        "2.9",
        "10.2G",
        "Table 4: Raw query speeds of various language model implementations.",
        "Times were averaged over 3 runs on the same machine.",
        "For Hash+Scroll, all queries were issued to the decoder in context-encoded form, which speeds up queries that exhibit scrolling behaviour.",
        "Note that memory usage is higher than for Hash because we store suffix offsets along with the values for an n-gram.",
        "Table 5: Full decoding times for various language model implementations.",
        "Our Hash LM is as fast as SRILM while using 25% of the memory.",
        "Our caching also reduces total decoding time by about 20% for our fastest models and speeds up Compressed by a factor of 6.",
        "Times were averaged over 3 runs on the same machine.",
        "We first measured pure query speed by logging all LM queries issued by a decoder and measuring the time required to query those n-grams in isolation.",
        "We used the the Joshua decoder with the WMT2010 model to generate queries for the first 100 sentences of the French 2008 News test set.",
        "This produced about 30 million queries.",
        "We measured the time required to perform each query in order with and without our direct-mapped caching, not including any time spent on file I/O.",
        "The results are shown in Table 4.",
        "As expected, Hash is the fastest of our implementations, and comparable in speed to SRILM-H, but using significantly less space.",
        "Sorted is slower but of course more memory efficient, and COMPRESSED is the slowest but also the most compact representation.",
        "In Hash+Scroll, we issued queries to the language model using the context encoding, which speeds up queries substantially.",
        "Finally, we note that our direct-mapped cache is very effective.",
        "The query speed of all models is boosted substantially.",
        "In particular, our COMPRESSED implementation with caching is nearly as fast as SRILM-H without caching, and even the already fast Hash implementation is 300% faster in raw query speed with caching enabled.",
        "We also measured the effect of LM performance on overall decoder performance.",
        "We modified Joshua to optionally use our LM implementations during decoding, and measured the time required to decode all 2051 sentences of the 2008 News test set.",
        "The results are shown in Table 5.",
        "Without caching, SRILM-H and Hash were comparable in speed, while Compressed introduces a performance penalty.",
        "With caching enabled, overall decoder speed is improved for both Hash and SRILM-H, while the COMPRESSED implementation is only about 50% slower that the others."
      ]
    },
    {
      "heading": "6. Conclusion",
      "text": [
        "We have presented several language model implementations which are state-of-the-art in both size and speed.",
        "Our experiments have demonstrated improvements in query speed over SRILM and compression rates against state-of-the-art lossy compression.",
        "We have also described a simple caching technique which leads to performance increases in overall decoding time."
      ]
    },
    {
      "heading": "Acknowledgements",
      "text": [
        "This work was supported by a Google Fellowship for the first author and by BBN under DARPA contract HR0011-06-C-0022.",
        "We would like to thank David Chiang, Zhifei Li, and the anonymous reviewers for their helpful comments.",
        "nately, it is not completely fair to compare our LMs against either of these numbers: although the JNI overhead slows down SRILM, implementing our LMs in Java instead of C++ slows down our LMs.",
        "In the tables, we quote times which include the JNI overhead, since this reflects the true cost to a decoder written in Java (e.g. Joshua).",
        "LMType",
        "No Cache",
        "Cache",
        "Size",
        "Compressed",
        "9264±73ns",
        "565±7ns",
        "3.7G",
        "Sorted",
        "1405±50ns",
        "243±4ns",
        "5.5G",
        "Hash",
        "495±10ns",
        "179±6ns",
        "7.5G",
        "SRILM-H",
        "428±5ns",
        "159±4ns",
        "26.6G",
        "Hash+Scroll",
        "323±5ns",
        "139±6ns",
        "10.5G",
        "LM Type",
        "No Cache",
        "Cache",
        "Size",
        "Compressed",
        "srilm-h Hash",
        "9880±82s 1120±26s 1146±8s",
        "1547±7s 938±11s 943±16s",
        "3.7G 26.6G 7.5G"
      ]
    }
  ]
}
