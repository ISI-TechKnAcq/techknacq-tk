{
  "info": {
    "authors": [
      "Makoto Kanazawa"
    ],
    "book": "45th Annual Meeting of the Association of Computational Linguistics",
    "id": "acl-P07-1023",
    "title": "Parsing and Generation as Datalog Queries",
    "url": "https://aclweb.org/anthology/P07-1023",
    "year": 2007
  },
  "references": [
    "acl-P01-1033"
  ],
  "sections": [
    {
      "text": [
        "National Institute of Informatics",
        "We show that the problems of parsing and surface realization for grammar formalisms with \"context-free\" derivations, coupled with Montague semantics (under a certain restriction) can be reduced in a uniform way to Datalog query evaluation.",
        "As well as giving a polynomial-time algorithm for computing all derivation trees (in the form of a shared forest) from an input string or input logical form, this reduction has the following complexity-theoretic consequences for all such formalisms: (i) the decision problem of recognizing grammaticality (surface realizability) of an input string (logical form) is in LOGCFL; and (ii) the search problem of finding one logical form (surface string) from an input string (logical form) is in functional LOGCFL.",
        "Moreover, the generalized supplementary magic-sets rewriting of the Datalog program resulting from the reduction yields efficient Earley-style algorithms for both parsing and generation."
      ]
    },
    {
      "heading": "1. Introduction",
      "text": [
        "The representation of context-free grammars (augmented with features) in terms of definite clause programs is well-known.",
        "In the case of a bare-bone CFG, the corresponding program is in the function-free subset of logic programming, known as Datalog.",
        "For example, determining whether a string John found a unicorn belongs to the language of the CFG in Figure 1 is equivalent to deciding whether the Datalog program in Figure 2 together with the database in (1) can derive the query \"?- S(0,4).\"",
        "(1) John(0,1).",
        "found(1,2).",
        "a(2,3).",
        "N unicorn",
        "S(i, j):- NP(i, k), VP(k, j).",
        "VP(i, j):- V(i, k), NP(k, j).",
        "NP(i,j):- Det(i,k),N(k,j).",
        "NP(i, j):- John(i, j).",
        "V(i, j):- found(i, j).",
        "V(i, j):- caught(i, j).",
        "j).",
        "Conj(i, j):- and(i, j).",
        "Det(i, j):- a(i, j).",
        "N (i, j):- unicorn(i, j).",
        "By naive (or seminaive) bottom-up evaluation (see, e.g., Ullman, 1988), the answer to such a query can be computed in polynomial time in the size of the database for any Datalog program.",
        "By recording rule instances rather than derived facts, a packed representation of the complete set of Datalog derivation trees for a given query can also be obtained in polynomial time by the same technique.",
        "Since a Datalog derivation tree uniquely determines a grammar derivation tree, this gives a reduction of context-free recognition and parsing to query evaluation in Datalog.",
        "In this paper, we show that a similar reduction to Datalog is possible for more powerful grammar formalisms with \"context-free\" derivations, such as (multi-component) tree-adjoining grammars (Joshi and Schabes, 1997; Weir, 1988), IO macro grammars (Fisher, 1968), and (parallel) multiple context-free grammars (Seki et al., 1991).",
        "For instance, the TAG in Figure 3 is represented by the Datalog program in Figure 4.",
        "Moreover, the method of reduc-",
        "unicorn(3, 4).",
        "S(pi,P3):- A(pi,p3,p2,P2).",
        "A(pi,ps,p4,ps):- A(p2,p7,p3,p6), a(pi,p2), b(p3,p4), C(p5, p6), d(p7, ps).",
        "A (pi, p2, pi, p2).",
        "VPO/xXjO/yXtyx)) - V(XO NPX2)",
        "NP(/u.u Johne) – John",
        "V(finde-e-t) – found",
        "V(catche – e – t) – caught",
        "N(unicorne_> t) – unicorn",
        "tion extends to the problem of tactical generation (surface realization) for these grammar formalisms coupled with Montague semantics (under a certain restriction).",
        "Our method essentially relies on the encoding of different formalisms in terms of abstract categorial grammars (de Groote, 2001).",
        "The reduction to Datalog makes it possible to apply to parsing and generation sophisticated evaluation techniques for Datalog queries; in particular, an application of generalized supplementary magic-sets rewriting (Beeri and Ramakrishnan, 1991) automatically yields Earley-style algorithms for both parsing and generation.",
        "The reduction can also be used to obtain a tight upper bound, namely LOGCFL, on the computational complexity of the problem of recognition, both for grammaticality of input strings and for surface realizability of input logical forms.",
        "With regard to parsing and recognition of input strings, polynomial-time algorithms and the LOGCFL upper bound on the computational complexity are already known for the grammar formalisms covered by our results (Engelfriet, 1986); nevertheless, we believe that our reduction to Datalog offers valuable insights.",
        "Concerning generation, our results seem to be entirely new."
      ]
    },
    {
      "heading": "2. Context-free grammars on i-terms",
      "text": [
        "Consider an augmentation of the grammar in Figure 1 with Montague semantics, where the left-hand",
        "NP VP John V NP found Det N a unicorn",
        "side of each rule is annotated with a //-term that tells how the meaning of the left-hand side is composed from the meanings of the right-hand side nonterminals, represented by upper-case variables X1;X2,... (Figure 5).",
        "The meaning of a sentence is computed from its derivation tree.",
        "For example, John found a unicorn has the derivation tree in Figure 6, and the grammar rules assign its root node the / term which jS-reduces to the /-term encoding the first-order logic formula representing the meaning of the sentence (i.e., its logical form).",
        "Thus, computing the logical form(s) of a sentence involves parsing and /-term normalization.",
        "To find a sentence expressing a given logical form, it suffices",
        "SXX2):- NP(X1), VP(X2).",
        "VP(/x.X2(/y.Xtyx)) :- V(X^, NP(Xi).",
        "V(/yx.X2(X^x)(X^yx)) :- V(X1), Conj(X2), V(X3).",
        "NPXX2):- Det(X1), N(Xi).",
        "NP(/u.u Johne).",
        "V(finde – e – t).",
        "V(catche – e – t).",
        "Conj(At_>t_>t).",
        "Det(/uv.3(e – t) – t (/y.At – 1 – t(uy)(vy))).",
        "N(unicorne_>t).",
        "to find a derivation tree whose root node is associated with a /-term that /^-reduces to the given logical form; the desired sentence can simply be read off from the derivation tree.",
        "At the heart of both tasks is the computation of the derivation tree(s) that yield the input.",
        "In the case of generation, this may be viewed as parsing the input / term with a \"context-free\" grammar that generates a set of / terms (in normal form) (Figure 7), which is obtained from the original CFG with Montague semantics by stripping off terminal symbols.",
        "Determining whether a given logical form is surface realizable with the original grammar is equivalent to recognition with the resulting context-free / term grammar (CFLG).",
        "In a CFLG such as in Figure 7, constants appearing in the / terms have preassigned types indicated by superscripts.",
        "There is a mapping a from nonterminals to their types (a = {S i~» t, NP i~» (e – > t) – > t, VP – e – t, V – e~>e~>t, Conj – t – t – t, Det – (e~»(e~»t, N – e~> t}).",
        "A rule that has A on the left-hand side and B1,...,Bn as right-hand side nonterminals has its left-hand side annotated with a well-formed /-term M that has type a(A) under the type environmentX1: a(B1),...,Xn: a(Bn) (in symbols, X1 : cr(BO,...,Xn : a(Bn) h M: a(A)).",
        "What we have called a context-free / term grammar is nothing but an alternative notation for an abstract categorial grammar (de Groote, 2001) whose abstract vocabulary is second-order, with the restriction to linear /-terms removed.",
        "In the linear case, Salvati (2005) has shown the recognition/parsing complexity to be PTIME, and exhibited an algorithm similar to Earley parsing for TAGs.",
        "Second-order S{/yX1(/z.z)y):- A(X1).",
        "A(/xy.ao – o(X1(/z.bo – o(x(co – oz)))(do – oy))) :- A(X1).",
        "A(/xy.xy).",
        "linear ACGs are known to be expressive enough to encode well-known mildly context-sensitive grammar formalisms in a straightforward way, including TAGs and multiple context-free grammars (de",
        "Groote, 2002; de Groote and Pogodalla, 2004).",
        "For example, the linear CFLG in Figure 8 is an encoding of the TAG in Figure 3, where a(S) = o – >o and a(A) = (o – > o) – > o – > o (see de Groote, 2002 for details of this encoding).",
        "In encoding a string-generating grammar, a CFLG uses o as the type of string position and o – > o as the type of string.",
        "Each terminal symbol is represented by a constant of type o – > o, and a string a1... an is encoded by the /-term /z.a°^o(... (ao_>oz)...), which has type o – > o.",
        "A string-generating grammar coupled with Montague semantics may be represented by a synchronous CFLG, a pair of CFLGs with matching rule sets (de Groote 2001).",
        "The transduction between strings and logical forms in either direction consists of parsing the input /-term with the source-side grammar and normalizing the /-term(s) constructed in accordance with the target-side grammar from the derivation tree(s) output by parsing."
      ]
    },
    {
      "heading": "3. Reduction to Datalog",
      "text": [
        "We show that under a weaker condition than linearity, a CFLG can be represented by a Datalog program, obtaining a tight upper bound (LOGCFL) on the recognition complexity.",
        "Due to space limitation, our presentation here is kept at an informal level; formal definitions and rigorous proof of correctness will appear elsewhere.",
        "We use the grammar in Figure 7 as an example, which is represented by the Datalog program in Figure 9.",
        "Note that all /-terms in this grammar are almost linear in the sense that they are /I-terms where any variable occurring free more than once in any subterm must have an atomic type.",
        "Our construction is guaranteed to be correct only when this condition is met.",
        "Each Datalog rule is obtained from the corresponding grammar rule in the following way.",
        "Let",
        "S(p1):- NP(p1, p2, p3), VP(p2, p3).",
        "VP(p1, p4):- V(p2, p4, p3), NP(p1, p2, p3).",
        "V(p2, p4, p3), Conj(p1, p5, p2), V(p5, p4, p3).",
        "NP(p1,p4,p5):- Det(p1,p4,p5,p2,p3), N(p2,p3).",
        "NP(p1,p1,p2):- John(p2).",
        "V(p1,p3,p2):- find(p1,p3,p2).",
        "V(p1,p3,p2):- catch(p1,p3,p2).",
        "Conj(p1,p3,p2):- A(p1,p3,p2).",
        "Det(p1, p5, p4, p3, p4):- 3(p1, p2, p4), A(p2, p5, p3).",
        "N(p1, p2):- unicorn(p1, p2).",
        "Figure 9: The Datalog representation of a CFLG.",
        "M be the /-term annotating the left-hand side of the grammar rule.",
        "We first obtain a principal (i.e., most general) typing of M. In the case of the second rule, this is /x.X2(/yX1yx): p4 – p1.",
        "We then remove – > and parentheses from the types in the principal typing and write the resulting sequences of atomic types in reverse.",
        "We obtain the Datalog rule by replacing Xi and Min the grammar rule with the sequence coming from the type paired with Xi and M, respectively.",
        "Note that atomic types in the principal typing become variables in the Datalog rule.",
        "When there are constants in the /-term M, they are treated like free variables.",
        "In the case of the second-to-last rule, the principal typing is",
        "/uv.B(/y.A(uy)(vy)):(p4 – p3) – (p4 – p5) – p1.",
        "If the same constant occurs more than once, distinct occurrences are treated as distinct free variables.",
        "The construction of the database representing the input /-term is similar, but slightly more complex.",
        "A simple case is the /-term (2), where each constant occurs just once.",
        "We compute its principal typing, treating constants as free variables.",
        "h 3(/y.A(unicorn y)(findy John)):1.",
        "We then obtain the corresponding database (3) and query (4) from the antecedent and succedent of this judgment, respectively.",
        "Note that here we are using 1,2,3,... as atomic types, which become database constants.",
        "(3) 3(1,2,4).",
        "A(2,5,3).",
        "unicorn(3,4).",
        "find(5,6,4).",
        "John(6).",
        "(4) ?- S(1).",
        "When the input /-term contains more than one occurrence of the same constant, it is not always correct to simply treat them as distinct free variables, unlike in the case of /-terms annotating grammar rules.",
        "Consider the /-term (5) (John found and caught a unicorn):",
        "(5) 3(/y.A(unicorny)(A(findy John)(catchy John))).",
        "Here, the two occurrences of John must be treated as the same variable.",
        "The principal typing is (6) and the resulting database is (7).",
        "(A2(find y John)(catch y John))): 1.",
        "(7) 3(1,2,4).",
        "A(2,5,3).",
        "A(5,8,6).",
        "unicron(3,4).",
        "find(6,7,4).",
        "John(7).",
        "catch(8,7,4).",
        "It is not correct to identify the two occurrences of A in this example.",
        "The rule is to identify distinct occurrences of the same constant just in case they occur in the same position within a-equivalent sub-terms of an atomic type.",
        "This is a necessary condition for those occurrences to originate as one and the same occurrence in the non-normal /-term at the root of the derivation tree.",
        "(As a preprocessing step, it is also necessary to check that distinct occurrences of a bound variable satisfy the same condition, so that the given /-term is S-equal to some almost linear /-term.)"
      ]
    },
    {
      "heading": "4. Correctness of the reduction",
      "text": [
        "We sketch some key points in the proof of correctness of our reduction.",
        "The /-term N obtained from the input /-term by replacing occurrences of constants by free variables in the manner described above is the normal form of some almost linear /-term N'.",
        "The leftmost reduction from an almost linear /-term to its normal form must be non-deleting and almost non-duplicating in the sense that when a /?-redex (/x.P)Q is contracted, Q is not deleted, and moreover it is not duplicated unless the type of x is atomic.",
        "We can show that the Subject Expansion Theorem holds for such /^-reduction, so the principal typing of N is also the principal typing of N'.",
        "By a slight generalization of a result by Aoto (1999), this typing r h N' : a must be negatively non-duplicated in the sense that each atomic type has at most one negative occurrence in it.",
        "By Aoto and Ono's (1994) generalization of the Coherence Theorem (see Mints, 2000), it follows that every /-term P such that r' h P : a for some r' c r must be Sr-equal to N' (and consequently to N).",
        "Given the one-one correspondence between the grammar rules and the Datalog rules, a Datalog derivation tree uniquely determines a grammar derivation tree (see Figure 10 as an example).",
        "This relation is not one-one, because a Datalog derivation tree contains database constants from the input database.",
        "This extra information determines a typing of the /-term P at the root of the grammar derivation tree (with occurrences of constants in the /-term corresponding to distinct facts in the database regarded as distinct free variables):",
        "(/x.",
        "(/uv.3(/y.A(uy)(vy))) unicorn (/y.findyx)): 1.",
        "The antecedent of this typing must be a subset of the antecedent of the principal typing of the /-term N from which the input database was obtained.",
        "By the property mentioned at the end of the preceding paragraph, it follows that the grammar derivation tree is a derivation tree for the input /-term.",
        "Conversely, consider the /-term P (with distinct occurrences of constants regarded as distinct free variables) at the root of a grammar derivation tree for the input /-term.",
        "We can show that there is a substitution 9 which maps the free variables of P to the free variables of the /-term N used to build the input database such that 9 sends the normal form of P to N. Since P is an almost linear /-term, the leftmost reduction from P9 to N is non-deleting and almost non-duplicating.",
        "By the Subject Expansion Theorem, the principal typing of N is also the principal typing of P9, and this together with the grammar derivation tree determines a Datalog derivation tree."
      ]
    },
    {
      "heading": "5. Complexity-theoretic consequences",
      "text": [
        "Let us call a rule A(M):- B1(X1),..., Bn(Xn)ina CFLG an e-rule if n = 0 and M does not contain any constants.",
        "We can eliminate e-rules from an almost linear CFLG by the same method that Kanazawa and Yoshinaka (2005) used for linear grammars, noting that for any r and a, there are only finitely many almost linear /-terms M such that r h M : a.If a grammar has no e-rule, any derivation tree for the input /-term N that has a /-term P at its root node corresponds to a Datalog derivation tree whose number of leaves is equal to the number of occurrences of constants in P, which cannot exceed the number of occurrences of constants in N.",
        "A Datalog program P is said to have the polynomial fringe property relative to a class D of databases if there is a polynomial p(n) such that for every database D in D of n facts and every query q such that PUD derives q, there is a derivation tree for q whose fringe (i.e., sequence of leaves) is of length at most p(n).",
        "For such P and D, it is known that {(D, q) | D eD, P U D derives q} is in the complexity class LOGCFL (Ullman and Van Gelder, 1988;",
        "Kanellakis, 1988).",
        "We state without proof that the database-query pair (D, q) representing an input /-term N can be computed in logspace.",
        "By padding D with extra useless facts so that the size of D becomes equal to the number of occurrences of constants in N, we obtain a logspace reduction from the set of /-terms generated by an almost linear CFLG to a set of the form {(D, q) | D eD, P U D h q}, where P has the polynomial fringe property relative to D. This shows that the problem of recognition for an almost linear",
        "CFLG is in LOGCFL.",
        "By the main result of Gottlob et al.",
        "(2002), the related search problem of finding one derivation tree for the input /-term is in functional LOGCFL, i.e., the class of functions that can be computed by a logspace-bounded Turing machine with a LOGCFL oracle.",
        "In the case of a synchronous almost linear CFLG, the derivation tree found from the source /-term can be used to compute a target /-term.",
        "Thus, to the extent that transduction back and forth between strings and logical forms can be expressed by a synchronous almost linear CFLG, the search problem of finding one logical form of an input sentence and that of finding one surface realization of an input logical form are both in functional LOGCFL.",
        "As a consequence, there are efficient parallel algorithms for these problems."
      ]
    },
    {
      "heading": "6. Regular sets of trees as input",
      "text": [
        "Almost linear CFLGs can represent a substantial fragment of a Montague semantics for English and such \"linear\" grammar formalisms as (multi-component) tree-adjoining grammars (both as string grammars and as tree grammars) and multiple context-free grammars.",
        "However, IO macro grammars and parallel multiple context-free grammars cannot be directly represented because representing string copying requires multiple occurrences of a variable of type o – > o.",
        "This problem can be solved by switching from strings to trees.",
        "We convert the input string into the regular set of binary trees whose yield equals the input string (using c",
        "logspace (Salvati, 2007).",
        "linear, the normal form of computed because its size source /-term.",
        "Neverthe-identify the target /-term tree in logspace.",
        "Also, if string-generating, the tar-from the derivation tree in",
        "as the sole symbol of rank 2), and turn the grammar into a tree grammar, replacing all instances of string concatenation in the grammar with the tree operation t1, t2 i~» c(t1, t2).",
        "This way, a string grammar is turned into a tree grammar that generates a set of trees whose image under the yield function is the language of the string grammar.",
        "(In the case of an IO macro grammar, the result is an IO context-free tree grammar (Engelfriet, 1977).)",
        "String copying becomes tree copying, and the resulting grammar can be represented by an almost linear CFLG and hence by a Datalog program.",
        "The regular set of all binary trees that yield the input string is represented by a database that is constructed from a deterministic bottom-up finite tree automaton recognizing it.",
        "Determinism is important for ensuring correctness of this reduction.",
        "Since the database can be computed from the input string in logspace, the complexity-theoretic consequences of the last section carry over here."
      ]
    },
    {
      "heading": "7. Magic sets and Earley-style algorithms",
      "text": [
        "Magic-sets rewriting of a Datalog program allows bottom-up evaluation to avoid deriving useless facts by mimicking top-down evaluation of the original program.",
        "The result of the generalized supplementary magic-sets rewriting of Beeri and Ramakrish-nan (1991) applied to the Datalog program representing a CFG essentially coincides with the deduction system (Shieber et al., 1995) or uninstantiated parsing system (Sikkel, 1997) for Earley parsing.",
        "By applying the same rewriting method to Datalog programs representing almost linear CFLGs, we can obtain efficient parsing and generation algorithms for various grammar formalisms with context-free derivations.",
        "We illustrate this approach with the program in Figure 4, following the presentation of Ullman (1989a; 1989b).",
        "We assume the query to take the form \"?- S(0, x).",
        "\", so that the input database can be processed incrementally.",
        "The program is first made safe by eliminating the possibility of deriving non-ground atoms:",
        "S(pi, P3):-A(pi, P3, p2, P2).",
        "A(pi, P8,P4, P5):- A(P2,P7, P3, P6), a(pi, P2), Kp3, P4), c(p5, P6), d(P7,P8).",
        "A(pi, P8,P4, P5):- a(pi, P2), b(P2, P4), c(P5, P6), d(P6,P8).",
        "The subgoal rectification removes duplicate arguments from subgoals, creating new predicates as needed:",
        "S(Pi,P3):- B(Pi,P3,P2).",
        "A(Pi, P8, P4, P5):- A(P2, P7, P3, P6), a(pi, P2), b(P3, P4), C(P5, P6), d(P7, P8).",
        "A(Pi,P8,P4,P5):- a(pi,P2), b(P2,P4), c(P5,P6), d(P6,P8).",
        "B(Pi, P8, P4):-A(P2, P7, P3, P6), a(Pi, P2), b( P3, P4), c( P4, P6), d(P7, P8).",
        "B(Pi,P8,P4):- a(Pi,P2),b(P2,P4), c(P4,P6),d(P6,P8).",
        "We then attach to predicates adornments indicating the free/bound status of arguments in top-down evaluation, reordering subgoals so that as many arguments as possible are marked as bound:",
        "Sbf( Pi, P3):-Bbff(pi, P3, P2).",
        "dbf(P7, P8).",
        "Bbff(Pi,P8,P4):- abf(Pi,P2),bbf(P2,P4), cbf(P4,P6), dbf(P6,P8).",
        "Abfff(Pi,P8,P4,P5):- abf(Pi,P2),bbf(P2,P4), cff(p5,P6),dbf(P6,P8).",
        "The generalized supplementary magic-sets rewriting finally gives the following rule set:",
        "ri: mJ5(Pi) \\ - m_S(Pi).",
        "ri: S(Pi,P3):-m-B(Pi),B(Pi,P3,P2).",
        "r3: suP2.i(Pi,P2):-m_B(pi)>a(Pi,P2).",
        "r4: suP2.2(Pi,P7,P3,P6):- sup2A(pi,P2),A(p2,P7,P3,P6).",
        "sup23(pi, P7, P6, P4):- Sup2.2(Pi, P7, P3, P&), b(P3, P4) Sup2A(pi, P7, P4):- sup2.3(pi, P7, P6, P4), c(p4, P6).",
        "r7: B(pi,p8,P4):-sup2A(pi,P7,P4),d(p7,p8).",
        "r8: sup3.i(pi,P2):-m_B(pi)>a(pi,P2).",
        "r9: sup3.2(pi,P4):-sup3.i(pi,P2),b(p2,P4).",
        "rio: sup3.3(pi,p4,P6):-sup^^pi,P4),c(p4,P6).",
        "rn: B(pi,p8,P4):-sup3.3(pi,P4,P6),d(p6,P8).",
        "ri2: mJi(p2):- sup2A(pi,P2).",
        "ri3: m-A(p2):- sup4A(pi,p2).",
        "ri4: sup4.i(pi,P2):-mjA(Pi), a(pi,P2).",
        "ri5: sup4.2(Pi,P7,P3,P6):- sup4A(pi,P2),A(p2,P7,P3,P6).",
        "ri6: sup4.3(pi,P7,P6,P4):- sup4.2(Pi,P7,P3,P6), b(p3,P4) ri7: sup4.4(pi, P7, P4, P5):- sup43(pU P7, P6, P4), c(p5, P6).",
        "ri8: A(pi,p8,P4,P5):-sup4A(puP7,P4,P5),d(p7,p8).",
        "ri9: sup5.i(pi,P2):-mJi(pi), a(pi,P2).",
        "r2o: sup5.2(pi, P4):-sup5A(pi, p2), b(p2, P4).",
        "r2i: sup5.3(pi, p4, p5, P6):- sup52(pi, P4), c(p5, P6).",
        "r22: A(pi,p8,p4,P5):-sup 53^,P4,P5,P6),d(p6,P8).",
        "The following version of chart parsing adds control structure to this deduction system:",
        "1.",
        "(init) Initialize the chart to the empty set, the agenda to the singleton {m J>(0)}, and n to 0."
      ]
    },
    {
      "heading": "2.. Repeat the following steps:",
      "text": [
        "(a) Repeat the following steps until the agenda is exhausted:",
        "i.",
        "Remove a fact from the agenda, called the trigger.",
        "ii.",
        "Add the trigger to the chart.",
        "iii.",
        "Generate all facts that are immediate consequences of the trigger together with all facts in the chart, and add to the agenda those generated facts that are neither already in the chart nor in the agenda.",
        "(b) (scan) Remove the next fact from the input database and add it to the agenda, incrementing n. If there is no more fact in the input database, go to step 3.",
        "3.",
        "If S(0, n) is in the chart, accept; otherwise reject.",
        "The following is the trace of the algorithm on input string aabbccdd:",
        "Note that unlike existing Earley-style parsing algorithms for TAGs, the present algorithm is an instantiation of a general schema that applies to parsing with more powerful grammar formalisms as well as to generation with Montague semantics."
      ]
    },
    {
      "heading": "8. Conclusion",
      "text": [
        "Our reduction to Datalog brings sophisticated techniques for Datalog query evaluation to the problems of parsing and generation, and establishes a tight bound on the computational complexity of recognition for a wide range of grammars.",
        "In particular, it shows that the use of higher-order /-terms for semantic representation need not be avoided for the purpose of achieving computational tractability.",
        "i.",
        "m_S(0)",
        "INIT",
        "i4.",
        "c(4, 5)",
        "SCAN",
        "2.",
        "m_B(0)",
        "ri, i",
        "i5.",
        "sup53(i, 3,4,5)",
        "r2i, i2, i4",
        "3.",
        "a(0, i)",
        "SCAN",
        "i6.",
        "c(6, 5)",
        "SCAN",
        "4.",
        "sup2.i(0, i)",
        "r3, 2, 3",
        "i7.",
        "suP5 3(i , 3, 5, 6)",
        "r2i, i2, i6",
        "5.",
        "sup3 i(0, i)",
        "r8, 2, 3",
        "i8.",
        "d(6, 7)",
        "SCAN",
        "6.",
        "m^t(i)",
        "ri2,",
        "i9.",
        "A(i , 7, 3, 5)",
        "r22, i7, i8",
        "7.",
        "a(i, 2)",
        "SCAN",
        "20.",
        "suP2 2(0, 7, 3, 5)",
        "r4, 4, i9",
        "8.",
        "sup4i(i, 2)",
        "ri4, 6,",
        "2i.",
        "sup2.3(0,7,5,4)",
        "r5, i3,20",
        "9.",
        "sup5.i(i, 2)",
        "ri9,6,7",
        "22.",
        "suP2 4(0,7,4)",
        "r6, i4,2i",
        "io.",
        "m^t(2)",
        "ri3,8",
        "23.",
        "d(7, 8)",
        "SCAN",
        "ii.",
        "b(2, 3)",
        "SCAN",
        "24.",
        "B(0, 8, 4)",
        "r7, 22, 23",
        "i2.",
        "sup5.2(i, 3)",
        "r20, 9, ii",
        "25.",
        "S(0, 8)",
        "r2,2,24",
        "i3.",
        "b(3, 4)",
        "SCAN"
      ]
    }
  ]
}
