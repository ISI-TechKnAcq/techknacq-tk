{
  "info": {
    "authors": [
      "Daniel Quernheim",
      "Kevin Knight"
    ],
    "book": "Proceedings of the 10th International Workshop on Finite State Methods and Natural Language Processing",
    "id": "acl-W12-6207",
    "title": "DAGGER: A Toolkit for Automata on Directed Acyclic Graphs",
    "url": "https://aclweb.org/anthology/W12-6207",
    "year": 2012
  },
  "references": [
    "acl-J08-3004",
    "acl-J97-2003",
    "acl-N06-1045",
    "acl-N09-4005",
    "acl-P03-2041",
    "acl-W90-0108"
  ],
  "sections": [
    {
      "heading": "Abstract",
      "text": [
        "This paper presents DAGGER, a toolkit for finite-state automata that operate on directed acyclic graphs (dags).",
        "The work is based on a model introduced by (Kamimura and Slutzki, 1981; Kamimura and Slutzki, 1982), with a few changes to make the automata more applicable to natural language processing.",
        "Available algorithms include membership checking in bottom-up dag acceptors, transduction of dags to trees (bottom-up dag-to-tree transducers), k-best generation and basic operations such as union and intersection."
      ]
    },
    {
      "heading": "1 Introduction",
      "text": [
        "Finite string automata and finite tree automata have proved to be useful tools in various areas of natural language processing (Knight and May, 2009).",
        "However, some applications, especially in semantics, require graph structures, in particular directed acyclic graphs (dags), to model reentrancies.",
        "For instance, the dags in Fig. 1 represents the semantics of the sentences ?The boy wants to believe the girl?",
        "and ?The boy wants the girl to believe him.?",
        "The double role of ?the boy?",
        "is made clear by the two parent edges of the BOY node, making this structure non-tree-like.",
        "Powerful graph rewriting systems have been used for NLP (Bohnet and Wanner, 2010), yet we consider a rather simple model: finite dag automata that have been introduced by (Kamimura and Slutzki, 1981; Kamimura and Slutzki, 1982) as a straightforward extension of tree automata.",
        "We present the toolkit DAGGER (written in PYTHON) that can be used to visualize dags and to build dag acceptors",
        "(b) ?The boy wants the girl to believe him.?",
        "First edge",
        "represents :agent role, second edge represents :patient role.",
        "and dag-to-tree transducers similar to their model.",
        "Compared to those devices, in order to use them for actual NLP tasks, our machines differ in certain aspects: ?",
        "We do not require our dags to be planar, and we do not only consider derivation dags.",
        "?",
        "We add weights from any commutative semir-ing, e.g. real numbers.",
        "The toolkit is available under an open source licence.1"
      ]
    },
    {
      "heading": "2 Dags and dag acceptors",
      "text": [
        "DAGGER comes with a variety of example dags and automata.",
        "Let us briefly illustrate some of them.",
        "The dag of Fig. 1(a) can be defined in a human-readable",
        "In this format, every node has a unique identifier, and edge labels start with a colon.",
        "The tail node of an edge is specified as a whole subdag, or, in the case of a reentrancy, is referred to with its identifier.",
        "Fig.",
        "2 shows a dag acceptor.",
        "The first line contains the final state, and the remaining lines contain rules.",
        "Mind that the rules are written in a top-down fashion, but are evaluated bottom-up for now.",
        "Let us consider a single rule: s -> (WANT :agent i :patient s) The right-hand side is a symbol (WANT :agent :patient) whose tail edges are labeled with states (i and s), and after applying the rule, its head edges are labeled with new states (s).",
        "All rules are height one, but in the future we will allow for larger subgraphs.",
        "In order to deal with symbols of arbitrary head rank (i.e. symbols that can play multiple roles), we can use rules using special symbols such as 2=1 and 3=1 that split one edge into more than one: i s -> (2=1 :arg e) Using these state-changing rules, the ruleset can be simplified (see Fig. 3), however the dags look a bit different now:",
        "Note that we also added weights to the ruleset now.",
        "Weights are separated from the rest of a rule by the @ sign.",
        "The weight semantics is the usual one, where weights are multiplied along derivation steps, while the weights of alternative derivations are added."
      ]
    },
    {
      "heading": "2.1 Membership checking and derivation forests",
      "text": [
        "DAGGER is able to perform various operations on dags.",
        "The instructions can be given in a simple expression language.",
        "The general format of an expression is: (command f1 .. fm p1 .. pn) Every command has a number of (optional) features fi and a fixed number of arguments pi.",
        "Most commands have a short and a long name; we will use the short names here to save space.",
        "In order to evaluate a expression, you can either",
        "?",
        "supply it on the command-line: ./dagger.py e EXPRESSION ?",
        "or read from a file: ./dagger.py f FILE",
        "We will now show a couple of example expressions that are composed of smaller expressions.",
        "Assume that the dag acceptor of Fig. 2 is saved in the file example.bda, and the file boywants.dag contains the example dag in PENMAN format.",
        "We can load the dag with the expression (g (f boywants.dag)), and the acceptor with the expression (a w (f example.bda)) where w means that the acceptor is weighted.",
        "We could also specify the dag directly in PENMAN format using p instead of f. We can use the command r: (r (a w (f example.bda)) (g (f boywants.dag))) to check whether example.bda recognizes boywants.dag.",
        "This will output one list item",
        "for each successful derivation (and, if the acceptor is weighted, their weights), in this case: (?s?, ?0.1?, 0, ?0?",
        "), which means that the acceptor can reach state s with a derivation weighted 0.1.",
        "The rest of the output concerns dag-to-tree transducers and will be explained later.",
        "Note that in general, there might be multiple derivations due to ambiguity (non-determinism).",
        "Fortunately, the whole set of derivations can be efficiently represented as another dag acceptor with the d command.",
        "This derivation forest acceptor has the set of rules as its symbol and the set of configurations (state-labelings of the input dag) as its state set.",
        "(d (a w (f example.bda)) (g f boywants.dag))) will write the derivation forest acceptor to the standard output."
      ]
    },
    {
      "heading": "2.2 k-best generation",
      "text": [
        "To obtain the highest-weighted 7 dags generated by the example dag acceptor, run:",
        "If the acceptor is unweighted, the smallest dags (in terms of derivation steps) are returned."
      ]
    },
    {
      "heading": "2.3 Visualization of dags",
      "text": [
        "Both dags and dag acceptors can be visualized using GRAPHVIZ2.",
        "For this purpose, we use the q (query) command and the v feature:",
        "Dag acceptors are represented as hypergraphs, where the nodes are the states and each hyperedge represents a rule labeled with a symbol."
      ]
    },
    {
      "heading": "2.4 Union and intersection",
      "text": [
        "In order to construct complex acceptors from simpler building blocks, it is helpful to make use of union (u) and intersection (i).",
        "The following code will intersect two acceptors and return the 5 best dags of the intersection acceptor.",
        "(k 5 (i (a (f example.bda)) (a (f someother.bda)))) Weighted union, as usual, corresponds to sum, weighted intersection to product.",
        "string automata tree automata dag automata compute .",
        ".",
        ".",
        "strings (sentences) .",
        ".",
        ".",
        "(syntax) trees .",
        ".",
        ".",
        "semantic representations k-best .",
        ".",
        ".",
        "paths through a WFSA (Viterbi,"
      ]
    },
    {
      "heading": "3 Dag-to-tree transducers",
      "text": [
        "Dag-to-tree transducers are dag acceptors with tree output.",
        "In every rule, the states on the right-hand sides have tree variables attached that are used to build one tree for each state on the left-hand side.",
        "A fragment of an example dag-to-tree transducer can be seen in Fig. 5.",
        "Let us see what happens if we apply this transducer to our example dag: (r (a t (f example.bdt)) (g (f boywants.dag))) All derivations including output trees will be listed: (?q?, ?1.0?, S(NP(the boy) wants INF(NP(the girl) to believe NP(him))), ?the boy wants the girl to believe him?)",
        "A graphical representation of this derivation (top-down instead of bottom-up for illustrative purposes) can be seen in Fig. 4."
      ]
    },
    {
      "heading": "3.1 Backward application and force decoding",
      "text": [
        "Sometimes, we might want to see which dags map to a certain input tree in a dag-to-tree transducer.",
        "This is called backward application since we use the transducer in the reverse direction: We are currently implementing this by ?generation and checking?, i.e. a process that generates dags and trees at the same time.",
        "Whenever a partial tree does not match the input tree, it is discarded, until we find a derivation and a dag for the input tree.",
        "If we also restrict the dag part, we have force decoding."
      ]
    },
    {
      "heading": "4 Future work",
      "text": [
        "This work describes the basics of a dag automata toolkit.",
        "To the authors?",
        "knowledge, no such implementation already exists.",
        "Of course, many algorithms are missing, and there is a lot of room for improvement, both from the theoretical and the practical viewpoint.",
        "This is a brief list of items for future research (Quernheim and Knight, 2012): ?",
        "Complexity analysis of the algorithms.",
        "?",
        "Closure properties of dag acceptors and dag-to-tree transducers as well as composition with tree transducers.",
        "?",
        "Extended left-hand sides to condition on a larger semantic context, just like extended top-down tree transducers (Maletti et al., 2009).",
        "?",
        "Handling flat, unordered, sparse sets of relations that are typical of feature structures.",
        "Currently, rules are specific to the rank of the nodes.",
        "A first step in this direction could be gone by getting rid of the explicit n=m symbols.",
        "?",
        "Hand-annotated resources such as (dag, tree) pairs, similar to treebanks for syntactic representations as well as a reasonable probabilistic model and training procedures.",
        "?",
        "Useful algorithms for NLP applications that exist for string and tree automata (cf. Table 1).",
        "The long-term goal could be to build a semantics-based machine translation pipeline."
      ]
    },
    {
      "heading": "Acknowledgements",
      "text": [
        "This research was supported in part by ARO grant W911NF-101-0533.",
        "The first author was supported by the German Research Foundation (DFG) grant MA 4959/1?1."
      ]
    }
  ]
}
