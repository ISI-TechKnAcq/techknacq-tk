{
  "info": {
    "authors": [
      "Martin Jansche"
    ],
    "book": "45th Annual Meeting of the Association of Computational Linguistics",
    "id": "acl-P07-1093",
    "title": "A Maximum Expected Utility Framework for Binary Sequence Labeling",
    "url": "https://aclweb.org/anthology/P07-1093",
    "year": 2007
  },
  "references": [
    "acl-H05-1087",
    "acl-J99-4005",
    "acl-P03-1006",
    "acl-P06-1028"
  ],
  "sections": [
    {
      "text": [
        "Martin Jansche*",
        "jansche@acm.org",
        "We consider the problem of predictive inference for probabilistic binary sequence labeling models under F-score as utility.",
        "For a simple class of models, we show that the number of hypotheses whose expected F-score needs to be evaluated is linear in the sequence length and present a framework for efficiently evaluating the expectation of many common loss/utility functions, including the F-score.",
        "This framework includes both exact and faster inexact calculation methods."
      ]
    },
    {
      "heading": "1. Introduction",
      "text": [
        "The weighted F-score (van Rijsbergen, 1974) plays an important role in the evaluation of binary classifiers, as it neatly summarizes a classifier's ability to identify the positive class.",
        "A variety of methods exists for training classifiers that optimize the F-score, or some similar trade-off between false positives and false negatives, precision and recall, sensitivity and specificity, type I error and type II error rate, etc.",
        "Among the most general methods are those of Mozer et al.",
        "(2001), whose constrained optimization technique is similar to those in (Gao et al., 2006; Jansche, 2005).",
        "More specialized methods also exist, for example for support vector machines (Musicant et al., 2003) and for conditional random fields (Gross et al., 2007; Suzuki etal., 2006).",
        "All of these methods are about classifier training.",
        "In this paper we focus primarily on the related, but orthogonal, issue of predictive inference with a fully trained probabilistic classifier.",
        "Using the weighted F-score as our utility function, predictive inference amounts to choosing an optimal hypothesis which maximizes the expected utility.",
        "We refer to this as the prediction or decoding task.",
        "In general, decoding can be a hard computational problem (Casacuberta and de la Higuera, 2000; Knight, 1999).",
        "In this paper we show that the maximum expected F-score decoding problem can be solved in polynomial time under certain assumptions about the underlying probability model.",
        "One key ingredient in our solution is a very general framework for evaluating the expected F-score, and indeed many other utility functions, of a fixed hypothesis.",
        "This framework can also be applied to discriminative classifier training.",
        "We formulate our approach in terms of sequence labeling, although it has applications beyond that.",
        "This is motivated by the fact that our framework for evaluating expected utility is indeed applicable to general sequence labeling tasks, while our decoding method is more restricted.",
        "Another reason is that the F-score is only meaningful for comparing two (multi)sets or two binary sequences, but the notation for multisets is slightly more awkward.",
        "All tasks considered here involve strings of binary labels.",
        "We write the length of a given string y e {0,1 }n as |y | = n. It is convenient to view such strings as real vectors - whose components happen to be 0 or 1 - with the dot product defined as usual.",
        "Then y • y is the number of ones that occur in the string y.",
        "For two strings x,y of the same length |x| = |y| the number of ones that occur at corresponding indices is x • y.",
        "Given a hypothesis z and a gold standard label sequence y, we define the following quantities:"
      ]
    },
    {
      "heading": "2.. P = z • z, the predicted positives;",
      "text": [
        "3.",
        "A = z • y, the true positives (predicted positives that are genuinely positive);",
        "*Current affiliation: Google Inc. Former affiliation: Center of Computational Learning Systems, Columbia University."
      ]
    },
    {
      "heading": "4.. Reel = A/T, recall (a.k.a. sensitivity or power);",
      "text": [
        "5.",
        "Prec = A/P, precision.",
        "The j6-weighted F-score is then defined as the weighted harmonic mean of recall and precision.",
        "This simplifies to where we assume for convenience that 0/0 = 1 to avoid explicitly dealing with the special case of the denominator being zero.",
        "We will write the weighted F-score from now on as F (z, y) to emphasize that it is a function of z and y.",
        "In Section 3 we will develop a method for evaluating the expectation of the F-score, which can also be used as a smooth approximation of the raw F-score during classifier training: in that task (which we will not discuss further in this paper), z are the supervised labels, y is the classifier output, and the challenge is that F< z, y) does not depend smoothly on the parameters of the classifier.",
        "Gradient-based optimization techniques are not applicable unless some of the quantities defined above are replaced by approximations that depend smoothly on the classifier's parameters.",
        "For example, the constrained optimization method of (Mozer et al., 2001) relies on approximations of sensitivity (which they call CA) and specificity (their CR); related techniques (Gao et al., 2006; Jansche, 2005) rely on approximations of true positives, false positives, and false negatives, and, indirectly, recall and precision.",
        "Unlike these methods we compute the expected F-score exactly, without relying on ad hoc approximations of the true positives, etc.",
        "Being able to efficiently compute the expected F-score is a prerequisite for maximizing it during decoding.",
        "More precisely, we compute the expectation of the function which is a unary function obtained by holding the first argument of the binary function F fixed.",
        "It will henceforth be abbreviated as F(z, •), and we will denote its expected value by",
        "This expectation is taken with respect to a probability model over binary label sequences, written as Pr(y) for simplicity.",
        "This probability model may be conditional, that is, in general it will depend on covariates x and parameters 6.",
        "We have suppressed both in our notation, since x is fixed during training and decoding, and we assume that the model is fully identified during decoding.",
        "This is for clarity only and does not limit the class of models, though we will introduce additional, limiting assumptions shortly.",
        "We are now ready to tackle the inference task formally."
      ]
    },
    {
      "heading": "2. Maximum Expected F-Score Inference 2.1 Problem Statement",
      "text": [
        "Optimal predictive inference under F-score utility requires us to find an hypothesis z of length n which maximizes the expected F-score relative to a given probabilistic sequence labeling model:",
        "z = argmaxE [F(z, •)] = argmax£F(z,y) Pr(y).",
        "We require the probability model to factor into independent Bernoulli components (Markov order zero):",
        "In practical applications we might choose the overall probability distribution to be the product of independent logistic regression models, for example.",
        "Ordinary classification arises as a special case when the y, are i.i.d., that is, a single probabilistic classifier is used to find Pr(y, = 1 | x,).",
        "For our present purposes it is sufficient to assume that the inference algorithm takes as its input the vector (p1,..., pn), where is the probability that y, = 1.",
        "The discrete maximization problem (4) cannot be solved naively, since the number of hypotheses that would need to be evaluated in a brute-force search for an optimal hypothesis z is exponential in the sequence length n. We show below that in fact only a few hypotheses (n +1 instead of 2n) need to be examined in order to find an optimal one.",
        "The inference algorithm is the intuitive one, analogous to the following simple observation: Start with the hypothesis z = 00... 0 and evaluate its raw F-score F (z, y) relative to a fixed but unknown binary string y.",
        "Then z will have perfect precision (no positive labels means no chance to make mistakes), and zero recall (unless y = z).",
        "Switch on any bit of z that is currently off.",
        "Then precision will decrease or remain equal, while recall will increase or remain equal.",
        "Repeat until z = 11 .",
        ".",
        ".",
        "1 is reached, in which case recall will be perfect and precision at its minimum.",
        "The inference algorithm for expected F-score follows the same strategy, and in particular it switches on the bits of z in order of non-increasing probability: start with 00... 0, then switch on the bit ii = argmax; p,, etc.",
        "until 11 .",
        ".",
        ".",
        "1 is reached.",
        "We now show that this intuitive strategy is indeed admissible.",
        "In general, maximization can be carried out piece-wise, since",
        "xeX xe{argmaxyeyf(y)|Fen(X)}",
        "where n(X) is any family (Fi, Y2,...) of nonempty subsets of X whose union ,Y, is equal to X.",
        "(Recursive application would lead to a divide-and-conquer algorithm.)",
        "Duplication of effort is avoided if n(X) is a partition of X.",
        "Here we partition the set {0,1}n into equivalence classes based on the number of ones in a string (viewed as a real vector).",
        "Define Sm to be the set consisting of all binary strings of fixed length n that contain exactly m ones.",
        "Then the maximization problem (4) can be transformed into an inner maximization followed by an outer maximization",
        "The key insight is that the inner maximization problem (6) can be solved analytically.",
        "Given a vector p = (p1,..., pn) of probabilities, define z(m) to be the binary label sequence with exactly m ones and nm zeroes where for all indices k we have",
        "(m) , (m) A ^ z - 1 A zk - 0 p, > Pk.",
        "Algorithm 1 Maximizing the Expected F-Score.",
        "2: I < – indices of p sorted by non-increasing probability 6: for j – 1 to n do",
        "In other words, the most probable m bits (according to p) in z(m) are set and the least probable nm bits are off.",
        "We rely on the following result, whose proof is deferred to Appendix A:",
        "Theorem 1.",
        "(Vs e Sm) E [F(z(m), •)] > E [F(s, •)].",
        "Because z(m) is maximal in Sm, we may equate z(m) = argmaxseSm E [F(s, •)] = s(m) (modulo ties, which can always arise with argmax).",
        "With the inner maximization (6) thus solved, the outer maximization (7) can be carried out naively, since only n + 1 hypotheses need to be evaluated.",
        "This is precisely what Algorithm 1 does, which keeps track of the maximum value in v. On termination z = argmaxsE[F(s, •)].",
        "Correctness follows directly from our results in this section.",
        "Algorithm 1 runs in time O(nlogn + nf (n)).",
        "A total of O(nlogn) time is required for accessing the vector p in sorted order (line 2).",
        "This dominates the O(n) time required to explicitly generate the optimal hypothesis (lines 13-14).",
        "The algorithm invokes a subroutine expecfF(z, p) a total of n + 1 times.",
        "This subroutine, which is the topic of the next section, evaluates, in time f(n), the expected F-score (with respect to p) of a given hypothesis z of length n."
      ]
    },
    {
      "heading": "3. Computing the Expected F-Score 3.1 Problem Statement",
      "text": [
        "We now turn to the problem of computing the expected value (3) of the F-score for a given hypothesis z relative to a fully identified probability model.",
        "The method presented here does not strictly require the zeroth-order Markov assumption (5) instated earlier (a higher-order Markov assumption will suffice), but it shall remain in effect for simplicity.",
        "As with the maximization problem (4), the sum in (3) is over exponentially many terms and cannot be computed naively.",
        "But observe that the F-score (1) is a (rational) function of integer counts which are bounded, so it can take on only a finite, and indeed small, number of distinct values.",
        "We shall see shortly that the function (2) whose expectation we wish to compute has a domain whose cardinality is exponential in n, but the cardinality of its range is polynomial in n. The latter is sufficient to ensure that its expectation can be computed in polynomial time.",
        "The method we are about to develop is in fact very general and applies to many other loss and utility functions besides the F-score.",
        "A few notions from real analysis are helpful because they highlight the importance of thinking about functions in terms of their range, level sets, and the equivalence classes they induce on their domain (the kernel of the function).",
        "A function g : Q – R is said to be s,mple if it can be expressed as a linear combination of indicator functions (characteristic functions):",
        "where K is a finite index set, ak e R, and Bk C Q.",
        "(Xs : S – {0,1} is the characteristic function of set S.)",
        "Let Q be a countable set and P be a probability measure on Q.",
        "Then the expectation of g is given by the Lebesgue integral of g. In the case of a simple function g as defined above, the integral, and hence the expectation, is defined as",
        "This gives us a general recipe for evaluating E[g] when Q is much larger than the range of g. Instead of computing the sum £yeQ g(y) P({y}) we can compute the sum in (8) above.",
        "This directly yields an efficient algorithm whenever K is sufficiently small and P (Bk) can be evaluated efficiently.",
        "The expected F-score is thus the Lebesgue integral of the function (2).",
        "Looking at the definition of the",
        "F-score in (1) we see that the only expressions which depend on y are A = z • y and T = y • y (P = z • z is fixed because z is).",
        "But 0 < z • y < y • y < n = |z|.",
        "Therefore F (z, •) takes on at most (n + 1)(n + 2)/2, i.e. quadratically many, distinct values.",
        "It is a simple function with",
        "z • z + J3 T B(a,t) = {y | z• y = A, y • y = T}.",
        "Observe that the family of sets (B(A T))(A t)eK partition (namely the kernel of F (z, •)) of the set Q = { 0, 1 } n of all label sequences of length n. In turn it gives rise to a function h : Q – K where h(y) = k iffy e Bk.",
        "The function h can be computed by a deterministic finite automaton, viewed as a sequence classifier: rather than assigning binary accept/reject labels, it assigns arbitrary labels from a finite set, in this case the index set K. For simplicity we show the initial portion of a slightly more general two-tape automaton h' in Figure 1.",
        "It reads the two sequences z and y on its two input tapes and counts the number of matching positive labels (represented as Y) as well as the number of positive labels on the second tape.",
        "Its behavior is therefore h'(z, y) = (z • y, y • y).",
        "The function h is obtained as a special case when z (the first tape) is fixed.",
        "Note that this only applies to the special case when Algorithm 2 Simple Function Instance for F-Score.",
        "Algorithm 3 Value of a Simple Function.",
        "1: Input: instance g of the simple function interface, strings z",
        "the family B = ( Bk) k K is a partition of Q.",
        "It is always possible to express any simple function in this way, but in general there may be an exponential increase in the size of K when the family B is required to be a partition.",
        "However for the special cases we consider here this problem does not arise.",
        "In general, what we will call the s^mp/ef^<nc^^on frick amounts to representing the simple function g whose expectation we want to compute by:"
      ]
    },
    {
      "heading": "1.. a finite index set K (perhaps implicit),",
      "text": []
    },
    {
      "heading": "2.. a deterministic finite state classifier h : Q – K,",
      "text": [
        "3. and a vector of coefficients (ak)keK.",
        "In practice, this means instantiating an interface with three methods: the start and transition function of the transducer which computes h' (and from which h can be derived), and an accessor method for the coefficients a. Algorithm 2 shows the F-score instance.",
        "Any simple function g expressed as an instance of this interface can then be evaluated very simply as g(x) = ah(x).",
        "This is shown in Algorithm 3.",
        "Evaluating E[g] is also straightforward: Compose the DFA h with the probability model p and use an algebraic path algorithm to compute the total probability mass P (Bk) for each final state k of the resulting automaton.",
        "If p factors into independent components as required by (5), the composition is greatly simAlgorithm 4 Expectation of a Simple Function.",
        "1: Input: instance g of the simple function interface, string z and probability vector p of length n 4: for i – 1 to n do 9: if k0 G N then 14: if k1 G N then 21: return E",
        "plified.",
        "If p incorporates label history (higher-order Markov assumption), nothing changes in principle, though the following algorithm assumes for simplicity that the stronger assumption is in effect.",
        "Algorithm 4 expands the following composed automaton, represented implicitly: the finite-state transducer h' specified as part of the simple function object g is composed on the left with the string z (yielding h) and on the right with the probability model p. The outer loop variable , is an index into z and hence a state in the automaton that accepts z; the variable k keeps track of the states of the automaton implemented by g; and the probability model has a single state by assumption, which does not need to be represented explicitly.",
        "Exploring the states in order of increasing , puts them in topological order, which means that the algebraic path problem can be solved in time linear in the size of the composed automaton.",
        "The maps M and N keep track of the algebraic distance from the start state to each intermediate state.",
        "On termination of the first outer loop (lines 4-17), the map M contains the final states together with their distances.",
        "The algebraic distance of a final state k is now equal to P (Bk), so the expected value E can be computed in the second loop (lines 18-20) as suggested by (8).",
        "When the utility function interface g is instantiated as in Algorithm 2 to represent the F-score, the runtime of Algorithm 4 is cubic in n, with very small constants.",
        "The first main loop iterates over n. The inner loop iterates over the states expanded at iteration z, of which there are O(z) many when dealing with the F-score.",
        "The second main loop iterates over the final states, whose number is quadratic in n in this case.",
        "The overall cubic runtime of the first loop dominates the computation.",
        "With other functions g the runtime of Algorithm 4 will depend on the asymptotic size of the index set K. If there are asymptotically as many intermediate states at any point as there are final states, then the general asymptotic runtime is O(n |K|).",
        "Many loss/utility functions are subsumed by the present framework.",
        "Zero-one loss is trivial: the automaton has two states (success, failure); it starts and remains in the success state as long as the symbols read on both tapes match; on the first mismatch it transitions to, and remains in, the failure state.",
        "Hamming (1950) distance is similar to zero-one loss, but counts the number of mismatches (bounded by n), whereas zero-one loss only counts up to a threshold of one.",
        "A more interesting case is given by the Pk-score (Beeferman et al., 1999) and its generalizations, which moves a sliding window of size k over a pair of label sequences (z, y) and counts the number of windows which contain a segment boundary on one of the sequences but not the other.",
        "To compute its expectation in our framework, all we have to do is express the sliding window mechanism as an automaton, which can be done very naturally (see the proof-of-concept implementation for further details)."
      ]
    },
    {
      "heading": "4. Faster Inexact Computations",
      "text": [
        "Because the exact computation of the expected F-score by Algorithm 4 requires cubic time, the overall runtime of Algorithm 1 (the decoder) is quartic.",
        "Faster decoding can be achieved by modifying Algorithm 4 to compute an approximation (in fact, a lower bound) of the expected F-score.",
        "This is done by introducing an additional parameter L which limits the number of intermediate states that get expanded.",
        "Instead of iterating over all states and their associated probabilities (inner loop starting at line 6), one iterates over the top L states only.",
        "We require that L > 1 for this to be meaningful.",
        "Before entering the inner loop the entries of the map M are expanded and, using the linear time selection algorithm, the top L entries are selected.",
        "Because each state that gets expanded in the inner loop has out-degree 2, the new state map N will contain at most 2L states.",
        "This means that we have an additional loop invariant: the size of M is always less than or equal to 2 L. Therefore the selection algorithm runs in time O(L), and so does the abridged inner loop, as well as the second outer loop.",
        "The overall runtime of this modified algorithm is therefore O(nL).",
        "If L is a constant function, the inexact computation of the expected F-score runs in linear time and the overall decoding algorithm in quadratic time.",
        "In particular if L = 1 the approximate expected F-score is equal to the F-score of the MAP hypothesis, and the modified inference algorithm reduces to a variant of Viterbi decoding.",
        "If L is a linear function of n, the overall decoding algorithm runs in cubic time.",
        "We experimentally compared the exact quartic-time decoding algorithm with the approximate decoding algorithm for L = 2 n and for L = 1.",
        "We computed the absolute difference between the expected F-score of the optimal hypothesis (as found by the exact algorithm) and the expected F-score of the winning hypothesis found by the approximate decoding algorithm.",
        "For different sequence lengths n e {1,..., 50} we performed 10 runs of the different decoding algorithms on randomly generated probability vectors p, where each p, was randomly drawn from a continuous uniform distribution on (0,1), or, in a second experiment, from a Beta(1/2,1/2) distribution (to simulate an over-trained classifier).",
        "For L = 1 there is a substantial difference of about",
        "preceding run in just one position.",
        "This means that the map data-structures only need to be recomputed from that position forward.",
        "However, this does not lead to an asymptotically faster algorithm in the worst case.",
        "0.6 between the expected F-scores of the winning hypothesis computed by the exact algorithm and by the approximate algorithm.",
        "Nevertheless the approximate decoding algorithm found the optimal hypothesis more than 99% of the time.",
        "This is presumably due to the additional regularization inherent in the discrete maximization of the decoder proper: even though the computed expected F-scores may be far from their exact values, this does not necessarily affect the behavior of the decoder very much, since it only needs to find the maximum among a small number of such scores.",
        "The error introduced by the approximation would have to be large enough to disturb the order of the hypotheses examined by the decoder in such a way that the true maximum is reordered.",
        "This generally does not seem to happen.",
        "For L = 2 n the computed approximate expected F-scores were indistinguishable from their exact values.",
        "Consequently the approximate decoder found the true maximum every time."
      ]
    },
    {
      "heading": "5. Conclusion and Related Work",
      "text": [
        "We have presented efficient algorithms for maximum expected F-score decoding.",
        "Our exact algorithm runs in quartic time, but an approximate cubic-time variant is indistinguishable in practice.",
        "A quadratic-time approximation makes very few mistakes and remains practically useful.",
        "We have further described a general framework for computing the expectations of certain loss/utility functions.",
        "Our method relies on the fact that many functions are sparse, in the sense of having a finite range that is much smaller than their codomain.",
        "To evaluate their expectations, we can use the simple function trick and concentrate on their level sets: it suffices to evaluate the probability of those sets/ events.",
        "The fact that the commonly used utility functions like the F-score have only polynomially many level sets is sufficient (but not necessary) to ensure that our method is efficient.",
        "Because the coefficients ak can be arbitrary (in fact, they can be generalized to be elements of a vector space over the reals), we can deal with functions that go beyond simple counts.",
        "Like the methods developed by Allauzen et al.",
        "(2003) and Cortes et al.",
        "(2003) our technique incorporates finite automata, but uses a direct threshold-counting technique, rather than a nondeterministic counting technique which relies on path multiplicities.",
        "This makes it easy to formulate the simultaneous counting of two distinct quantities, such as our A and T, and to reason about the resulting automata.",
        "The method described here is similar in spirit to those of Gao et al.",
        "(2006) and Jansche (2005), who discuss maximum expected F-score training of decision trees and logistic regression models.",
        "However, the present work is considerably more general in two ways: (1) the expected utility computations presented here are not tied in any way to particular classifiers, but can be used with large classes of probabilistic models; and (2) our framework extends beyond the computation of F-scores, which fall out as a special case, to other loss and utility functions, including the Pk score.",
        "More importantly, expected F-score computation as presented here can be exact, if desired, whereas the cited works always use an approximation to the quantities we have called A and T."
      ]
    },
    {
      "heading": "Acknowledgements",
      "text": [
        "Most of this research was conducted while I was affilated with the Center for Computational Learning Systems, Columbia University.",
        "I would like to thank my colleagues at Google, in particular Ryan McDonald, as well as two anonymous reviewers for valuable feedback.",
        "The proof of Theorem 1 employs the following lemma: Theorem 2.",
        "Forfixed n and p, /e/ s,/ e Smfor some m whIz 1 < m < n. Fur/her assume /ha/ s and / d^ffer on/y »1 /wo tos, , and k, »1 such a way /ha/ sj = 1, sk = 0; = 0, /k = 1; and p; > pk.",
        "Then E [F(s, •)] > E [F(/, •)].",
        "Proof.",
        "Express the expected F-score E[F(s, •)] as a sum and split the summation into two parts:",
        "£F(s,y) Pr(y) = £F(s,y) Pr(y) + £F(s,y) Pr(y).",
        "If y!",
        "= yk then F(s,y) = F(/,y), for three reasons: the number of ones in s and / is the same (namely m) by assumption; y is constant; and the number of true positives is the same, that is s • y = / • y.",
        "The latter holds because s and y agree everywhere except on t and k; if = yk = 0, then there are no true positives at t and k; and if = yk = 1 then is a true positive but skis not, and conversely /k is but is not.",
        "Therefore",
        "Focus on those summands where = yk.",
        "Specifically group them into pairs ( y, z) where y and z are identical except that = 1 and yk = 0, but = 0 and zk = 1.",
        "In other words, the two summations on the right-hand side of the following equality are carried out in parallel:",
        "£F(s,y) Pr(y)= £F(s,y) Pr(y) + £F(s,z) Pr(z).",
        "Then, focusing on s first:",
        "where A = s • z is the number of true positives between s and z (s and y have an additional true positive at t by construction); T = y • y = z • z is the number of positive labels in y and z (identical by assumption); and is the probability of y and z evaluated on all positions except for i and k. This equality holds because of the zeroth-order Markov assumption (5) imposed on Pr(y).",
        "C0 and C1 are constants that allow us to focus on the essential aspects.",
        "The situation for t is similar, except for the true positives:",
        "where all constants have the same values as above.",
        "But pf > pk by assumption, pk + C0 > 0, and C1 > 0, so we have",
        "and therefore",
        "£ F (s, y) Pr(y) > £ F (t, y) Pr(y).",
        "yy yi=yk yi=yk",
        "The theorem follows from equality (9) and inequality (10).",
        "□",
        "Proof of Theorem 1: (Vs e Sm) E [F (z(m), •)] > E [F (s, •)].",
        "Observe that z(m) e Sm by definition (see Section 2.3).",
        "For m = 0 and m = n the theorem holds trivially because Sm is a singleton set.",
        "In the nontrivial cases, Theorem 2 is applied repeatedly.",
        "The string z(m) can be transformed into any other string s Sm by repeatedly clearing a more likely set bit and setting a less likely unset bit.",
        "In particular this can be done as follows: First, find the indices where z(m) and s disagree.",
        "By construction there must be an even number of such indices; indeed there are equinumerous sets",
        "This holds because the total number of ones is fixed and identical in z(m) and s, and so is the total number of zeroes.",
        "Next, sort those indices by non-increasing probability and represent them as 11,..., tk and 71,..., jk.",
        "Let s0 = z(m).",
        "Then let s1 be identical to s0 except that = 0 and s j = 1.",
        "Form s2,..., sk along the same lines and observe that sk = s by construction.",
        "By definition of z(m) it must be the case that > pjr for all r e {1,..., k}.",
        "Therefore Theorem 2 applies at every step along the way from z(m) = s0 to sk = s, and so the expected utility is non-increasing along that path.",
        "□"
      ]
    }
  ]
}
